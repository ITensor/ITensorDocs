var documenterSearchIndex = {"docs":
[{"location":"DMRG.html#DMRG-1","page":"DMRG","title":"DMRG","text":"","category":"section"},{"location":"DMRG.html#","page":"DMRG","title":"DMRG","text":"dmrg","category":"page"},{"location":"DMRG.html#ITensors.dmrg","page":"DMRG","title":"ITensors.dmrg","text":"dmrg(H::MPO,psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, represented as a matrix product operator (MPO). The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\ndmrg(Hs::Vector{MPO},psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H. The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nThis version of dmrg accepts a representation of H as a Vector of MPOs, Hs = [H1,H2,H3,...] such that H is defined as H = H1+H2+H3+... Note that this sum of MPOs is not actually computed; rather the set of MPOs [H1,H2,H3,..] is efficiently looped over at  each step of the DMRG algorithm when optimizing the MPS.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\ndmrg(H::MPO,Ms::Vector{MPS},psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, subject to the constraint that the MPS is orthogonal to each of the MPS provided in the Vector Ms. The orthogonality constraint is approximately enforced by adding to H terms of  the form w|M1><M1| + w|M2><M2| + ... where Ms=[M1,M2,...] and w is the \"weight\" parameter, which can be adjusted through the optional weight keyword argument. The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\n","category":"function"},{"location":"QN.html#QN-1","page":"QN","title":"QN","text":"","category":"section"},{"location":"QN.html#Description-1","page":"QN","title":"Description","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"QN","category":"page"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"A QN object stores a collection of up to four named values such as (\"Sz\",1) or (\"N\",0).  These values can include a third integer \"m\" which makes them obey addition modulo m, for  example (\"P\",1,2) for a value obeying addition mod 2. (The default is regular integer addition).\n\nAdding or subtracting pairs of QN objects performs addition and subtraction element-wise on each of the named values. If a name is missing from the  collection, its value is treated as zero.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#Constructors-1","page":"QN","title":"Constructors","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"QN(qvs...)\nQN(name,val::Int,modulus::Int=1)\nQN(val::Int,modulus::Int=1)","category":"page"},{"location":"QN.html#ITensors.QN-Tuple","page":"QN","title":"ITensors.QN","text":"QN(qvs...)\n\nConstruct a QN from a set of up to four named value tuples.\n\nExamples\n\nq = QN((\"Sz\",1))\nq = QN((\"N\",1),(\"Sz\",-1))\nq = QN((\"P\",0,2),(\"Sz\",0)).\n\n\n\n\n\n","category":"method"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"QN(name,val::Int,modulus::Int=1)\n\nConstruct a QN with a single named value by providing the name, value, and optional modulus.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"QN(val::Int,modulus::Int=1)\n\nConstruct a QN with a single unnamed value (equivalent to the name being the empty string) with optional modulus.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#Properties-1","page":"QN","title":"Properties","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"val(q::QN,name)\nmodulus(q::QN,name)","category":"page"},{"location":"QN.html#ITensors.val-Tuple{QN,Any}","page":"QN","title":"ITensors.val","text":"val(q::QN,name)\n\nGet the value within the QN q corresponding to the string name\n\n\n\n\n\n","category":"method"},{"location":"QN.html#ITensors.modulus-Tuple{QN,Any}","page":"QN","title":"ITensors.modulus","text":"modulus(q::QN,name)\n\nGet the modulus within the QN q corresponding to the string name\n\n\n\n\n\n","category":"method"},{"location":"QN.html#Related-Functions-1","page":"QN","title":"Related Functions","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"zero(q::QN)","category":"page"},{"location":"QN.html#Base.zero-Tuple{QN}","page":"QN","title":"Base.zero","text":"zero(q::QN)\n\nReturns a QN object containing the same names as q, but with all values set to zero.\n\n\n\n\n\n","category":"method"},{"location":"DMRGObserver.html#DMRGObserver-1","page":"DMRGObserver","title":"DMRGObserver","text":"","category":"section"},{"location":"DMRGObserver.html#","page":"DMRGObserver","title":"DMRGObserver","text":"A DMRGObserver is a type of observer which offers certain useful, general purpose capabilities  for DMRG calculations such as measuring custom  local observables at each step and stopping DMRG early if certain energy convergence conditions are met.","category":"page"},{"location":"DMRGObserver.html#","page":"DMRGObserver","title":"DMRGObserver","text":"In addition to the example code below, more detailed  example code showing sample usage of DMRGObserver is included in the ITensor source, in the file 1d_ising_with_observer.jl under the folder examples/dmrg.","category":"page"},{"location":"DMRGObserver.html#Sample-Usage-1","page":"DMRGObserver","title":"Sample Usage","text":"","category":"section"},{"location":"DMRGObserver.html#","page":"DMRGObserver","title":"DMRGObserver","text":"In the following example, we have already made a Hamiltonian MPO H and initial MPS psi0 for a system of spins whose sites have an associated \"Sz\" operator defined. We construct a  DMRGObserver which measures \"Sz\" on each site at each step of DMRG, and also stops the calculation early if the energy no longer changes to a relative precision of 1E-7.","category":"page"},{"location":"DMRGObserver.html#","page":"DMRGObserver","title":"DMRGObserver","text":"Sz_observer = DMRGObserver([\"Sz\"],sites,energy_tol=1E-7)\n\nenergy, psi = dmrg(H,psi0,sweeps,observer=Sz_observer)\n\nfor (sw,Szs) in enumerate(measurements(Sz_observer)[\"Sz\"])\n  println(\"Total Sz after sweep $sw = \", sum(Szs)/N)\nend","category":"page"},{"location":"DMRGObserver.html#Constructors-1","page":"DMRGObserver","title":"Constructors","text":"","category":"section"},{"location":"DMRGObserver.html#","page":"DMRGObserver","title":"DMRGObserver","text":"DMRGObserver(;energy_tol::Float64,minsweeps::Int)\nDMRGObserver(ops::Vector{String},sites::Vector{<:Index};energy_tol::Float64,minsweeps::Int)","category":"page"},{"location":"DMRGObserver.html#ITensors.DMRGObserver-Tuple{}","page":"DMRGObserver","title":"ITensors.DMRGObserver","text":"DMRGObserver(;energy_tol=0.0,\n              minsweeps=2)\n\nConstruct a DMRGObserver by providing the energy tolerance used for early stopping, and minimum number of sweeps that must be done.\n\nenergy_tol: if the energy from one sweep to the next no longer changes by more than this amount, stop after the current sweep\nminsweeps: do at least this many sweeps\n\n\n\n\n\n","category":"method"},{"location":"DMRGObserver.html#ITensors.DMRGObserver-Tuple{Array{String,1},Array{#s76,1} where #s76<:Index}","page":"DMRGObserver","title":"ITensors.DMRGObserver","text":"DMRGObserver(ops::Vector{String}, \n             sites::Vector{<:Index};\n             energy_tol=0.0,\n             minsweeps=2)\n\nConstruct a DMRGObserver, provide an array of ops of operator names which are strings  recognized by the op function. Each of these operators will be measured on every site during every step of DMRG and the results  recorded inside the DMRGOberver for later analysis. The array sites is the basis of sites used to define the MPS and MPO for the DMRG calculation.\n\nOptionally, one can provide an energy tolerance used for early stopping, and minimum number of sweeps that must be done.\n\nenergy_tol: if the energy from one sweep to the next no longer changes by more than this amount, stop after the current sweep\nminsweeps: do at least this many sweeps\n\n\n\n\n\n","category":"method"},{"location":"DMRGObserver.html#Methods-1","page":"DMRGObserver","title":"Methods","text":"","category":"section"},{"location":"DMRGObserver.html#","page":"DMRGObserver","title":"DMRGObserver","text":"measurements(::DMRGObserver)\nDMRGMeasurement\nenergies(::DMRGObserver)","category":"page"},{"location":"DMRGObserver.html#ITensors.measurements-Tuple{DMRGObserver}","page":"DMRGObserver","title":"ITensors.measurements","text":"measurements(o::DMRGObserver)\n\nAfter using a DMRGObserver object o within a DMRG calculation, retrieve a dictionary of measurement results, with the keys being operator names and values being DMRGMeasurement objects.\n\n\n\n\n\n","category":"method"},{"location":"DMRGObserver.html#ITensors.DMRGMeasurement","page":"DMRGObserver","title":"ITensors.DMRGMeasurement","text":"A DMRGMeasurement object is an alias for Vector{Vector{Float64}}, in other words an array of arrays of real numbers.\n\nGiven a DMRGMeasurement M,the result for the  measurement on sweep n and site i as M[n][i].\n\n\n\n\n\n","category":"type"},{"location":"DMRGObserver.html#ITensors.energies-Tuple{DMRGObserver}","page":"DMRGObserver","title":"ITensors.energies","text":"energies(o::DMRGObserver)\n\nAfter using a DMRGObserver object o within a DMRG calculation, retrieve an array of the  energy after each sweep.\n\n\n\n\n\n","category":"method"},{"location":"Observer.html#observer-1","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"","category":"section"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"An observer is an object which can be passed to the ITensor DMRG algorithm, to allow measurements to be performed throughout the DMRG calculation and to set conditions for early stopping of DMRG.","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"The only requirement of an observer is that it is a subtype  of AbstractObserver. But to do something interesting, it should also overload at least one the methods measure! or checkdone!.","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"A general purpose observer type called DMRGObserver is included with ITensors which already provides some quite useful features. It accepts a list of strings naming local operators to be measured at each step of DMRG, with the results saved for later analysis. It also accepts an optional energy precision, and stops a DMRG calculation early if the energy no longer changes to this precision. For more details about the DMRGObserver type, see  the DMRGObserver documentation page.","category":"page"},{"location":"Observer.html#Defining-a-Custom-Observer-1","page":"Observer System for DMRG","title":"Defining a Custom Observer","text":"","category":"section"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"To define a custom observer, just make a struct with any name and internal fields you would like, and make this struct a subtype of AbstractObserver.","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"For example, let's make a type called DemoObserver as:","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"mutable struct DemoObserver <: AbstractObserver\n   energy_tol::Float64\n   last_energy::Float64\n\n   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)\nend\n","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"In this minimal example, our DemoObserver  contains a field energy_tol which we can use to set an early-stopping condition for DMRG, and an field last_energy which our observer will use internally to keep track of changes to the energy after each sweep.","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"Now to give our DemoObserver type a useful behavior we need to define overloads of the methods measure! and checkdone!. ","category":"page"},{"location":"Observer.html#Overloading-the-checkdone!-method-1","page":"Observer System for DMRG","title":"Overloading the checkdone! method","text":"","category":"section"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"Let's start with the checkdone! method. After each sweep of DMRG, the checkdone! method is  passed the observer object, as well as a set of keyword arguments which currently include:","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"energy: the current energy\npsi: the current wavefunction MPS\nsweep: the number of the sweep that just finished\noutputlevel: an integer stating the desired level of output","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"If the checkdone! function returns true, then the DMRG routine stops (recall that checkdone! is called only at the  end of a sweep).","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"In our example, we will just compare the energy keyword argument to the last_energy variable held inside the DemoObserver:","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"function ITensors.checkdone!(o::DemoObserver;kwargs...)\n  sw = kwargs[:sweep]\n  energy = kwargs[:energy]\n  if abs(energy-o.last_energy)/abs(energy) < o.energy_tol\n    println(\"Stopping DMRG after sweep $sw\")\n    return true\n  end\n  # Otherwise, update last_energy and keep going\n  o.last_energy = energy\n  return false\nend","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"(Recall that in order to properly overload the default behavior, the checkdone! method has to be imported from the ITensors module or preceded with ITensors.)","category":"page"},{"location":"Observer.html#Overloading-the-measure!-method-1","page":"Observer System for DMRG","title":"Overloading the measure! method","text":"","category":"section"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"The other method that an observer can overload is measure!. This method is called at every step of DMRG, so at every  site and for every sweep. The measure! method is passed the current observer object and a set of keyword arguments which include:","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"energy: the energy after the current step of DMRG\npsi: the current wavefunction MPS \nbond: the bond b that was just optimized, corresponding to sites (b,b+1) in the two-site DMRG algorihtm\nsweep: the current sweep number\nhalf_sweep: the half-sweep number, equal to 1 for a left-to-right, first half sweep, or 2 for the second, right-to-left half sweep\nspec: the Spectrum object returned from factorizing the local superblock wavefunction tensor in two-site DMRG\noutputlevel: an integer specifying the amount of output to show","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"For our minimal DemoObserver example here, we will just make a measure! function that prints out some of the information above, but in a more realistic setting one  could use the MPS psi to perform essentially arbitrary measurements.","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"function ITensors.measure!(o::DemoObserver; kwargs...)\n  energy = kwargs[:energy]\n  sweep = kwargs[:sweep]\n  bond = kwargs[:bond]\n  outputlevel = kwargs[:outputlevel]\n\n  if outputlevel > 0\n    println(\"Sweep $sweep at bond $bond, the energy is $energy\")\n  end\nend","category":"page"},{"location":"Observer.html#Calling-DMRG-with-the-Custom-Observer-1","page":"Observer System for DMRG","title":"Calling DMRG with the Custom Observer","text":"","category":"section"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"After defining an observer type and overloading at least one of the  methods checkdone! or measure! for it, one can construct an object of this type and pass it to the ITensor dmrg function using the observer keyword argument.","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"Continuing with our DemoObserver example above:","category":"page"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"obs = DemoObserver(1E-4) # use an energy tolerance of 1E-4\nenergy, psi = dmrg(H,psi0,sweeps; observer=obs, outputlevel=1)","category":"page"},{"location":"Observer.html#Complete-Sample-Code-1","page":"Observer System for DMRG","title":"Complete Sample Code","text":"","category":"section"},{"location":"Observer.html#","page":"Observer System for DMRG","title":"Observer System for DMRG","text":"using ITensors\n\nmutable struct DemoObserver <: AbstractObserver\n   energy_tol::Float64\n   last_energy::Float64\n\n   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)\nend\n\nfunction ITensors.checkdone!(o::DemoObserver;kwargs...)\n  sw = kwargs[:sweep]\n  energy = kwargs[:energy]\n  if abs(energy-o.last_energy)/abs(energy) < o.energy_tol\n    println(\"Stopping DMRG after sweep $sw\")\n    return true\n  end\n  # Otherwise, update last_energy and keep going\n  o.last_energy = energy\n  return false\nend\n\nfunction ITensors.measure!(o::DemoObserver; kwargs...)\n  energy = kwargs[:energy]\n  sweep = kwargs[:sweep]\n  bond = kwargs[:bond]\n  outputlevel = kwargs[:outputlevel]\n\n  if outputlevel > 0\n    println(\"Sweep $sweep at bond $bond, the energy is $energy\")\n  end\nend\n\nlet\n  N = 10\n  etol = 1E-4\n\n  s = siteinds(\"S=1/2\",N)\n\n  a = AutoMPO()\n  for n=1:N-1\n    a += \"Sz\",n,\"Sz\",n+1\n    a += 0.5,\"S+\",n,\"S-\",n+1\n    a += 0.5,\"S-\",n,\"S+\",n+1\n  end\n  H = MPO(a,s)\n  psi0 = randomMPS(s,4)\n\n  sweeps = Sweeps(5)\n  cutoff!(sweeps,1E-8)\n  maxdim!(sweeps,10,20,100)\n\n  obs = DemoObserver(etol)\n\n  println(\"Starting DMRG\")\n  energy, psi = dmrg(H,psi0,sweeps; observer=obs, outputlevel=1)\n\n  return\nend","category":"page"},{"location":"AutoMPO.html#AutoMPO-1","page":"AutoMPO","title":"AutoMPO","text":"","category":"section"},{"location":"AutoMPO.html#Description-1","page":"AutoMPO","title":"Description","text":"","category":"section"},{"location":"AutoMPO.html#","page":"AutoMPO","title":"AutoMPO","text":"AutoMPO","category":"page"},{"location":"AutoMPO.html#ITensors.AutoMPO","page":"AutoMPO","title":"ITensors.AutoMPO","text":"An AutoMPO stores a collection of operator terms, to be later summed together into an MPO by calling the function MPO on the AutoMPO object.  Each term is a product of local operators specified by names such as \"Sz\" or \"N\", times an optional coefficient which can be real or complex.\n\nWhich local operator names are available is determined by the function op associated with the TagType defined by special Index tags, such as \"S=1/2\",\"S=1\", \"Fermion\", and \"Electron\".\n\n\n\n\n\n","category":"type"},{"location":"AutoMPO.html#Methods-1","page":"AutoMPO","title":"Methods","text":"","category":"section"},{"location":"AutoMPO.html#","page":"AutoMPO","title":"AutoMPO","text":"add!\nMPO(::AutoMPO,::Vector{<:Index})","category":"page"},{"location":"AutoMPO.html#ITensors.add!","page":"AutoMPO","title":"ITensors.add!","text":"add!(ampo::AutoMPO,\n     op1::String, i1::Int)\n\nadd!(ampo::AutoMPO,\n     coef::Number,\n     op1::String, i1::Int)\n\nadd!(ampo::AutoMPO,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\nadd!(ampo::AutoMPO,\n     coef::Number,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\n+(ampo:AutoMPO, term::Tuple)\n\nAdd a single- or multi-site operator  term to the AutoMPO ampo. Each operator is specified by a name (String) and a site number (Int). The second version accepts a real or complex coefficient.\n\nThe + operator version of this function accepts a tuple with entries either (String,Int,String,Int,...) or (Number,String,Int,String,Int,...) where these tuple values are the same as valid inputs to the add! function. For inputting a very large number of terms (tuples) to an AutoMPO, consider using the broadcasted operator .+= which avoids reallocating the AutoMPO after each addition.\n\nExamples\n\nampo = AutoMPO()\n\nadd!(ampo,\"Sz\",2,\"Sz\",3)\n\nampo += (\"Sz\",3,\"Sz\",4)\n\nampo += (0.5,\"S+\",4,\"S-\",5)\n\nampo .+= (0.5,\"S+\",5,\"S-\",6)\n\n\n\n\n\n","category":"function"},{"location":"AutoMPO.html#ITensors.MPO-Tuple{AutoMPO,Array{#s76,1} where #s76<:Index}","page":"AutoMPO","title":"ITensors.MPO","text":"MPO(ampo::AutoMPO,sites::Vector{<:Index};kwargs...)\n\nConvert an AutoMPO object ampo to an MPO, with indices given by sites. The resulting MPO will have the indices sites[1], sites[1]', sites[2], sites[2]' etc. The conversion is done by an algorithm that compresses the MPO resulting from adding the AutoMPO terms together, often achieving the minimum possible bond dimension.\n\nExamples\n\nampo = AutoMPO()\nampo += (\"Sz\",1,\"Sz\",2)\nampo += (\"Sz\",2,\"Sz\",3)\nampo += (\"Sz\",3,\"Sz\",4)\n\nsites = siteinds(\"S=1/2\",4)\nH = MPO(ampo,sites)\n\n\n\n\n\n","category":"method"},{"location":"AdvancedUsageGuide.html#Advanced-ITensor-usage-guide-1","page":"Advanced usage guide","title":"Advanced ITensor usage guide","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#Installing-and-updating-ITensors.jl-1","page":"Advanced usage guide","title":"Installing and updating ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The ITensors package can be installed with the Julia package manager. Assuming you have already downloaded Julia, which you can get here, from the Julia REPL,  type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> add ITensors","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> import Pkg; Pkg.add(\"ITensors\")","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We recommend using ITensors.jl with Intel MKL in order to get the  best possible performance. If you have not done so already, you can  replace the current BLAS and LAPACK implementation used by Julia with  MKL by using the MKL.jl package. Please follow the instructions  here.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To use the latest version of ITensors.jl, use update ITensors.  We will commonly release new minor versions with bug fixes and  improvements. However, make sure to double check before doing this,  because new releases may be breaking.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To try the \"development branch\" of ITensors.jl (for example, if  there is a feature or fix we added that hasn't been released yet),  you can do add ITensors#master. You can switch back to the latest released version with add ITensors. Using the development/master branch is generally not encouraged unless you know what you are doing.","category":"page"},{"location":"AdvancedUsageGuide.html#Using-ITensors.jl-in-the-REPL-1","page":"Advanced usage guide","title":"Using ITensors.jl in the REPL","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"There are many ways you can write code based on ITensors.jl, ranging  from using it in the REPL to writing a small script to making a  package that depends on it.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"For example, you can just start the REPL from your command line like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"assuming you have an available version of Julia with the ITensors.jl package installed. Then just type:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"and start typing ITensor commands. For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> i = Index(2, \"i\")\n(dim=2|id=355|\"i\")\n\njulia> A = randomITensor(i, i')\nITensor ord=2 (dim=2|id=355|\"i\") (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=355|\"i\")\nDim 2: (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 1.2320011464276275  1.8504245734277216\n 1.0763652402177477  0.030353720156277037\n\njulia> (A*dag(A))[]\n3.9627443142240617","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Note that there are some \"gotchas\" with working in the REPL like this. Technically, all commands in the REPL are in the \"global scope\". The global scope might not work as you would expect, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> for _ in 1:3\n         A *= 2\n       end\nERROR: UndefVarError: A not defined\nStacktrace:\n [1] top-level scope at ./REPL[12]:2\n [2] eval(::Module, ::Any) at ./boot.jl:331\n [3] eval_user_input(::Any, ::REPL.REPLBackend) at /home/mfishman/software/julia-1.4.0/share/julia/stdlib/v1.4/REPL/src/REPL.jl:86\n [4] run_backend(::REPL.REPLBackend) at /home/mfishman/.julia/packages/Revise/AMRie/src/Revise.jl:1023\n [5] top-level scope at none:0","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"since the A inside the for-loop introduces a new local variable. Some alternatives are to wrap that part of the code in a let-block or a function:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> function f(A)\n         for _ in 1:3\n           A *= 2\n         end\n         A\n       end\nf (generic function with 1 method)\n\njulia> A = f(A)\nITensor ord=2 (dim=2|id=355|\"i\") (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=355|\"i\")\nDim 2: (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 9.85600917142102   14.803396587421773\n 8.610921921741982   0.2428297612502163","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In this particular case, you can alternatively modify the ITensor in-place:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> for _ in 1:3\n         A ./= 2\n       end\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=355|\"i\")\nDim 2: (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 1.2320011464276275  1.8504245734277216\n 1.0763652402177477  0.030353720156277037","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"A common place you might accidentally come across this is when you are creating a Hamiltonian with AutoMPO:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> N = 4;\n\njulia> sites = siteinds(\"S=1/2\",N);\n\njulia> ampo = AutoMPO();\n\njulia> for j=1:N-1\n         ampo += \"Sz\", j, \"Sz\", j+1\n       end\nERROR: UndefVarError: ampo not defined\nStacktrace:\n [1] top-level scope at ./REPL[16]:2\n [2] eval(::Module, ::Any) at ./boot.jl:331\n [3] eval_user_input(::Any, ::REPL.REPLBackend) at /home/mfishman/software/julia-1.4.0/share/julia/stdlib/v1.4/REPL/src/REPL.jl:86\n [4] run_backend(::REPL.REPLBackend) at /home/mfishman/.julia/packages/Revise/AMRie/src/Revise.jl:1023\n [5] top-level scope at none:0","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In this case, you can use ampo .+= (\"Sz\", j, \"Sz\", j+1), add!(ampo, \"Sz\", j, \"Sz\", j+1), or wrap your code in a let-block or function.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Take a look at Julia's documentation here for rules on scoping. Also note that this behavior is particular to Julia v1.4 and below, and is expected to change in v1.5.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Note that the REPL is very useful for prototyping code quickly, but working directly in the REPL and outside of functions can cause sub-optimal performance. See Julia's performance tips for more information.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We recommend the package OhMyREPL which adds syntax highlighting to the Julia REPL.","category":"page"},{"location":"AdvancedUsageGuide.html#Finding-documentation-interactively-1","page":"Advanced usage guide","title":"Finding documentation interactively","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Julia provides many tools for searching for documentation interactively at the REPL. Say that you want to learn more about how to use an ITensor from the command line. You can start by typing ? followed by ITensor:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors\n\njulia> ?ITensor\nsearch: ITensor ITensors itensor emptyITensor randomITensor\n\n  An ITensor is a tensor whose interface is independent of its\n  memory layout. Therefore it is not necessary to know the ordering\n  of an ITensor's indices, only which indices an ITensor has.\n  Operations like contraction and addition of ITensors automatically\n  handle any memory permutations.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> i = Index(2, \"i\")\n  (dim=2|id=287|\"i\")\n  \n  julia> A = randomITensor(i', i)\n  ITensor ord=2 (dim=2|id=287|\"i\")' (dim=2|id=287|\"i\")\n  NDTensors.Dense{Float64,Array{Float64,1}}\n  \n  julia> @show A;\n  A = ITensor ord=2\n  Dim 1: (dim=2|id=287|\"i\")'\n  Dim 2: (dim=2|id=287|\"i\")\n  NDTensors.Dense{Float64,Array{Float64,1}}\n   2×2\n   0.28358594718392427   1.4342219756446355\n   1.6620103556283987   -0.40952231269251566\n  \n  julia> @show inds(A);\n  inds(A) = IndexSet{2} (dim=2|id=287|\"i\")' (dim=2|id=287|\"i\") \n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"(the specific output may be different for different versions of ITensors.jl as we update the docs). You can use the help prompt (which you get by typing ? at the REPL) to print out documentation for types and methods.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Another way to get information about types is with the function fieldnames:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> fieldnames(ITensor)\n(:store, :inds)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"which shows the fields of a type. Note that in general the specific names of the fields and structures of types may change (we consider those to be internal details), however we often make functions to access the fields of a type that have the same name as the field, so it is a good place to get started. For example, you can access the storage and indices of an ITensor A with the functions store(A) and inds(A).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Another helpful function is apropos, which search through all documentation for a string (ignoring the case) and prints a list of all types and methods with documentation that contain the string. For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> apropos(\"IndexSet\")\nITensors.IndexSet\nITensors.push\nITensors.insertat\nITensors.getfirst\nITensors.commoninds\nITensors.pushfirst\nNDTensors.mindim\n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This can often return too much information. A helpful way to narrow down the search is with regular expressions, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> apropos(r\"ITensor.*IndexSet\")\nITensors.block\nITensors.hasinds\nITensors.ITensor\nNDTensors.inds","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"where the notation r\"...\" is Julia notation for making a string that will be interpreted as a regular expression. Here, we are searching for any documentation that contains the string \"ITensor\" followed at some point by \"IndexSet\". The notation .* is regular expression notation for matching any number of any type of character.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Based on the apropos function, we can make some helper functions that may be useful. For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"using ITensors\n\nfunction finddocs(s)\n  io = IOBuffer()\n  apropos(io, s)\n  v = chomp(String(take!(io)))\n  return split(v, \"\\n\")\nend\n\nfunction finddocs(s...)\n  intersect(finddocs.(s)...)\nend\n\nfound_methods = finddocs(\"indices\", \"set difference\")\ndisplay(found_methods)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"returns:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"3-element Array{SubString{String},1}:\n \"ITensors.noncommoninds\"\n \"Base.setdiff\"\n \"ITensors.uniqueinds\"","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"which are the functions that have docs that contain the strings \"indices\" and \"set difference\". We can print the docs for uniqueinds to find:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"help?> uniqueinds\nsearch: uniqueinds unique_siteinds uniqueind uniqueindex\n\n  uniqueinds(A, B; kwargs...)\n  uniqueinds(::Order{N}, A, B; kwargs...)\n\n\n  Return an IndexSet with indices that are unique to the set of\n  indices of A and not in B (the set difference).\n\n  Optionally, specify the desired number of indices as Order(N),\n  which adds a check and can be a bit more efficient.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We can also filter the results to only specify functions from certain modules, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> filter(x -> startswith(x, \"ITensors\"), finddocs(\"indices\", \"set difference\"))\n2-element Array{SubString{String},1}:\n \"ITensors.noncommoninds\"\n \"ITensors.uniqueinds\"\n\njulia> filter(x -> !startswith(x, \"ITensors\"), finddocs(\"indices\", \"set difference\"))\n1-element Array{SubString{String},1}:\n \"Base.setdiff\"","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Ideally we could have apropos do a \"smart\" Google-like search of the appropriate docstrings, but this is a pretty good start.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Additionally, the names function can be useful, which prints the names of all functions and types that are exported by a module. For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> names(ITensors)\n264-element Array{Symbol,1}:\n Symbol(\"@OpName_str\")\n Symbol(\"@SiteType_str\")\n Symbol(\"@StateName_str\")\n Symbol(\"@TagType_str\")\n Symbol(\"@disable_warn_order\")\n Symbol(\"@reset_warn_order\")\n Symbol(\"@set_warn_order\")\n Symbol(\"@ts_str\")\n :AbstractObserver\n :AutoMPO\n :DMRGObserver\n :ITensor\n :ITensors\n :Index\n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Of course this is a very long list (and the methods are returned as Symbols, which are like strings but not as easy to work with). However, we can convert the list to strings and filter the strings to find functions we are interested in, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> filter(x -> contains(x, \"common\") && contains(x, \"ind\"), String.(names(ITensors)))\n8-element Array{String,1}:\n \"common_siteind\"\n \"common_siteinds\"\n \"commonind\"\n \"commonindex\"\n \"commoninds\"\n \"hascommoninds\"\n \"noncommonind\"\n \"noncommoninds\"","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Julia types do not have member functions, so people coming from object oriented programming languages may find that at first it is more difficult to find methods that are applicable to a certain type. However, Julia has many fantastic tools for introspection that we can use to make this task easier.","category":"page"},{"location":"AdvancedUsageGuide.html#Make-a-small-project-based-on-ITensors.jl-1","page":"Advanced usage guide","title":"Make a small project based on ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Once you start to have longer code, you will want to put your code into one or more files. For example, you may have a short script with one or more functions based on ITensors.jl:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# my_itensor_script.jl\nusing ITensors\n\nfunction norm2(A::ITensor)\n  return (A*dag(A))[]\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, in the same directory as your script my_itensor_script.jl, just type:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> include(\"my_itensor_script.jl\");\n\njulia> i = Index(2; tags=\"i\");\n\njulia> A = randomITensor(i', i);\n\njulia> norm2(A)\n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"As your code gets longer, you can split it into multiple files and include this files into one main project file, for example if you have two files with functions in them:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# file1.jl\n\nfunction norm2(A::ITensor)\n  return (A*dag(A))[]\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"and","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# file2.jl\n\nfunction square(A::ITensor)\n  return A .^ 2\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# my_itensor_project.jl\n\nusing ITensors\n\ninclude(\"file1.jl\")\n\ninclude(\"file2.jl\")","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, as before, you can use your functions at the Julia REPL by just including the file my_itensor_project.jl:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> include(\"my_itensor_project.jl\");\n\njulia> i = Index(2; tags=\"i\");\n\njulia> A = randomITensor(i', i);\n\njulia> norm2(A)\n[...]\n\njulia> square(A)\n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"As your code gets more complicated and has more files, it is helpful to organize it into a package. That will be covered in the next section.","category":"page"},{"location":"AdvancedUsageGuide.html#Make-a-Julia-package-based-on-ITensors.jl-1","page":"Advanced usage guide","title":"Make a Julia package based on ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In this section, we will describe how to make a Julia package based on ITensors.jl. This is useful to do when your project gets longer, since it helps with:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Code organization.\nAdding dependencies that will get automatically installed through Julia's package system.\nVersioning.\nAutomated testing.\nCode sharing and easier package installation.\nOfficially registering your package with Julia.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"and many more features that we will mention later.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Start up Julia and install PkgTemplates","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia\n\njulia> ]\n\npkg> add PkgTemplates","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"then press backspace and type:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using PkgTemplates\n\njulia> t = Template(; user=\"your_github_username\", plugins=[Git(; ssh=true),])\n\njulia> t(\"MyITensorsPkg\")","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You should put your Github account name instead of \"your_github_username\", if you want to use Github to host your package.  The option plugins=[Git(; ssh=true),] sets the Github authentication to use ssh, which is generally more convenient. You can switch to https (where you have to type your username and password to push changes) by setting ssh=false or leaving off plugins=[...]. By default, the package will be located in the directory ~/.julia/dev, you can change this with the keyword argument dir=[...]. However, ~/.julia/dev is recommended since that is the directory Julia's package manager (and other packages like Revise) will look for development packages. Please see the PkgTemplate documentation for more customization options.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, we want to tell Julia about our new package. We do this as follows:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> dev ~/.julia/dev/MyITensorsPkg","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"then you can do:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using MyITensorsPkg","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"from any directory to use your new package. However, it doesn't  have any functions available yet. Additionally, there should be an empty test file already set up here:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"~/.julia/dev/MyITensorsPkg/test/runtests.jl","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"which you can run from any directory like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> test MyITensorsPkg","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"It should show something like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"[...]\nTest Summary:    |\nMyITensorsPkg.jl | No tests\n    Testing MyITensorsPkg tests passed ","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"since there are no tests yet.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"First we want to add ITensors as a dependency of our package. We do this by \"activating\" our package environment and then adding ITensors:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> activate MyITensorsPkg\n\n(MyITensorsPkg) pkg> add ITensors","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This will edit the file ~/.julia/dev/MyITensorsPkg/Project.toml and add the line","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"[deps]\nITensors = \"9136182c-28ba-11e9-034c-db9fb085ebd5\"","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Because your package is under development, back in the main Pkg environment you should type resolve:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"(MyITensorsPkg) pkg> activate\n\npkg> resolve","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now, if you or someone else uses the package, it will automatically install ITensors.jl for you.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now your package is set up to develop! Try editing the file ~/.julia/dev/MyITensorsPkg/src/MyITensorsPkg.jl and add the  norm2 function, which calculates the squared norm of an ITensor:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"module MyITensorsPkg\n\nusing ITensors\n\nexport norm2\n\nnorm2(A::ITensor) = (A*dag(A))[]\n\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The export command makes norm2 available in the namespace without needing to type MyITensorsPkg.norm2 when you do  using MyITensorsPkg. Now in a new Julia session you can do:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors\n\njulia> i = Index(2)\n(dim=2|id=263)\n\njulia> A = randomITensor(i)\nITensor ord=1 (dim=2|id=263)\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> norm(A)^2\n6.884457016011188\n\njulia> norm2(A)\nERROR: UndefVarError: norm2 not defined\n[...]\n\njulia> using MyITensorsPkg\n\njulia> norm2(A)\n6.884457016011188","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Unfortunately, if you continue to edit the file MyITensorsPkg.jl, even if you type using MyITensorsPkg again, if you are in the same Julia session the changes will not be reflected, and you will have to restart your Julia session. The  Revise package will allow you to edit your package files and have the changes reflected in real time in your current Julia session, so you don't have to restart the session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now, we can add some tests for our new functionality. Edit the file ~/.julia/dev/MyITensorsPkg/test/runtests.jl to look like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"using MyITensorsPkg\nusing ITensors\nusing Test\n\n@testset \"MyITensorsPkg.jl\" begin\n  i = Index(2)\n  A = randomITensor(i)\n  @test isapprox(norm2(A), norm(A)^2)\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now when you test your package you should see:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"pkg> test MyITensorsPkg\n[...]\nTest Summary:    | Pass  Total\nMyITensorsPkg.jl |    1      1\n    Testing MyITensorsPkg tests passed ","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Your package should already be set up as a git repository by  the PkgTemplates commands we started with. We recommend using Github or similar versions control systems for your packages, especially if you plan to make them public and officially register them as Julia packages.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You can set up your local package as a Github repository by following the steps here. Many of the steps may be unnecessary since they were already set up by PkgTemplates. You should be able to go to the website here, create a new Github repository with the name MyITensorsPkg.jl, and then following the instructions under \"push an existing repository from the command line\".","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You may also want to switch between HTTPS and SSH authentication as described here, if you didn't choose your preferred authentication protocol with PkgTemplates.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"There are many more features you can add to your package through  various Julia packages and Github, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Control of precompilation with tools like SnoopCompile.\nAutomatic testing of your package at every pull request/commit with Github Actions, Travis, or similar services.\nAutomated benchmarking of your package at every pull request with BenchmarkTools, PkgBenchmark and BenchmarkCI.\nAutomated building of your documentation with Documenter.\nCompiling your package with PackageCompiler.\nAutomatically check what parts of your code your tests check with code coverage.\nOfficially register your Julia package so that others can easily install it and follow along with updated versions using the Registrator.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You can take a look at the ITensors  Github page for inspiration on setting up some of these services and ideas for organizing your package.","category":"page"},{"location":"AdvancedUsageGuide.html#Developing-ITensors.jl-1","page":"Advanced usage guide","title":"Developing ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To make your own changes to ITensors.jl, type dev ITensors in Pkg mode (by typing ] at the Julia prompt). This  will create a local clone of the Github repository in the directory  ~/.julia/dev/ITensors. Changes to that directory will be reflected  when you do using ITensors in a new session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We highly recommend using the Revise package when you are developing  packages, which automatically detects changes you are making in a  package so you can edit code and not have to restart your Julia  session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"info: Coming soon\nA more extended guide for contributing to ITensors.jl, including  contributing to the related NDTensors.jl as well as a style  guide, is coming soon.","category":"page"},{"location":"AdvancedUsageGuide.html#Compiling-ITensors.jl-1","page":"Advanced usage guide","title":"Compiling ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You might notice that the time to load ITensors.jl (with using  ITensors) and the time to run your first few ITensor commands is  slow. This is due to Julia's just-in-time (JIT) compilation. Julia is compiling special versions of each function that is being called based on the inputs that it gets at runtime. This allows it to have fast code, often nearly as fast as fully compiled languages like C++, while still being a dynamic language.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"However, the long startup time can still be annoying. In this section, we will discuss some strategies that can be used to minimize this annoyance, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Precompilation.\nStaying in the same Julia session with Revise.\nUsing PackageCompiler to compile ITensors.jl ahead of time.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Precompilation is performed automatically when you first install ITensors.jl or update a version and run the command using ITensors for the first time. For example, when you first use ITensors after installation or updating, you will see:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors\n[ Info: Precompiling ITensors [9136182c-28ba-11e9-034c-db9fb085ebd5]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The process is done automatically, and puts some compiled binaries in your ~/.julia directory. The goal is to decrease the time it takes when you first type using ITensors in your next Julia session, and also the time it takes for you to first run ITensor functions in a new Julia session. This helps the startup time, but currently doesn't help enough. This is something both ITensors.jl and the Julia language will try to improve over time.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To avoid this time, it is recommended that you work as much as you can in a single Julia session. You should not need to restart your Julia session very often. For example, if you are writing code in a script, just include the file again which will pull in the new changes to the script (the exception is if you change the definition of a type you made, which would requiring restarting the REPL).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"If you are working on a project, we highly recommend using the Revise package which automatically detects changes you are making in your packages and reflects them real-time in your current REPL session. Using these strategies should minimize the number of times you need to restart your REPL session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"If you plan to use ITensors.jl directly from the command line (i.e. not from the REPL), and the startup time is an issue, you can try compiling ITensors.jl using PackageCompiler.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Before using PackageCompiler to compile ITensors, when we first start using ITensors.jl we might see:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> @time using ITensors\n  3.845253 seconds (10.96 M allocations: 618.071 MiB, 3.95% gc time)\n\njulia> @time i = Index(2);\n  0.000684 seconds (23 allocations: 20.328 KiB)\n\njulia> @time A = randomITensor(i', i);\n  0.071022 seconds (183.24 k allocations: 9.715 MiB)\n\njulia> @time svd(A, i');\n  5.802053 seconds (24.56 M allocations: 1.200 GiB, 7.83% gc time)\n\njulia> @time svd(A, i');\n  0.000177 seconds (450 allocations: 36.609 KiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"ITensors provides the command ITensors.compile() to create what is called a \"custom system image\", a custom version of Julia that includes a compiled version of ITensors (see the PackageCompiler documentation for more details). Just run the command:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ITensors.compile()\n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"By default, this will create the file sys_itensors.so in the directory ~/.julia/sysimages. Then if we start julia with:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia --sysimage ~/.julia/sysimages/sys_itensors.so","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"then you should see something like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> @time using ITensors\n  0.330587 seconds (977.61 k allocations: 45.807 MiB, 1.89% gc time)\n\njulia> @time i = Index(2);\n  0.000656 seconds (23 allocations: 20.328 KiB)\n\njulia> @time A = randomITensor(i', i);\n  0.000007 seconds (7 allocations: 576 bytes)\n\njulia> @time svd(A, i');\n  0.263526 seconds (290.02 k allocations: 14.220 MiB)\n\njulia> @time svd(A, i');\n  0.000135 seconds (350 allocations: 29.984 KiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"which is much better. ","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Note that you will have to recompile ITensors with the command  ITensors.compile() any time that you update the version of ITensors in order to keep the system image updated. We hope to make this process more automated in the future.","category":"page"},{"location":"AdvancedUsageGuide.html#Multithreading-Support-1","page":"Advanced usage guide","title":"Multithreading Support","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"There are two possible sources of parallelization available in  ITensors.jl, both external to the package right now. These are:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"BLAS/LAPACK multithreading (through whatever flavor you are using, i.e. OpenBLAS or MKL).\nThe Strided.jl package, which implements a multithreaded array permutation.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The BLAS/LAPACK multithreading can be controlled in the usual way with  environment variables, or within Julia. So for example, to control  from Julia, you would do:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using LinearAlgebra\n\njulia> BLAS.vendor()  # Check which BLAS you are using\n:mkl\n\njulia> BLAS.set_num_threads(4)\n\njulia> ccall((:MKL_GET_MAX_THREADS, Base.libblas_name), Cint, ())\n4\n\njulia> BLAS.set_num_threads(2)\n\njulia> ccall((:MKL_GET_MAX_THREADS, Base.libblas_name), Cint, ())\n2","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"if you are using OpenBLAS, the command would be something like  ccall((:openblas_get_num_threads, Base.libblas_name), Cint, ()).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Alternatively, you can use environment variables, so at your command  line prompt you would use:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ export MKL_NUM_THREADS=4","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"if you are using MKL or","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ export OPENBLAS_NUM_THREADS=4","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"if you are using OpenBLAS. We would highly recommend using MKL (see the installation instructions for how to do that), especially if you  are using an Intel chip. In general, we have not found MKL/OpenBLAS  multithreading to help much in the context of common ITensor applications (like DMRG), but your mileage may vary and it would depend highly on the  problem you are studying.  How well BLAS multithreading will work would depend on how much your  calculations are dominated by matrix multiplications (which is not  always the case, especially if you are using QN conservation).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, a separate level of mutlithreading could be turned on, which is  native Julia multithreading. Right now in ITensors.jl, this would  only control array permutation functions we use from  Strided.jl. You would set it  with the environment variable JULIA_NUM_THREADS, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> Threads.nthreads() # By default it is probably off\n1","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then if you set export JULIA_NUM_THREADS=4 at your command line,  you would see the next time you start up Julia:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> Threads.nthreads()\n4","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"As of this writing, we have not found that using that kind of  multithreading has helped much in the context of DMRG calculation,  but your mileage may vary. Also note that the two kinds of multithreading (BLAS vs. native Julia) may compete with each other for resources, so it is recommended you turn one or the other off.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We plan to incorporate our own multithreading with Julia's native  multithreading capabilities, for example to parallelize over block  sparse contractions. Stay tuned for that!","category":"page"},{"location":"AdvancedUsageGuide.html#Benchmarking-and-profiling-1","page":"Advanced usage guide","title":"Benchmarking and profiling","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Julia has great built-in tools for benchmarking and profiling. For benchmarking fast code at the command line, you can use BenchmarkTools:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors;\n\njulia> using BenchmarkTools;\n\njulia> i = Index(100, \"i\");\n\njulia> A = randomITensor(i, i');\n\njulia> @btime 2*$A;\n  4.279 μs (8 allocations: 78.73 KiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We recommend packages like ProfileView  to get detailed profiles of your code, in order to pinpoint functions  or lines of code that are slower than they should be.","category":"page"},{"location":"AdvancedUsageGuide.html#ITensor-type-design-and-writing-performant-code-1","page":"Advanced usage guide","title":"ITensor type design and writing performant code","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Advanced users might notice something strange about the definition of the ITensor type, that it is often not \"type stable\". Some of  this is by design. The definition for ITensor is:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"mutable struct ITensor{N}\n  inds::IndexSet{N}\n  store::TensorStorage\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"These are both abstract types, which is something that is generally  discouraged for peformance.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This has a few disadvantages. Some code that you might expect to be  type stable, like getindex, is not, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> i = Index(2, \"i\");\n\njulia> A = randomITensor(i, i');\n\njulia> @code_warntype A[i=>1, i'=>2]\nVariables\n  #self#::Core.Compiler.Const(getindex, false)\n  T::ITensor{1}\n  ivs::Tuple{Pair{Index{Int64},Int64}}\n  p::Tuple{Union{Nothing, Int64}}\n  vals::Tuple{Any}\n\nBody::Number\n1 ─ %1  = NDTensors.getperm::Core.Compiler.Const(NDTensors.getperm, false)\n│   %2  = ITensors.inds(T)::IndexSet{1,IndexT,DataT} where DataT<:Tuple where IndexT<:Index\n│   %3  = Base.broadcasted(ITensors.ind, ivs)::Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple},Nothing,typeof(ind),Tuple{Tuple{Pair{Index{Int64},Int64}}}}\n│   %4  = Base.materialize(%3)::Tuple{Index{Int64}}\n│         (p = (%1)(%2, %4))\n│   %6  = NDTensors.permute::Core.Compiler.Const(NDTensors.permute, false)\n│   %7  = Base.broadcasted(ITensors.val, ivs)::Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple},Nothing,typeof(val),Tuple{Tuple{Pair{Index{Int64},Int64}}}}\n│   %8  = Base.materialize(%7)::Tuple{Int64}\n│         (vals = (%6)(%8, p))\n│   %10 = Core.tuple(T)::Tuple{ITensor{1}}\n│   %11 = Core._apply_iterate(Base.iterate, Base.getindex, %10, vals)::Number\n│   %12 = Core.typeassert(%11, ITensors.Number)::Number\n└──       return %12\n\njulia> typeof(A[i=>1, i'=>2])\nFloat64","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Uh oh, that doesn't look good! Julia can't know ahead of time, based on  the inputs, what the type of the output is, besides that it will be a Number (though at runtime, the output has a concrete type, Float64).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"So why is it designed this way? The main reason is to allow more  generic and dynamic code than traditional, statically-typed Arrays. This allows us to have code like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> i = Index(2, \"i\")\n(dim=2|id=811|\"i\")\n\njulia> A = emptyITensor(i', i);\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=811|\"i\")'\nDim 2: (dim=2|id=811|\"i\")\nNDTensors.Empty{Float64,NDTensors.Dense{Float64,Array{Float64,1}}}\n 2×2\n\n\n\njulia> A[i' => 1, i => 2] = 1.2;\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=811|\"i\")'\nDim 2: (dim=2|id=811|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.0  1.2\n 0.0  0.0","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Here, the type of the storage of A is changed in-place. It starts as an Empty storage, a special trivial storage. When we set an element, we then allocate the appropriate storage. Allocations are performed only when needed, so if another element is set then no allocation is performed. More generally, this allows ITensors to have more generic in-place  functionality, so you can write code where you don't know what the storage is until runtime.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This can lead to certain types of code having perfomance problems,  for example looping through ITensors with many elements can be slow:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> function myscale!(A::ITensor, x::Number)\n         for n in 1:dim(A)\n           A[n] = x * A[n]\n         end\n       end;\n\njulia> d = 10_000;\n\njulia> i = Index(d);\n\njulia> @btime myscale!(A, 2) setup = (A = randomITensor(i));\n  2.169 ms (117958 allocations: 3.48 MiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"However, this is fast:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> function myscale!(A::Array, x::Number)\n         for n in 1:length(A)\n           A[n] = x * A[n]\n         end\n       end;\n\njulia> @btime myscale!(A, 2) setup = (A = randn(d));\n  3.451 μs (0 allocations: 0 bytes)\n\njulia> myscale2!(A::ITensor, x::Number) = myscale!(array(A), x)\nmyscale2! (generic function with 1 method)\n\njulia> @btime myscale2!(A, 2) setup = (A = randomITensor(i));\n  3.571 μs (2 allocations: 112 bytes)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"How does this work? It relies on a \"function barrier\" technique.  Julia compiles functions \"just-in-time\", so that calls to an inner  function written in terms of a type-stable type are still fast. That inner function is compiled to very fast code. The main overhead is that Julia has to determine which function  to call at runtime.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Therefore, users should keep this in mind when they are writing  ITensors.jl code, and we warn that explicitly looping over large  ITensors by individual elements should be done with caution in  performance critical sections of your code.  However, be sure to benchmark and profile your code before  prematurely optimizing, since you may be surprised about  what are the fast and slow parts of your code.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Some strategies for avoiding ITensor loops are:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Use broadcasting and other built-in ITensor functionality that makes use of function barriers.\nConvert ITensors to type-stable collections like the Tensor type of NDTensors.jl and write functions in terms of the Tensor type (i.e. the function barrier techique that is used throughout ITensors.jl).\nWhen initializing very large ITensors elementwise, use built-in ITensor constructors, or first construct an equivalent tensor as an Array or Tensor and then convert it to an ITensor.","category":"page"},{"location":"AdvancedUsageGuide.html#ITensor-in-place-operations-1","page":"Advanced usage guide","title":"ITensor in-place operations","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In-place operations can help with optimizing code, when the memory of the output tensor of an operation is preallocated.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The main way to access this in ITensor is through broadcasting. For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"A = randomITensor(i, i')\nB = randomITensor(i', i)\nA .+= 2 .* B","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Internally, this is rewritten by Julia as a call to broadcast!. ITensors.jl overloads this call (or more specifically, a lower level function copyto! written in terms of a special lazy type that saves all of the objects and operations). Then, this call is  rewritten as","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"map!((x,y) -> x+2*y, A, A, B)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This is mostly an optimization to use when you can preallocate storage that can be used multiple times.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Additionally, ITensors makes the unique choice that:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"C .= A .* B","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"is interpreted as an in-place tensor contraction. What this means is that this calls a function:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"mul!(C, A, B)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"(likely to be given an alternative name contract!) which contracts A and B into the pre-allocated memory C.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Because of the design of the ITensor type (see the section above), there is some flexibility we take in allocating memory for users. For example, if the storage type is more narrow than the result, for convenience we might expand it in-place. If you are worried about memory allocations, we recommend using benchmarking and profiling to pinpoint slow parts of your code (often times, you may be surprised by what is actually slow).","category":"page"},{"location":"AdvancedUsageGuide.html#NDTensors-and-ITensors-1","page":"Advanced usage guide","title":"NDTensors and ITensors","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"ITensors.jl is built on top of another, more traditional tensor  library called NDTensors. NDTensors implements AbstractArrays with  a variety of sparse storage types, with more to come in the future.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"NDTensors implements functionality like permutation of dimensions,  fast get and set index, broadcasting, and tensor contraction (where  labels of the dimensions must be specified).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"using ITensors\nusing NDTensors\n\nT = Tensor(2,2,2)\nT[1,2,1] = 1.3  # Conventional element setting\n\ni = Index(2)\nT = Tensor((i,i',i'))  # The identifiers are ignored, just interpreted as above\nT[1,2,1] = 1.3","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To make performant ITensor code (refer to the the previous section  on type stability and function barriers), ITensor storage data and  indices are passed by reference into Tensors, where the performance  critical operations are performed.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"An example of a function barrier using NDTensors is the following:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using NDTensors\n\njulia> d = 10_000;\n\njulia> i = Index(d);\n\njulia> function myscale!(A::Tensor, x::Number)\n         for n in 1:dim(A)\n           A[n] = x * A[n]\n         end\n       end;\n\njulia> @btime myscale!(A, 2) setup = (A = Tensor(d));\n  3.530 μs (0 allocations: 0 bytes)\n\njulia> myscale2!(A::ITensor, x::Number) = myscale!(tensor(A), x)\nmyscale2! (generic function with 1 method)\n\njulia> @btime myscale2!(A, 2) setup = (A = randomITensor(i));\n  3.549 μs (2 allocations: 112 bytes)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"A very efficient function is written for the Tensor type. Then, the ITensor version just wraps the Tensor function by calling it after converting the ITensor to a Tensor (without any copying) with the tensor function. This is the basis for the design of all performance critical ITensors.jl functions.","category":"page"},{"location":"IndexType.html#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"IndexType.html#Description-1","page":"Index","title":"Description","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"Index\nITensors.QNIndex","category":"page"},{"location":"IndexType.html#ITensors.Index","page":"Index","title":"ITensors.Index","text":"An Index represents a single tensor index with fixed dimension dim. Copies of an Index compare equal unless their  tags are different.\n\nAn Index carries a TagSet, a set of tags which are small strings that specify properties of the Index to help  distinguish it from other Indices. There is a special tag which is referred to as the integer tag or prime  level which can be incremented or decremented with special priming functions.\n\nInternally, an Index has a fixed id number, which is how the ITensor library knows two indices are copies of a  single original Index. Index objects must have the same id, as well as the tags to compare equal.\n\n\n\n\n\n","category":"type"},{"location":"IndexType.html#ITensors.QNIndex","page":"Index","title":"ITensors.QNIndex","text":"A QN Index is an Index with QN block storage instead of just an integer dimension. The QN block storage is a  vector of pairs of QNs and block dimensions. The total dimension of a QN Index is the sum of the dimensions of the blocks of the Index.\n\n\n\n\n\n","category":"type"},{"location":"IndexType.html#Constructors-1","page":"Index","title":"Constructors","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"Index(::Int)\nIndex(::Int, ::Union{AbstractString, TagSet})\nIndex(::Pair{QN, Int}...)\nIndex(::Vector{Pair{QN, Int}})\nIndex(::Vector{Pair{QN, Int}}, ::Union{AbstractString, TagSet})","category":"page"},{"location":"IndexType.html#ITensors.Index-Tuple{Int64}","page":"Index","title":"ITensors.Index","text":"Index(dim::Int; tags::Union{AbstractString, TagSet} = \"\",\n                plev::Int = 0)\n\nCreate an Index with a unique id, a TagSet given by tags, and a prime level plev.\n\nExamples\n\njulia> i = Index(2; tags = \"l\", plev = 1)\n(dim=2|id=818|\"l\")'\n\njulia> dim(i)\n2\n\njulia> plev(i)\n1\n\njulia> tags(i)\n\"l\"\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Int64,Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.Index","text":"Index(dim::Integer, tags::Union{AbstractString, TagSet}; plev::Int = 0)\n\nCreate an Index with a unique id and a tagset given by tags.\n\nExamples\n\njulia> i = Index(2, \"l,tag\")\n(dim=2|id=58|\"l,tag\")\n\njulia> dim(i)\n2\n\njulia> plev(i)\n0\n\njulia> tags(i)\n\"l,tag\"\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Vararg{Pair{QN,Int64},N} where N}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Pair{QN, Int64}...; dir::Arrow = Out,\n                                    tags = \"\",\n                                    plev::Integer = 0)\n\nConstruct a QN Index from a list of pairs of QN and block  dimensions.\n\nExample\n\nIndex(QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1; tags = \"i\")\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Array{Pair{QN,Int64},1}}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Vector{Pair{QN, Int64}}; dir::Arrow = Out,\n                                         tags = \"\",\n                                         plev::Integer = 0)\n\nConstruct a QN Index from a Vector of pairs of QN and block  dimensions.\n\nNote: in the future, this may enforce that all blocks have the same QNs (which would allow for some optimizations, for example when constructing random QN ITensors).\n\nExample\n\nIndex([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1]; tags = \"i\")\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Array{Pair{QN,Int64},1},Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Vector{Pair{QN, Int64}}, tags; dir::Arrow = Out,\n                                               plev::Integer = 0)\n\nConstruct a QN Index from a Vector of pairs of QN and block  dimensions.\n\nExample\n\nIndex([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1], \"i\"; dir = In)\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Properties-1","page":"Index","title":"Properties","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"id(::Index)\nhasid(::Index, ::ITensors.IDType)\ntags(::Index)\nhastags(::Index, ::Union{AbstractString,TagSet})\nplev(::Index)\nhasplev(::Index, ::Int)\ndim(::Index)\n==(::Index, ::Index)\ndir(::Index)\nhasqns(::Index)","category":"page"},{"location":"IndexType.html#ITensors.id-Tuple{Index}","page":"Index","title":"ITensors.id","text":"id(i::Index)\n\nObtain the id of an Index, which is a unique 64 digit integer.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasid-Tuple{Index,UInt64}","page":"Index","title":"ITensors.hasid","text":"hasid(i::Index, id::ITensors.IDType)\n\nCheck if an Index i has the provided id.\n\nExamples\n\njulia> i = Index(2)\n(dim=2|id=321)\n\njulia> hasid(i, id(i))\ntrue\n\njulia> j = Index(2)\n(dim=2|id=17)\n\njulia> hasid(i, id(j))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.tags-Tuple{Index}","page":"Index","title":"ITensors.tags","text":"tags(i::Index)\n\nObtain the TagSet of an Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hastags-Tuple{Index,Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.hastags","text":"hastags(i::Index, ts::Union{AbstractString,TagSet})\n\nCheck if an Index i has the provided tags, which can be a string of comma-separated tags or  a TagSet object.\n\nExamples\n\njulia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=861|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"SpinHalf,Site\")\ntrue\n\njulia> hastags(i, \"Link\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.plev-Tuple{Index}","page":"Index","title":"ITensors.plev","text":"plev(i::Index)\n\nObtain the prime level of an Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasplev-Tuple{Index,Int64}","page":"Index","title":"ITensors.hasplev","text":"hasplev(i::Index, plev::Int)\n\nCheck if an Index i has the provided prime level.\n\nExamples\n\njulia> i = Index(2; plev=2)\n(dim=2|id=543)''\n\njulia> hasplev(i, 2)\ntrue\n\njulia> hasplev(i, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#NDTensors.dim-Tuple{Index}","page":"Index","title":"NDTensors.dim","text":"dim(i::Index)\n\nObtain the dimension of an Index.\n\nFor a QN Index, this is the sum of the block dimensions.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.:==-Tuple{Index,Index}","page":"Index","title":"Base.:==","text":"==(i1::Index, i1::Index)\n\nCompare indices for equality. First the id's are compared, then the prime levels are compared, and finally the tags are compared.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.dir-Tuple{Index}","page":"Index","title":"ITensors.dir","text":"dir(i::Index)\n\nObtain the direction of an Index (In, Out, or Neither).\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasqns-Tuple{Index}","page":"Index","title":"ITensors.hasqns","text":"hasqns(::Index)\n\nChecks of the Index has QNs or not.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Priming-and-tagging-methods-1","page":"Index","title":"Priming and tagging methods","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"prime(::Index, ::Int)\nadjoint(::Index)\n^(::Index, ::Int)\nsetprime(::Index, ::Int)\nnoprime(::Index)\nsettags(::Index, ::Any)\naddtags(::Index, ::Any)\nremovetags(::Index, ::Any)\nreplacetags(::Index, ::Any, ::Any)","category":"page"},{"location":"IndexType.html#ITensors.prime-Tuple{Index,Int64}","page":"Index","title":"ITensors.prime","text":"prime(i::Index, plinc::Int = 1)\n\nReturn a copy of Index i with its prime level incremented by the amount plinc\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.adjoint-Tuple{Index}","page":"Index","title":"Base.adjoint","text":"adjoint(i::Index)\n\nPrime an Index using the notation i'.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.:^-Tuple{Index,Int64}","page":"Index","title":"Base.:^","text":"^(i::Index, pl::Int)\n\nPrime an Index using the notation i^3.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.setprime-Tuple{Index,Int64}","page":"Index","title":"ITensors.setprime","text":"setprime(i::Index, plev::Int)\n\nReturn a copy of Index i with its prime level set to plev\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.noprime-Tuple{Index}","page":"Index","title":"ITensors.noprime","text":"noprime(i::Index)\n\nReturn a copy of Index i with its prime level set to zero.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.settags-Tuple{Index,Any}","page":"Index","title":"ITensors.settags","text":"settags(i::Index, ts)\n\nReturn a copy of Index i with tags replaced by the ones given The ts argument can be a comma-separated  string of tags or a TagSet.\n\nExamples\n\njulia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=543|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"Link\")\nfalse\n\njulia> j = settags(i,\"Link,n=4\")\n(dim=2|id=543|\"Link,n=4\")\n\njulia> hastags(j, \"Link\")\ntrue\n\njulia> hastags(j, \"n=4,Link\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.addtags-Tuple{Index,Any}","page":"Index","title":"ITensors.addtags","text":"addtags(i::Index,ts)\n\nReturn a copy of Index i with the specified tags added to the existing ones. The ts argument can be a comma-separated  string of tags or a TagSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.removetags-Tuple{Index,Any}","page":"Index","title":"ITensors.removetags","text":"removetags(i::Index, ts)\n\nReturn a copy of Index i with the specified tags removed. The ts argument can be a comma-separated string of tags or a TagSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.replacetags-Tuple{Index,Any,Any}","page":"Index","title":"ITensors.replacetags","text":"replacetags(i::Index, tsold, tsnew)\n\nreplacetags(i::Index, tsold => tsnew)\n\nIf the tag set of i contains the tags specified by tsold, replaces these with the tags specified by tsnew, preserving any other tags. The arguments tsold and tsnew can be comma-separated strings of tags, or TagSet objects.\n\nExamples\n\njulia> i = Index(2; tags = \"l,x\", plev = 1)\n(dim=2|id=83|\"l,x\")'\n\njulia> replacetags(i, \"l\", \"m\")\n(dim=2|id=83|\"m,x\")'\n\njulia> replacetags(i, \"l\" => \"m\")\n(dim=2|id=83|\"m,x\")'\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Methods-1","page":"Index","title":"Methods","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"sim(::Index)\ndag(::Index)\nremoveqns(::Index)","category":"page"},{"location":"IndexType.html#NDTensors.sim-Tuple{Index}","page":"Index","title":"NDTensors.sim","text":"sim(i::Index; tags = tags(i), plev = plev(i), dir = dir(i))\n\nProduces an Index with the same properties (dimension or QN structure) but with a new id.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.dag-Tuple{Index}","page":"Index","title":"ITensors.dag","text":"dag(i::Index)\n\nCopy an index i and reverse its direction.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.removeqns-Tuple{Index}","page":"Index","title":"ITensors.removeqns","text":"removeqns(::Index)\n\nRemoves the QNs from the Index, if it has any.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Iterating-1","page":"Index","title":"Iterating","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"iterate(::Index)","category":"page"},{"location":"IndexType.html#Base.iterate-Tuple{Index}","page":"Index","title":"Base.iterate","text":"Iterating over Index I gives the IndexVals I(1) through I(dim(I)).\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPS-and-MPO-1","page":"MPS and MPO","title":"MPS and MPO","text":"","category":"section"},{"location":"MPSandMPO.html#Types-1","page":"MPS and MPO","title":"Types","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPS\nMPO","category":"page"},{"location":"MPSandMPO.html#ITensors.MPS","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS\n\nA finite size matrix product state type. Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#ITensors.MPO","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO\n\nA finite size matrix product operator type.  Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#MPS-Constructors-1","page":"MPS and MPO","title":"MPS Constructors","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPS(::Int)\nMPS(::Type{<:Number}, ::Vector{<:Index})\nrandomMPS(sites::Vector{<:Index}; linkdim=1)\nrandomMPS(::Type{<:Number}, sites::Vector{<:Index}; linkdim=1)\nrandomMPS(sites::Vector{<:Index}, state; linkdim=1)\nproductMPS(::Vector{<:Index},states)\nproductMPS(::Type{<:Number},::Vector{<:Index},states)\nproductMPS(::Vector{<:IndexVal})\nproductMPS(::Type{<:Number}, ::Vector{<:IndexVal})","category":"page"},{"location":"MPSandMPO.html#ITensors.MPS-Tuple{Int64}","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS(N::Int)\n\nConstruct an MPS with N sites with default constructed ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPS-Tuple{Type{#s76} where #s76<:Number,Array{#s75,1} where #s75<:Index}","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS([::Type{ElT} = Float64, ]sites)\n\nConstruct an MPS filled with Empty ITensors of type ElT from a collection of indices.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Array{#s76,1} where #s76<:Index}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(sites::Vector{<:Index}; linkdim=1)\n\nConstruct a random MPS with link dimension linkdim of  type Float64.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Type{#s76} where #s76<:Number,Array{#s75,1} where #s75<:Index}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(::Type{ElT<:Number}, sites::Vector{<:Index}; linkdim=1)\n\nConstruct a random MPS with link dimension linkdim of  type ElT.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Array{#s76,1} where #s76<:Index,Any}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(sites::Vector{<:Index}, state; linkdim=1)\n\nConstruct a real, random MPS with link dimension linkdim, made by randomizing an initial product state specified by state. This version of randomMPS is necessary when creating QN-conserving random MPS (consisting of QNITensors). The initial state array provided determines the total QN of the resulting random MPS.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Array{#s76,1} where #s76<:Index,Any}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(sites::Vector{<:Index},states)\n\nConstruct a product state MPS having site indices sites, and which corresponds to the initial state given by the array states. The states array may consist of either an array of integers or strings, as  recognized by the state function defined for the relevant Index tag type.\n\nExamples\n\nN = 10\nsites = siteinds(\"S=1/2\",N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi = productMPS(sites,states)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Type{#s76} where #s76<:Number,Array{#s75,1} where #s75<:Index,Any}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(::Type{T},\n           sites::Vector{<:Index},\n           states::Union{Vector{String},\n                         Vector{Int},\n                         String,\n                         Int})\n\nConstruct a product state MPS of element type T, having site indices sites, and which corresponds to the initial state given by the array states. The input states may be an array of strings or an array of ints recognized by the  state function defined for the relevant Index tag type. In addition, a single string or int can be input to create a uniform state.\n\nExamples\n\nN = 10\nsites = siteinds(\"S=1/2\", N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi = productMPS(ComplexF64, sites, states)\nphi = productMPS(sites, \"Up\")\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Array{#s76,1} where #s76<:IndexVal}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(ivals::Vector{<:IndexVal})\n\nConstruct a product state MPS with element type Float64 and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Type{#s76} where #s76<:Number,Array{#s75,1} where #s75<:IndexVal}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(::Type{T<:Number}, ivals::Vector{<:IndexVal})\n\nConstruct a product state MPS with element type T and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPO-Constructors-1","page":"MPS and MPO","title":"MPO Constructors","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPO(::Int)\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::Vector{String})\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::String)\nMPO(::MPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Int64}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO(N::Int)\n\nMake an MPO of length N filled with default ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Type{#s76} where #s76<:Number,Array{#s75,1} where #s75<:Index,Array{String,1}}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO([::Type{ElT} = Float64}, ]sites, ops::Vector{String})\n\nMake an MPO with pairs of sites s[i] and s[i]' and operators ops on each site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Type{#s76} where #s76<:Number,Array{#s75,1} where #s75<:Index,String}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO([::Type{ElT} = Float64, ]sites, op::String)\n\nMake an MPO with pairs of sites s[i] and s[i]' and operator op on every site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO(A::MPS; kwargs...)\n\nFor an MPS |A>, make the MPO |A><A|. Keyword arguments like cutoff can be used to truncate the resulting MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Properties-1","page":"MPS and MPO","title":"Properties","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"length(::ITensors.AbstractMPS)\nflux(::ITensors.AbstractMPS)\nmaxlinkdim(::ITensors.AbstractMPS)\nhasqns(::ITensors.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#Base.length-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"Base.length","text":"length(::MPS/MPO)\n\nThe number of sites of an MPS/MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.flux-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.flux","text":"flux(M::MPS)\n\nflux(M::MPO)\n\ntotalqn(M::MPS)\n\ntotalqn(M::MPO)\n\nFor an MPS or MPO which conserves quantum numbers, compute the total QN flux. For a tensor network such as an MPS or MPO, the flux is the sum of fluxes of each of the tensors in the network. The name totalqn is an alias for flux.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.maxlinkdim-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.maxlinkdim","text":"maxlinkdim(M::MPS)\n\nmaxlinkdim(M::MPO)\n\nGet the maximum link dimension of the MPS or MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.hasqns-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.hasqns","text":"hasqns(M::MPS)\n\nhasqns(M::MPO)\n\nReturn true if the MPS or MPO has tensors which carry quantum numbers.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Obtaining-and-finding-indices-1","page":"MPS and MPO","title":"Obtaining and finding indices","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"common_siteind(::ITensors.AbstractMPS, ::ITensors.AbstractMPS, ::Int)\ncommon_siteinds(::ITensors.AbstractMPS, ::ITensors.AbstractMPS)\nfindsite\nfindsites\nfirstsiteind\nfirstsiteinds\nlinkind(::ITensors.AbstractMPS,::Int)\nsiteind(::MPS, ::Int)\nsiteinds(::MPS)\nsiteind(::MPO, ::Int)\nsiteinds(::MPO)\nsiteinds(::ITensors.AbstractMPS, ::Int)\nunique_siteind(::ITensors.AbstractMPS, ::ITensors.AbstractMPS, ::Int)\nunique_siteinds(::ITensors.AbstractMPS, ::ITensors.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.common_siteind-Tuple{ITensors.AbstractMPS,ITensors.AbstractMPS,Int64}","page":"MPS and MPO","title":"ITensors.common_siteind","text":"common_siteind(A::MPO, B::MPS, j::Integer)\ncommon_siteind(A::MPO, B::MPO, j::Integer)\n\nGet the site index of MPO A that is shared with MPS/MPO B.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.common_siteinds-Tuple{ITensors.AbstractMPS,ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.common_siteinds","text":"common_siteinds(A::MPO, B::MPS)\ncommon_siteinds(A::MPO, B::MPO)\n\nGet the site indices of MPO A that are shared with MPS/MPO B, as a Vector{<:Index}.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.findsite","page":"MPS and MPO","title":"ITensors.findsite","text":"findsite(M::Union{MPS, MPO}, is)\n\nReturn the first site of the MPS or MPO that has at least one Index in common with the Index or collection of indices is.\n\nTo find all sites with common indices with is, use the  findsites function.\n\nExamples\n\ns = siteinds(\"S=1/2\", 5)\nψ = randomMPS(s)\nfindsite(ψ, s[3]) == 3\nfindsite(ψ, (s[3], s[4])) == 3\n\nM = MPO(s)\nfindsite(M, s[4]) == 4\nfindsite(M, s[4]') == 4\nfindsite(M, (s[4]', s[4])) == 4\nfindsite(M, (s[4]', s[3])) == 3\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensors.findsites","page":"MPS and MPO","title":"ITensors.findsites","text":"findsites(M::Union{MPS, MPO}, is)\n\nReturn the sites of the MPS or MPO that have indices in common with the collection of site indices is.\n\nExamples\n\ns = siteinds(\"S=1/2\", 5)\nψ = randomMPS(s)\nfindsites(ψ, s[3]) == [3]\nfindsites(ψ, (s[4], s[1])) == [1, 4]\n\nM = MPO(s)\nfindsites(M, s[4]) == [4]\nfindsites(M, s[4]') == [4]\nfindsites(M, (s[4]', s[4])) == [4]\nfindsites(M, (s[4]', s[3])) == [3, 4]\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensors.firstsiteinds","page":"MPS and MPO","title":"ITensors.firstsiteinds","text":"firstsiteinds(M::MPO; kwargs...)\n\nGet a Vector of the first site Index found on each site of M.\n\nBy default, it finds the first site Index with prime level 0.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensors.linkind-Tuple{ITensors.AbstractMPS,Int64}","page":"MPS and MPO","title":"ITensors.linkind","text":"linkind(M::MPS, j::Integer)\n\nlinkind(M::MPO, j::Integer)\n\nGet the link or bond Index connecting the MPS or MPO tensor on site j to site j+1.\n\nIf there is no link Index, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.siteind-Tuple{MPS,Int64}","page":"MPS and MPO","title":"ITensors.siteind","text":"siteind(M::MPS, j::Int; kwargs...)\n\nGet the first site Index of the MPS. Return nothing if none is found.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.siteinds-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.siteinds","text":"siteinds(M::MPS)\nsiteinds(::typeof(first), M::MPS)\n\nGet a vector of the first site Index found on each tensor of the MPS.\n\nsiteinds(::typeof(only), M::MPS)\n\nGet a vector of the only site Index found on each tensor of the MPS. Errors if more than one is found.\n\nsiteinds(::typeof(all), M::MPS)\n\nGet a vector of the all site Indices found on each tensor of the MPS. Returns a Vector of IndexSets.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.siteind-Tuple{MPO,Int64}","page":"MPS and MPO","title":"ITensors.siteind","text":"siteind(M::MPO, j::Int; plev = 0, kwargs...)\n\nGet the first site Index of the MPO found, by default with prime level 0. \n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.siteinds-Tuple{MPO}","page":"MPS and MPO","title":"ITensors.siteinds","text":"siteinds(M::MPO; kwargs...)\n\nGet a Vector of IndexSets of all the site indices of M.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.siteinds-Tuple{ITensors.AbstractMPS,Int64}","page":"MPS and MPO","title":"ITensors.siteinds","text":"siteinds(M::Union{MPS, MPO}}, j::Integer; kwargs...)\n\nReturn the site Indices found of the MPO or MPO at the site j as an IndexSet.\n\nOptionally filter prime tags and prime levels with keyword arguments like plev and tags.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.unique_siteind-Tuple{ITensors.AbstractMPS,ITensors.AbstractMPS,Int64}","page":"MPS and MPO","title":"ITensors.unique_siteind","text":"unique_siteind(A::MPO, B::MPS, j::Integer)\nunique_siteind(A::MPO, B::MPO, j::Integer)\n\nGet the site index of MPO A that is unique to A (not shared with MPS/MPO B).\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.unique_siteinds-Tuple{ITensors.AbstractMPS,ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.unique_siteinds","text":"unique_siteinds(A::MPO, B::MPS)\nunique_siteinds(A::MPO, B::MPO)\n\nGet the site indices of MPO A that are unique to A (not shared with MPS/MPO B), as a Vector{<:Index}.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Priming-and-tagging-1","page":"MPS and MPO","title":"Priming and tagging","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"prime(::ITensors.AbstractMPS)\nprime!(::ITensors.AbstractMPS)\nsetprime(::ITensors.AbstractMPS)\nsetprime!(::ITensors.AbstractMPS)\nnoprime(::ITensors.AbstractMPS)\nnoprime!(::ITensors.AbstractMPS)\naddtags(::ITensors.AbstractMPS)\naddtags!(::ITensors.AbstractMPS)\nremovetags(::ITensors.AbstractMPS)\nremovetags!(::ITensors.AbstractMPS)\nreplacetags(::ITensors.AbstractMPS)\nreplacetags!(::ITensors.AbstractMPS)\nsettags(::ITensors.AbstractMPS)\nsettags!(::ITensors.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime(M::MPS, args...; kwargs...)\n\nprime(M::MPO, args...; kwargs...)\n\nApply prime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.prime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime!","text":"prime!(M::MPS, args...; kwargs...)\n\nprime!(M::MPO, args...; kwargs...)\n\nApply prime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime(M::MPS, args...; kwargs...)\n\nsetprime(M::MPO, args...; kwargs...)\n\nApply setprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime!","text":"setprime!(M::MPS, args...; kwargs...)\n\nsetprime!(M::MPO, args...; kwargs...)\n\nApply setprime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime(M::MPS, args...; kwargs...)\n\nnoprime(M::MPO, args...; kwargs...)\n\nApply noprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime!","text":"noprime!(M::MPS, args...; kwargs...)\n\nnoprime!(M::MPO, args...; kwargs...)\n\nApply noprime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.addtags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.addtags","text":"addtags(M::MPS, args...; kwargs...)\n\naddtags(M::MPO, args...; kwargs...)\n\nApply addtags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.addtags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.addtags!","text":"addtags!(M::MPS, args...; kwargs...)\n\naddtags!(M::MPO, args...; kwargs...)\n\nApply addtags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.removetags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.removetags","text":"removetags(M::MPS, args...; kwargs...)\n\nremovetags(M::MPO, args...; kwargs...)\n\nApply removetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.removetags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.removetags!","text":"removetags!(M::MPS, args...; kwargs...)\n\nremovetags!(M::MPO, args...; kwargs...)\n\nApply removetags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.replacetags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.replacetags","text":"replacetags(M::MPS, args...; kwargs...)\n\nreplacetags(M::MPO, args...; kwargs...)\n\nApply replacetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.replacetags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.replacetags!","text":"replacetags!(M::MPS, args...; kwargs...)\n\nreplacetags!(M::MPO, args...; kwargs...)\n\nApply replacetags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags(M::MPS, args...; kwargs...)\n\nsettags(M::MPO, args...; kwargs...)\n\nApply settags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags!","text":"settags!(M::MPS, args...; kwargs...)\n\nsettags!(M::MPO, args...; kwargs...)\n\nApply settags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Operations-1","page":"MPS and MPO","title":"Operations","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"dag(::ITensors.AbstractMPS)\ndag!(::ITensors.AbstractMPS)\ndense(::ITensors.AbstractMPS)\nmovesite(::ITensors.AbstractMPS, ::Pair{Int, Int};orthocenter::Int,kwargs...)\northogonalize!\nreplacebond!(::MPS, ::Int, ::ITensor)\nsample(::MPS)\nsample!(::MPS)\nsample(::MPO)\nswapbondsites(::ITensors.AbstractMPS, ::Int; kwargs...)\ntruncate!","category":"page"},{"location":"MPSandMPO.html#ITensors.dag-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.dag","text":"dag(M::MPS, args...; kwargs...)\n\ndag(M::MPO, args...; kwargs...)\n\nApply dag to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.dag!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.dag!","text":"dag!(M::MPS, args...; kwargs...)\n\ndag!(M::MPO, args...; kwargs...)\n\nApply dag to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#NDTensors.dense-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"NDTensors.dense","text":"dense(::MPS/MPO)\n\nGiven an MPS (or MPO), return a new MPS (or MPO)  having called dense on each ITensor to convert each tensor to use dense storage and remove any QN or other sparse structure information, if it is not dense already.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.movesite-Tuple{ITensors.AbstractMPS,Pair{Int64,Int64}}","page":"MPS and MPO","title":"ITensors.movesite","text":"movesite(::Union{MPS, MPO}, n1n2::Pair{Int, Int})\n\nCreate a new MPS/MPO where the site at n1 is moved to n2, for a pair n1n2 = n1 => n2.\n\nThis is done with a series a pairwise swaps, and can introduce a lot of entanglement into your state, so use with caution.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.orthogonalize!","page":"MPS and MPO","title":"ITensors.orthogonalize!","text":"orthogonalize!(M::MPS, j::Int; kwargs...)\northogonalize(M::MPS, j::Int; kwargs...)\n\northogonalize!(M::MPO, j::Int; kwargs...)\northogonalize(M::MPO, j::Int; kwargs...)\n\nMove the orthogonality center of the MPS to site j. No observable property of the MPS will be changed, and no truncation of the bond indices is performed. Afterward, tensors 1,2,...,j-1 will be left-orthogonal and tensors j+1,j+2,...,N will be right-orthogonal.\n\nEither modify in-place with orthogonalize! or out-of-place with orthogonalize.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensors.replacebond!-Tuple{MPS,Int64,ITensor}","page":"MPS and MPO","title":"ITensors.replacebond!","text":"replacebond!(M::MPS, b::Int, phi::ITensor; kwargs...)\n\nFactorize the ITensor phi and replace the ITensors b and b+1 of MPS M with the factors. Choose the orthogonality with ortho=\"left\"/\"right\".\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.sample-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.sample","text":"sample(m::MPS)\n\nGiven a normalized MPS m with orthocenter(m)==1, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.sample!-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.sample!","text":"sample!(m::MPS)\n\nGiven a normalized MPS m, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents. If the MPS does not have an orthogonality center, orthogonalize!(m,1) will be called before computing the sample.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.sample-Tuple{MPO}","page":"MPS and MPO","title":"ITensors.sample","text":"sample(M::MPO)\n\nGiven a normalized MPO M, returns a Vector{Int} of length(M) corresponding to one sample of the probability distribution defined by the MPO, treating the MPO as a density matrix.\n\nThe MPO M should have an (approximately) positive spectrum.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.swapbondsites-Tuple{ITensors.AbstractMPS,Int64}","page":"MPS and MPO","title":"ITensors.swapbondsites","text":"swapbondsites(ψ::Union{MPS, MPO}, b::Integer; kwargs...)\n\nSwap the sites b and b+1.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#NDTensors.truncate!","page":"MPS and MPO","title":"NDTensors.truncate!","text":"truncate!(M::MPS; kwargs...)\n\ntruncate!(M::MPO; kwargs...)\n\nPerform a truncation of all bonds of an MPS/MPO, using the truncation parameters (cutoff,maxdim, etc.) provided as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#Gate-evolution-1","page":"MPS and MPO","title":"Gate evolution","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"product(::Vector{ <: ITensor}, ::ITensors.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.product-Tuple{Array{#s76,1} where #s76<:ITensor,ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.product","text":"product(As::Vector{<:ITensor}, M::Union{MPS, MPO}; <keyword arguments>)\napply([...])\n\nApply the ITensors As to the MPS or MPO M, treating them as gates or matrices from pairs of prime or unprimed indices.\n\nExamples\n\nApply one-site gates to an MPS:\n\nN = 3\n\nITensors.op(::OpName\"σx\", ::SiteType\"S=1/2\", s::Index) =\n  2*op(\"Sx\", s)\n\nITensors.op(::OpName\"σz\", ::SiteType\"S=1/2\", s::Index) =\n  2*op(\"Sz\", s)\n\n# Make the operator list.\nos = [(\"σx\", n) for n in 1:N]\nappend!(os, [(\"σz\", n) for n in 1:N])\n\n@show os\n\ns = siteinds(\"S=1/2\", N)\ngates = ops(os, s)\n\n# Starting state |↑↑↑⟩\nψ0 = productMPS(s, \"↑\")\n\n# Apply the gates.\nψ = apply(gates, ψ0; cutoff = 1e-15)\n\n# Test against exact (full) wavefunction\nprodψ = apply(gates, prod(ψ0))\n@show prod(ψ) ≈ prodψ\n\n# The result is:\n# σz₃ σz₂ σz₁ σx₃ σx₂ σx₁ |↑↑↑⟩ = -|↓↓↓⟩\n@show inner(ψ, productMPS(s, \"↓\")) == -1\n\nApply nonlocal two-site gates and one-site gates to an MPS:\n\n# 2-site gate\nfunction ITensors.op(::OpName\"CX\", ::SiteType\"S=1/2\", s1::Index, s2::Index)\n  mat = [1 0 0 0\n         0 1 0 0\n         0 0 0 1\n         0 0 1 0]\n  return itensor(mat, s2', s1', s2, s1)\nend\n\nos = [(\"CX\", 1, 3), (\"σz\", 3)]\n\n@show os\n\n# Start with the state |↓↑↑⟩\nψ0 = productMPS(s, n -> n == 1 ? \"↓\" : \"↑\")\n\n# The result is:\n# σz₃ CX₁₃ |↓↑↑⟩ = -|↓↑↓⟩\nψ = apply(ops(os, s), ψ0; cutoff = 1e-15)\n@show inner(ψ, productMPS(s, n -> n == 1 || n == 3 ? \"↓\" : \"↑\")) == -1\n\nPerform TEBD-like time evolution:\n\n# Define the nearest neighbor term `S⋅S` for the Heisenberg model\nfunction ITensors.op(::OpName\"expS⋅S\", ::SiteType\"S=1/2\",\n                     s1::Index, s2::Index; τ::Number)\n  O = 0.5 * op(\"S+\", s1) * op(\"S-\", s2) +\n      0.5 * op(\"S-\", s1) * op(\"S+\", s2) +\n            op(\"Sz\", s1) * op(\"Sz\", s2)\n  return exp(τ * O)\nend\n\nτ = -0.1im\nos = [(\"expS⋅S\", (1, 2), (τ = τ,)),\n      (\"expS⋅S\", (2, 3), (τ = τ,))]\nψ0 = productMPS(s, n -> n == 1 ? \"↓\" : \"↑\")\nexpτH = ops(os, s)\nψτ = apply(expτH, ψ0)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Algebra-Operations-1","page":"MPS and MPO","title":"Algebra Operations","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"dot(::MPST, ::MPST) where {MPST <: ITensors.AbstractMPS}\nlogdot(::MPST, ::MPST) where {MPST <: ITensors.AbstractMPS}\nnorm(::ITensors.AbstractMPS)\nlognorm(::ITensors.AbstractMPS)\n+(::MPS, ::MPS)\n*(::MPO, ::MPS)","category":"page"},{"location":"MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST,MPST}} where MPST<:ITensors.AbstractMPS","page":"MPS and MPO","title":"LinearAlgebra.dot","text":"dot(A::MPS, B::MPS; make_inds_match = true)\ninner(A::MPS, B::MPS; make_inds_match = true)\n\ndot(A::MPO, B::MPO)\ninner(A::MPO, B::MPO)\n\nCompute the inner product <A|B>. If A and B are MPOs, computes the Frobenius inner product.\n\nIf make_inds_match = true, the function attempts to make the site indices match before contracting (so for example, the inputs can have different site indices, as long as they have the same dimensions or QN blocks).\n\nFor now, make_inds_match is only supported for MPSs.\n\nSee also logdot/loginner.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.logdot-Union{Tuple{MPST}, Tuple{MPST,MPST}} where MPST<:ITensors.AbstractMPS","page":"MPS and MPO","title":"ITensors.logdot","text":"logdot(A::MPS, B::MPS; make_inds_match = true)\nloginner(A::MPS, B::MPS; make_inds_match = true)\n\nlogdot(A::MPO, B::MPO)\nloginner(A::MPO, B::MPO)\n\nCompute the logarithm of the inner product <A|B>. If A and B are MPOs, computes the logarithm of the Frobenius inner product.\n\nThis is useful for larger MPS/MPO, where in the limit of large numbers of sites the inner product can diverge or approach zero.\n\nIf make_inds_match = true, the function attempts to make the site indices match before contracting (so for example, the inputs can have different site indices, as long as they have the same dimensions or QN blocks).\n\nFor now, make_inds_match is only supported for MPSs.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.norm-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"LinearAlgebra.norm","text":"norm(A::MPS)\n\nnorm(A::MPO)\n\nCompute the norm of the MPS or MPO.\n\nSee also lognorm.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.lognorm-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.lognorm","text":"lognorm(A::MPS)\n\nlognorm(A::MPO)\n\nCompute the logarithm of the norm of the MPS or MPO. \n\nThis is useful for larger MPS/MPO that are not gauged, where in the limit of large numbers of sites the norm can diverge or approach zero.\n\nSee also norm and loginner/logdot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:+-Tuple{MPS,MPS}","page":"MPS and MPO","title":"Base.:+","text":"+(A::MPS/MPO...; kwargs...)\nadd(A::MPS/MPO...; kwargs...)\n\nAdd arbitrary numbers of MPS/MPO with each other, with some optional truncation.\n\nA cutoff of 1e-15 is used by default, and in general users should set their own cutoff for their particular application.\n\nIn the future we will give an interface for returning the truncation error.\n\nExamples\n\nN = 10\n\ns = siteinds(\"S=1/2\", N; conserve_qns = true)\n\nstate = n -> isodd(n) ? \"↑\" : \"↓\"\nψ₁ = randomMPS(s, state, 2)\nψ₂ = randomMPS(s, state, 2)\nψ₃ = randomMPS(s, state, 2)\n\nψ = +(ψ₁, ψ₂; cutoff = 1e-8)\n\n# Can use:\n#\n# ψ = ψ₁ + ψ₂\n#\n# but generally you want to set a custom `cutoff` and `maxdim`.\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₂) + inner(ψ₁, ψ₂) + inner(ψ₂, ψ₁) + inner(ψ₂, ψ₂)\n\n# Computes ψ₁ + 2ψ₂\nψ = ψ₁ + 2ψ₂\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + 2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂)\n\n# Computes ψ₁ + 2ψ₂ + ψ₃\nψ = ψ₁ + 2ψ₂ + ψ₃\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + inner(ψ₁, ψ₃) +\n      2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂) + 2 * inner(ψ₂, ψ₃) +\n      inner(ψ₃, ψ₁) + 2 * inner(ψ₃, ψ₂) + inner(ψ₃, ψ₃)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:*-Tuple{MPO,MPS}","page":"MPS and MPO","title":"Base.:*","text":"contract(::MPS, ::MPO; kwargs...)\n*(::MPS, ::MPO; kwargs...)\n\ncontract(::MPO, ::MPS; kwargs...)\n*(::MPO, ::MPS; kwargs...)\n\nContract the MPO with the MPS, returning an MPS with the unique site indices of the MPO.\n\nChoose the method with the method keyword, for example \"densitymatrix\" and \"naive\".\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ProjMPO-1","page":"ProjMPO","title":"ProjMPO","text":"","category":"section"},{"location":"ProjMPO.html#Description-1","page":"ProjMPO","title":"Description","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"ProjMPO","category":"page"},{"location":"ProjMPO.html#ITensors.ProjMPO","page":"ProjMPO","title":"ITensors.ProjMPO","text":"A ProjMPO computes and stores the projection of an MPO into a basis defined by an MPS, leaving a certain number of site indices of the MPO unprojected. Which sites are unprojected can be shifted by calling the position! method.\n\nDrawing of the network represented by a ProjMPO P(H),  showing the case of nsite(P)==2 and position!(P,psi,4)  for an MPS psi:\n\no--o--o-      -o--o--o--o--o--o <psi|\n|  |  |  |  |  |  |  |  |  |  |\no--o--o--o--o--o--o--o--o--o--o H\n|  |  |  |  |  |  |  |  |  |  |\no--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPO.html#Methods-1","page":"ProjMPO","title":"Methods","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"product(::ProjMPO,::ITensor)\nposition!(::ProjMPO, ::MPS, ::Int)\nnoiseterm(::ProjMPO,::ITensor,::String)","category":"page"},{"location":"ProjMPO.html#ITensors.product-Tuple{ProjMPO,ITensor}","page":"ProjMPO","title":"ITensors.product","text":"product(P::ProjMPO,v::ITensor{N})::ITensor{N}\n\n(P::ProjMPO)(v::ITensor)\n\nEfficiently multiply the ProjMPO P by an ITensor v in the sense that the ProjMPO is a generalized square matrix or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensors.position!-Tuple{ProjMPO,MPS,Int64}","page":"ProjMPO","title":"ITensors.position!","text":"position!(P::ProjMPO, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPO P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPO on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensors.noiseterm-Tuple{ProjMPO,ITensor,String}","page":"ProjMPO","title":"ITensors.noiseterm","text":"noiseterm(P::ProjMPO,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the  ProjMPO P, and ortho is a String which can take the values \"left\" or \"right\" depending on the  sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Properties-1","page":"ProjMPO","title":"Properties","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"length(::ProjMPO)\neltype(::ProjMPO)\nsize(::ProjMPO)","category":"page"},{"location":"ProjMPO.html#Base.length-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.length","text":"length(P::ProjMPO)\n\nThe length of a ProjMPO is the same as the length of the MPO used to construct it\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.eltype-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.eltype","text":"eltype(P::ProjMPO)\n\nDeduce the element type (such as Float64 or ComplexF64) of the tensors in the ProjMPO P.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.size-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.size","text":"size(P::ProjMPO)\n\nThe size of a ProjMPO are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d. \n\nFor example, if a ProjMPO maps from a space with  indices (a,s1,s2,b) to the space (a',s1',s2',b')  then the size is (d,d) where  d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ProjMPOSum-1","page":"ProjMPOSum","title":"ProjMPOSum","text":"","category":"section"},{"location":"ProjMPOSum.html#Description-1","page":"ProjMPOSum","title":"Description","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"ProjMPOSum","category":"page"},{"location":"ProjMPOSum.html#ITensors.ProjMPOSum","page":"ProjMPOSum","title":"ITensors.ProjMPOSum","text":"A ProjMPOSum computes and stores the projection of an implied sum of MPOs into a basis defined by an MPS,  leaving a certain number of site indices of each MPO  unprojected. Which sites are unprojected can be shifted  by calling the position! method. The MPOs used as  input to a ProjMPOSum are not added together beforehand; instead when the product method of a ProjMPOSum is invoked, each projected MPO in the set of MPOs is multiplied by the input tensor one-by-one in an efficient way.\n\nDrawing of the network represented by a ProjMPOSum  P([H1,H2,...]), showing the case of nsite(P)==2  and position!(P,psi,4) for an MPS psi (note the sum Σⱼ on the left):\n\n     o--o--o-      -o--o--o--o--o--o <psi|\n     |  |  |  |  |  |  |  |  |  |  |\n Σⱼ  o--o--o--o--o--o--o--o--o--o--o Hⱼ\n     |  |  |  |  |  |  |  |  |  |  |\n     o--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPOSum.html#Methods-1","page":"ProjMPOSum","title":"Methods","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"product(::ProjMPOSum,::ITensor)\nposition!(::ProjMPOSum, ::MPS, ::Int)\nnoiseterm(::ProjMPOSum,::ITensor,::String)","category":"page"},{"location":"ProjMPOSum.html#ITensors.product-Tuple{ProjMPOSum,ITensor}","page":"ProjMPOSum","title":"ITensors.product","text":"product(P::ProjMPOSum,v::ITensor)\n\n(P::ProjMPOSum)(v::ITensor)\n\nEfficiently multiply the ProjMPOSum P by an ITensor v in the sense that the ProjMPOSum is a generalized square matrix  or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensors.position!-Tuple{ProjMPOSum,MPS,Int64}","page":"ProjMPOSum","title":"ITensors.position!","text":"position!(P::ProjMPOSum, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPOSum P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPOs on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensors.noiseterm-Tuple{ProjMPOSum,ITensor,String}","page":"ProjMPOSum","title":"ITensors.noiseterm","text":"noiseterm(P::ProjMPOSum,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the  ProjMPOSum P, and ortho is a String which can take the values \"left\" or \"right\" depending on the  sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Properties-1","page":"ProjMPOSum","title":"Properties","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"length(::ProjMPOSum)\neltype(::ProjMPOSum)\nsize(::ProjMPOSum)","category":"page"},{"location":"ProjMPOSum.html#Base.length-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.length","text":"length(is::IndexSet)\n\nThe number of indices in the IndexSet.\n\n\n\n\n\nlength(::Type{<:IndexSet})\n\nThe number of indices in the IndexSet type.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Base.eltype-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.eltype","text":"eltype(::IndexSet)\n\nGet the element type of the IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Base.size-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.size","text":"size(P::ProjMPOSum)\n\nThe size of a ProjMPOSum are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d. \n\nFor example, if a ProjMPOSum maps from a space with  indices (a,s1,s2,b) to the space (a',s1',s2',b')  then the size is (d,d) where  d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"SiteType.html#SiteType-and-op-1","page":"SiteType and op","title":"SiteType and op","text":"","category":"section"},{"location":"SiteType.html#Description-1","page":"SiteType and op","title":"Description","text":"","category":"section"},{"location":"SiteType.html#","page":"SiteType and op","title":"SiteType and op","text":"SiteType","category":"page"},{"location":"SiteType.html#ITensors.SiteType","page":"SiteType and op","title":"ITensors.SiteType","text":"SiteType is a parameterized type which allows making Index tags into Julia types. Use cases include overloading functions such as op, siteinds, and state which generate custom operators, Index arrays, and IndexVals associated with Index objects having a certain tag.\n\nTo make a SiteType type, you can use the string macro notation: SiteType\"MyTag\"\n\nTo make a SiteType value or object, you can use the notation: SiteType(\"MyTag\")\n\nThere are currently a few built-in site types recognized by ITensors.jl. The system is easily extensible by users. To add new operators to an existing site type, you can follow the instructions here. To create new site types, you can follow the instructions here and  here.\n\nThe current built-in site types are:\n\nSiteType\"S=1/2\" (or SiteType\"S=½\")\nSiteType\"S=1\"\nSiteType\"Fermion\"\nSiteType\"tJ\"\nSiteType\"Electron\"\n\nExamples\n\nTags on indices get turned into SiteTypes internally, and then we search for overloads of functions like op and siteind. For example:\n\njulia> s = siteind(\"S=1/2\")\n(dim=2|id=862|\"S=1/2,Site\")\n\njulia> @show op(\"Sz\", s);\nop(s, \"Sz\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.5   0.0\n 0.0  -0.5\n\njulia> @show op(\"Sx\", s);\nop(s, \"Sx\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.0  0.5\n 0.5  0.0\n\njulia> @show op(\"Sy\", s);\nop(s, \"Sy\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Complex{Float64},Array{Complex{Float64},1}}\n 2×2\n 0.0 + 0.0im  -0.0 - 0.5im\n 0.0 + 0.5im   0.0 + 0.0im\n\njulia> s = siteind(\"Electron\")\n(dim=4|id=734|\"Electron,Site\")\n\njulia> @show op(\"Nup\", s);\nop(s, \"Nup\") = ITensor ord=2\nDim 1: (dim=4|id=734|\"Electron,Site\")'\nDim 2: (dim=4|id=734|\"Electron,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 4×4\n 0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0\n\nMany operators are available, for example:\n\nSiteType\"S=1/2\": \"Sz\", \"Sx\", \"Sy\", \"S+\", \"S-\", ...\nSiteType\"Electron\": \"Nup\", \"Ndn\", \"Nupdn\", \"Ntot\", \"Cup\", \"Cdagup\", \"Cdn\", \"Cdagup\", \"Sz\", \"Sx\", \"Sy\", \"S+\", \"S-\", ...\n...\n\nYou can view the source code for the internal SiteType definitions and operators that are defined here.\n\n\n\n\n\n","category":"type"},{"location":"SiteType.html#Methods-1","page":"SiteType and op","title":"Methods","text":"","category":"section"},{"location":"SiteType.html#","page":"SiteType and op","title":"SiteType and op","text":"op","category":"page"},{"location":"SiteType.html#ITensors.op","page":"SiteType and op","title":"ITensors.op","text":"op(opname::String, s::Index; kwargs...)\n\nReturn an ITensor corresponding to the operator named opname for the Index s. The operator is constructed by calling an overload of either the op or op! methods which take a SiteType argument that corresponds to one of the tags of the Index s and an OpName\"opname\" argument that corresponds to the input operator name.\n\nOperator names can be combined using the \"*\" symbol, for example \"S+*S-\" or \"Sz*Sz*Sz\".  The result is an ITensor made by forming each operator  then contracting them together in a way corresponding to the usual operator product or matrix multiplication.\n\nThe op system is used by the AutoMPO system to convert operator names into ITensors, and can be used directly such as for applying operators to MPS.\n\nExample\n\ns = Index(2, \"Site,S=1/2\")\nSz = op(\"Sz\", s)\n\n\n\n\n\nop(opname::String,sites::Vector{<:Index},n::Int; kwargs...)\n\nReturn an ITensor corresponding to the operator named opname for the n'th Index in the array  sites.\n\nExample\n\ns = siteinds(\"S=1/2\", 4)\nSz2 = op(\"Sz\", s, 2)\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensor-1","page":"ITensor","title":"ITensor","text":"","category":"section"},{"location":"ITensorType.html#Description-1","page":"ITensor","title":"Description","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor","category":"page"},{"location":"ITensorType.html#ITensors.ITensor","page":"ITensor","title":"ITensors.ITensor","text":"ITensor{N}\n\nAn ITensor is a tensor whose interface is  independent of its memory layout. Therefore it is not necessary to know the ordering of an ITensor's indices, only which indices an ITensor has. Operations like contraction and addition of ITensors automatically handle any memory permutations.\n\nExamples\n\njulia> i = Index(2, \"i\")\n(dim=2|id=287|\"i\")\n\njulia> A = randomITensor(i', i)\nITensor ord=2 (dim=2|id=287|\"i\")' (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")'\nDim 2: (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.28358594718392427   1.4342219756446355\n 1.6620103556283987   -0.40952231269251566\n\njulia> @show inds(A);\ninds(A) = IndexSet{2} (dim=2|id=287|\"i\")' (dim=2|id=287|\"i\") \n\njulia> A[i => 1, i' => 2] = 1;\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")'\nDim 2: (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.28358594718392427   1.4342219756446355\n 1.0                  -0.40952231269251566\n\njulia> @show store(A);\nstore(A) = [0.28358594718392427, 1.0, 1.4342219756446355, -0.40952231269251566]\n\njulia> B = randomITensor(i, i');\n\njulia> @show B;\nB = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")\nDim 2: (dim=2|id=287|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n -0.6510816500352691   0.2579101497658179\n  0.256266641521826   -0.9464735926768166\n\njulia> @show A + B;\nA + B = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")'\nDim 2: (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n -0.3674957028513448   1.6904886171664615\n  1.2579101497658178  -1.3559959053693322\n\n\n\n\n\n","category":"type"},{"location":"ITensorType.html#Dense-Constructors-1","page":"ITensor","title":"Dense Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor(::Type{<:Number}, ::ITensors.Indices)\nITensor(::Type{<:Number}, ::UndefInitializer, ::ITensors.Indices)\nrandomITensor(::Type{<:Number}, ::ITensors.Indices)\nsetelt(::IndexVal)","category":"page"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s76} where #s76<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ]inds)\nITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor filled with zeros having indices inds and element type ElT. If the element type is not specified, it defaults to Float64.\n\nThe storage will have NDTensors.Dense type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s76} where #s76<:Number,UndefInitializer,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)\nITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...)\n\nConstruct an ITensor filled with undefined elements having indices inds and element type ElT. If the element type is not specified, it defaults to Float64.\n\nThe storage will have NDTensors.Dense type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.randomITensor-Tuple{Type{#s76} where #s76<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.randomITensor","text":"randomITensor([::Type{ElT <: Number} = Float64, ]inds)\n\nrandomITensor([::Type{ElT <: Number} = Float64, ]inds::Index...)\n\nConstruct an ITensor with type ElT and indices inds, whose elements are normally distributed random numbers. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.setelt-Tuple{IndexVal}","page":"ITensor","title":"ITensors.setelt","text":"setelt(ivs...)\n\nCreate an ITensor with all zeros except the specified value, which is set to 1.\n\nExamples\n\ni = Index(2,\"i\")\nA = setelt(i=>2)\n# A[i=>2] == 1, all other elements zero\n\nj = Index(3,\"j\")\nB = setelt(i=>1,j=>3)\n# B[i=>1,j=>3] == 1, all other element zero\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-BlockSparse-Constructors-1","page":"ITensor","title":"QN BlockSparse Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor(::Type{<:Number}, ::QN, ::ITensors.Indices)\nITensor(A::Array, inds::ITensors.QNIndexSet)","category":"page"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s76} where #s76<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds)\nITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds::Index...)\n\nConstruct an ITensor with BlockSparse storage filled with zero(ElT) where the nonzero blocks are determined by flux.\n\nIf ElT is not specified it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Array,IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}} where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor(::Array, ::IndexSet; tol = 0)\n\nITensor(::Array, ::Index...; tol = 0)\n\nCreate a block sparse ITensor from the input Array, and collection  of QN indices. Zeros are dropped and nonzero blocks are determined from the zero values of the array.\n\nOptionally, you can set a tolerance such that elements less than or equal to the tolerance are dropped.\n\nExamples\n\njulia> i = Index([QN(0)=>1, QN(1)=>2], \"i\");\n\njulia> A = [1e-9 0.0 0.0;\n            0.0 2.0 3.0;\n            0.0 1e-10 4.0];\n\njulia> @show ITensor(A, i', dag(i); tol = 1e-8);\nITensor(A, i', dag(i); tol = 1.0e-8) = ITensor ord=2\nDim 1: (dim=3|id=468|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=468|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.BlockSparse{Float64,Array{Float64,1},2}\n 3×3\nBlock: (2, 2)\n [2:3, 2:3]\n 2.0  3.0\n 0.0  4.0\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Empty-Constructors-1","page":"ITensor","title":"Empty Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"emptyITensor(::Type{<:Number}, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.emptyITensor-Tuple{Type{#s76} where #s76<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.emptyITensor","text":"emptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor with storage type NDTensors.Empty, indices inds, and element type ElT. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-Empty-Constructors-1","page":"ITensor","title":"QN Empty Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"emptyITensor(::Type{<:Number}, ::ITensors.QNIndices)","category":"page"},{"location":"ITensorType.html#ITensors.emptyITensor-Tuple{Type{#s76} where #s76<:Number,Union{Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}, IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}}} where N}","page":"ITensor","title":"ITensors.emptyITensor","text":"emptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor with storage type NDTensors.Empty, indices inds, and element type ElT. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\nemptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::QNIndex...)\n\nConstruct an ITensor with NDTensors.BlockSparse storage of element type ElT with the no blocks.\n\nIf ElT is not specified it defaults to Float64.\n\nIn the future, this will use the storage NDTensors.EmptyBlockSparse.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Diagonal-constructors-1","page":"ITensor","title":"Diagonal constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"diagITensor(::Type{<:Number}, ::ITensors.Indices)\ndiagITensor(::Vector{<:Number}, ::ITensors.Indices)\ndiagITensor(::Number, ::ITensors.Indices)\ndelta(::Type{<:Number}, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Type{#s76} where #s76<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor([::Type{ElT} = Float64, ]inds)\ndiagITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nMake a sparse ITensor of element type ElT with only elements along the diagonal stored. Defaults to having zero(T) along  the diagonal.\n\nThe storage will have NDTensors.Diag type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Array{#s76,1} where #s76<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor(v::Vector{T}, inds)\ndiagITensor(v::Vector{T}, inds::Index...)\n\nMake a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the values stored in v and  the ITensor will have element type float(T). The storage will have type NDTensors.Diag.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor(x::Number, inds)\ndiagITensor(x::Number, inds::Index...)\n\nMake a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the value float(x) and the ITensor will have element type float(eltype(x)). The storage will have NDTensors.Diag type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.delta-Tuple{Type{#s76} where #s76<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.delta","text":"delta([::Type{ElT} = Float64, ]inds)\ndelta([::Type{ElT} = Float64, ]inds::Index...)\n\nMake a uniform diagonal ITensor with all diagonal elements one(ElT). Only a single diagonal element is stored.\n\nThis function has an alias δ.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-Diagonal-constructors-1","page":"ITensor","title":"QN Diagonal constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"diagITensor(::Type{<:Number}, ::QN, ::ITensors.Indices)\ndelta(::Type{<:Number}, ::QN, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Type{#s76} where #s76<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndiagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)\n\nMake an ITensor with storage type NDTensors.DiagBlockSparse with elements zero(ElT). The ITensor only has diagonal blocks consistent with the specified flux.\n\nIf the element type is not specified, it defaults to Float64. If theflux is not specified, it defaults to QN().\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.delta-Tuple{Type{#s76} where #s76<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.delta","text":"delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndelta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)\n\nMake an ITensor with storage type NDTensors.DiagBlockSparse with uniform elements one(ElT). The ITensor only has diagonal blocks consistent with the specified flux.\n\nIf the element type is not specified, it defaults to Float64. If theflux is not specified, it defaults to QN().\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Convert-to-Array-1","page":"ITensor","title":"Convert to Array","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"Array{ElT, N}(::ITensor{N}, ::Vararg{Index, N}) where {ElT, N}\narray(::ITensor)\nmatrix(::ITensor{2})\nvector(::ITensor{1})","category":"page"},{"location":"ITensorType.html#Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor{N},Vararg{Index,N}}} where N where ElT","page":"ITensor","title":"Core.Array","text":"Array{ElT}(T::ITensor, i:Index...)\nArray(T::ITensor, i:Index...)\n\nMatrix{ElT}(T::ITensor, row_i:Index, col_i::Index)\nMatrix(T::ITensor, row_i:Index, col_i::Index)\n\nVector{ElT}(T::ITensor)\nVector(T::ITensor)\n\nGiven an ITensor T with indices i..., returns an Array with a copy of the ITensor's elements. The order in which the indices are provided indicates the order of the data in the resulting Array.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.array-Tuple{ITensor}","page":"ITensor","title":"NDTensors.array","text":"array(T::ITensor)\n\nGiven an ITensor T, returns an Array with a copy of the ITensor's elements, or a view in the case the the ITensor's storage is Dense. The ordering of the elements in the Array, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. Therefore this method is intended for developer use only and not recommended for use in ITensor applications.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.matrix-Tuple{ITensor{2}}","page":"ITensor","title":"NDTensors.matrix","text":"matrix(T::ITensor)\n\nGiven an ITensor T with two indices, returns a Matrix with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense. The ordering of the elements in the Matrix, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. Therefore this method is intended for developer use only and not recommended for use in ITensor applications.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.vector-Tuple{ITensor{1}}","page":"ITensor","title":"NDTensors.vector","text":"vector(T::ITensor)\n\nGiven an ITensor T with one index, returns a Vector with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Getting-and-setting-elements-1","page":"ITensor","title":"Getting and setting elements","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"getindex(::ITensor, ::Any...)\ngetindex(::ITensor{N}, ::Vararg{Int,N}) where {N}\nsetindex!(::ITensor, ::Number, ::Any...)\nsetindex!(::ITensor, ::Number, ::Int...)","category":"page"},{"location":"ITensorType.html#Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"Base.getindex","text":"getindex(T::ITensor, ivs...)\n\nGet the specified element of the ITensor, using a list of IndexVals or Pair{<:Index, Int}.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(2.0, i, i')\nA[i => 1, i' => 2] # 2.0, same as: A[i' => 2, i => 1]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N","page":"ITensor","title":"Base.getindex","text":"getindex(T::ITensor, I::Int...)\n\nGet the specified element of the ITensor, using internal Index ordering of the ITensor.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(2.0, i, i')\nA[1, 2] # 2.0, same as: A[i => 1, i' => 2]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}","page":"ITensor","title":"Base.setindex!","text":"setindex!(T::ITensor, x::Number, ivs...)\n\nSet the specified element of the ITensor using a list of IndexVals or Pair{<:Index, Int}.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(i, i')\nA[i => 1, i' => 2] = 1.0 # same as: A[i' => 2, i => 1] = 1.0\nA[i => 2, i' => :] = [2.0 3.0]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}","page":"ITensor","title":"Base.setindex!","text":"setindex!(T::ITensor, x::Number, I::Int...)\n\nsetindex!(T::ITensor, x::Number, I::CartesianIndex)\n\nSet the specified element of the ITensor, using internal Index ordering of the ITensor.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(i, i')\nA[1, 2] = 1.0 # same as: A[i => 1, i' => 2] = 1.0\nA[2, :] = [2.0 3.0]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Properties-1","page":"ITensor","title":"Properties","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"inds(::ITensor)\nind(::ITensor, ::Int)","category":"page"},{"location":"ITensorType.html#NDTensors.inds-Tuple{ITensor}","page":"ITensor","title":"NDTensors.inds","text":"inds(T::ITensor)\n\nReturn the indices of the ITensor as an IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.ind-Tuple{ITensor,Int64}","page":"ITensor","title":"NDTensors.ind","text":"ind(T::ITensor, i::Int)\n\nGet the Index of the ITensor along dimension i.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Priming_and_tagging_ITensor-1","page":"ITensor","title":"Priming and tagging","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"prime(::ITensor, ::Any...)\nsetprime(::ITensor, ::Any...)\nnoprime(::ITensor, ::Any...)\nmapprime(::ITensor, ::Any...)\nswapprime(::ITensor, ::Any...)\naddtags(::ITensor, ::Any...)\nremovetags(::ITensor, ::Any...)\nreplacetags(::ITensor, ::Any...)\nsettags(::ITensor, ::Any...)\nswaptags(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.prime","text":"prime[!](A::ITensor, plinc::Int = 1; <keyword arguments>) -> ITensor\n\nprime(is::IndexSet, plinc::Int = 1; <keyword arguments>) -> IndexSet\n\nIncrease the prime level of the indices of an ITensor or IndexSet.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.setprime","text":"setprime[!](A::ITensor, plev::Int; <keyword arguments>) -> ITensor\n\nsetprime(is::IndexSet, plev::Int; <keyword arguments>) -> IndexSet\n\nSet the prime level of the indices of an ITensor or IndexSet.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.noprime","text":"noprime[!](A::ITensor; <keyword arguments>) -> ITensor\n\nnoprime(is::IndexSet; <keyword arguments>) -> IndexSet\n\nSet the prime level of the indices of an ITensor or IndexSet to zero.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.mapprime","text":"replaceprime[!](A::ITensor, plold::Int, plnew::Int; <keyword arguments>) -> ITensor\nreplaceprime[!](A::ITensor, plold => plnew; <keyword arguments>) -> ITensor\nmapprime[!](A::ITensor, <arguments>; <keyword arguments>) -> ITensor\n\nreplaceprime(is::IndexSet, plold::Int, plnew::Int; <keyword arguments>) -> IndexSet\nreplaceprime(is::IndexSet, plold => plnew; <keyword arguments>) -> IndexSet\nmapprime(is::IndexSet, <arguments>; <keyword arguments>) -> IndexSet\n\nSet the prime level of the indices of an ITensor or IndexSet with prime level plold to plnew.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapprime","text":"swapprime[!](A::ITensor, pl1::Int, pl2::Int; <keyword arguments>) -> ITensor\nswapprime[!](A::ITensor, pl1 => pl2; <keyword arguments>) -> ITensor\n\nswapprime(is::ITensor, pl1::Int, pl2::Int; <keyword arguments>) -> IndexSet\nswapprime(is::ITensor, pl1 => pl2; <keyword arguments>) -> IndexSet\n\nSet the prime level of the indices of an ITensor or IndexSetwith prime level pl1 to pl2, and those with prime level pl2 to pl1.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.addtags","text":"addtags[!](A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\naddtags(is::IndexSet, ts::String; <keyword arguments>) -> IndexSet\n\nAdd the tags ts to the indices of an ITensor or IndexSet.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.removetags","text":"removetags[!](A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nremovetags(is::IndexSet, ts::String; <keyword arguments>) -> IndexSet\n\nRemove the tags ts from the indices of an ITensor or IndexSet.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replacetags","text":"replacetags[!](A::ITensor, tsold::String, tsnew::String; <keyword arguments>) -> ITensor\n\nreplacetags(is::IndexSet, tsold::String, tsnew::String; <keyword arguments>) -> IndexSet\n\nReplace the tags tsold with tsnew for the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.settags","text":"settags[!](A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nsettags(is::IndexSet, ts::String; <keyword arguments>) -> IndexSet\n\nSet the tags of the indices of an ITensor or IndexSet to ts.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swaptags","text":"swaptags[!](A::ITensor, ts1::String, ts2::String; <keyword arguments>) -> ITensor\n\nswaptags(is::IndexSet, ts1::String, ts2::String; <keyword arguments>) -> IndexSet\n\nSwap the tags ts1 with ts2 for the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nThe ITensor functions come in two versions, f and f!. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#IndexSet-set-operations-1","page":"ITensor","title":"IndexSet set operations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"commoninds\ncommonind\nuniqueinds\nuniqueind\nnoncommoninds\nnoncommonind\nunioninds\nunionind\nhascommoninds","category":"page"},{"location":"ITensorType.html#ITensors.commoninds","page":"ITensor","title":"ITensors.commoninds","text":"commoninds(A, B; kwargs...)\ncommoninds(::Order{N}, A, B; kwargs...)\n\nReturn an IndexSet with indices that are common between the indices of A and B (the set intersection, similar to Base.intersect).\n\nOptionally, specify the desired number of indices as Order(N), which adds a check and can be a bit more efficient.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.commonind","page":"ITensor","title":"ITensors.commonind","text":"commonind(A, B; kwargs...)\n\nReturn the first Index common between the indices of A and B.\n\nSee also commoninds.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.uniqueinds","page":"ITensor","title":"ITensors.uniqueinds","text":"uniqueinds(A, B; kwargs...)\nuniqueinds(::Order{N}, A, B; kwargs...)\n\nReturn an IndexSet with indices that are unique to the set of indices of A and not in B (the set difference, similar to Base.setdiff).\n\nOptionally, specify the desired number of indices as Order(N), which adds a check and can be a bit more efficient.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.uniqueind","page":"ITensor","title":"ITensors.uniqueind","text":"uniqueind(A, B; kwargs...)\n\nReturn the first Index unique to the set of indices of A and not in B.\n\nSee also uniqueinds.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.noncommoninds","page":"ITensor","title":"ITensors.noncommoninds","text":"noncommoninds(A, B; kwargs...)\nnoncommoninds(::Order{N}, A, B; kwargs...)\n\nReturn an IndexSet with indices that are not common between the indices of A and B (the symmetric set difference, similar to Base.symdiff).\n\nOptionally, specify the desired number of indices as Order(N), which adds a check and can be a bit more efficient.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.noncommonind","page":"ITensor","title":"ITensors.noncommonind","text":"noncommonind(A, B; kwargs...)\n\nReturn the first Index not common between the indices of A and B.\n\nSee also noncommoninds.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.unioninds","page":"ITensor","title":"ITensors.unioninds","text":"unioninds(A, B; kwargs...)\nunioninds(::Order{N}, A, B; kwargs...)\n\nReturn an IndexSet with indices that are the union of the indices of A and B (the set union, similar to Base.union).\n\nOptionally, specify the desired number of indices as Order(N), which adds a check and can be a bit more efficient.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.unionind","page":"ITensor","title":"ITensors.unionind","text":"unionind(A, B; kwargs...)\n\nReturn the first Index in the union of the indices of A and B.\n\nSee also unioninds.\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#ITensors.hascommoninds","page":"ITensor","title":"ITensors.hascommoninds","text":"hascommoninds(A, B; kwargs...)\n\nhascommoninds(B; kwargs...) -> f::Function\n\nCheck if the ITensors or sets of indices A and B have common indices.\n\nIf only one ITensor or set of indices B is passed, return a function f such that f(A) = hascommoninds(A, B; kwargs...)\n\n\n\n\n\n","category":"function"},{"location":"ITensorType.html#Index-Manipulations-1","page":"ITensor","title":"Index Manipulations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"replaceind(::ITensor, ::Any...)\nreplaceinds(::ITensor, ::Any...)\nswapind(::ITensor, ::Any...)\nswapinds(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replaceind","text":"replaceind[!](A::ITensor, i1::Index, i2::Index) -> ITensor\n\nReplace the Index i1 with the Index i2 in the ITensor.\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replaceinds","text":"replaceinds(A::ITensor, inds1, inds2) -> ITensor\n\nreplaceinds!(A::ITensor, inds1, inds2)\n\nReplace the Index inds1[n] with the Index inds2[n] in the ITensor, where n runs from 1 to length(inds1) == length(inds2).\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\nThe storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapind-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapind","text":"swapind(A::ITensor, i1::Index, i2::Index) -> ITensor\n\nswapind!(A::ITensor, i1::Index, i2::Index)\n\nSwap the Index i1 with the Index i2 in the ITensor.\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapinds-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapinds","text":"swapinds(A::ITensor, inds1, inds2) -> ITensor\n\nswapinds!(A::ITensor, inds1, inds2)\n\nSwap the Index inds1[n] with the Index inds2[n] in the ITensor, where n runs from 1 to length(inds1) == length(inds2).\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\nThe storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Math-operations-1","page":"ITensor","title":"Math operations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"*(::ITensor, ::ITensor)\nexp(::ITensor, ::Any, ::Any)","category":"page"},{"location":"ITensorType.html#Base.:*-Tuple{ITensor,ITensor}","page":"ITensor","title":"Base.:*","text":"A::ITensor * B::ITensor\n\nContract ITensors A and B to obtain a new ITensor. This  contraction * operator finds all matching indices common to A and B and sums over them, such that the result will  have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be  modified such that they no longer compare equal - for more information see the documentation on Index objects.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.exp-Tuple{ITensor,Any,Any}","page":"ITensor","title":"Base.exp","text":"exp(A::ITensor, Linds=Rinds', Rinds=inds(A,plev=0); ishermitian = false)\n\nCompute the exponential of the tensor A by treating it as a matrix A_lr with the left index l running over all indices in Linds and r running over all indices in Rinds.\n\nOnly accepts index lists Linds,Rinds such that: (1) length(Linds) + length(Rinds) == length(inds(A)) (2) length(Linds) == length(Rinds) (3) For each pair of indices (Linds[n],Rinds[n]), Linds[n] and Rinds[n] represent the same Hilbert space (the same QN structure in the QN case, or just the same length in the dense case), and appear in A with opposite directions.\n\nWhen ishermitian=true the exponential of Hermitian(A_{lr}) is computed internally.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Decompositions-1","page":"ITensor","title":"Decompositions","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"svd(::ITensor, ::Any...)\nfactorize(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"LinearAlgebra.svd","text":"svd(A::ITensor, inds::Index...; <keyword arguments>)\n\nSingular value decomposition (SVD) of an ITensor A, computed by treating the \"left indices\" provided collectively as a row index, and the remaining \"right indices\" as a column index (matricization of a tensor).\n\nThe first three return arguments are U, S, and V, such that A ≈ U * S * V.\n\nWhether or not the SVD performs a trunction depends on the keyword arguments provided. \n\nArguments\n\nmaxdim::Int: the maximum number of singular values to keep.\nmindim::Int: the minimum number of singular values to keep.\ncutoff::Float64: set the desired truncation error of the SVD, by default defined as the sum of the squares of the smallest singular values.\nlefttags::String = \"Link,u\": set the tags of the Index shared by U and S.\nrighttags::String = \"Link,v\": set the tags of the Index shared by S and V.\nalg::String = \"divide_and_conquer\". Options:\n\"divide_and_conquer\" - A divide-and-conquer algorithm. LAPACK's gesdd. Fast, but may lead to some innacurate singular values for very ill-conditioned matrices. Also may sometimes fail to converge, leading to errors (in which case \"qr_iteration\" or \"recursive\" can be tried).\n\"qr_iteration\" - Typically slower but more accurate for very ill-conditioned matrices compared to \"divide_and_conquer\". LAPACK's gesvd.\n\"recursive\" - ITensor's custom svd. Very reliable, but may be slow if high precision is needed. To get an svd of a matrix A, an eigendecomposition of A^dagger A is used to compute U and then a qr of A^dagger U is used to compute V. This is performed recursively to compute small singular values.\nuse_absolute_cutoff::Bool = false: set if all probability weights below the cutoff value should be discarded, rather than the sum of discarded weights.\nuse_relative_cutoff::Bool = true: set if the singular values should be normalized for the sake of truncation.\n\nSee also: factorize\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"LinearAlgebra.factorize","text":"factorize(A::ITensor, Linds::Index...; <keyword arguments>)\n\nPerform a factorization of A into ITensors L and R such that A ≈ L * R.\n\nArguments\n\northo::String = \"left\": Choose orthogonality properties of the factorization.\n\"left\": the left factor L is an orthogonal basis such that L * dag(prime(L, commonind(L,R))) ≈ I. \n\"right\": the right factor R forms an orthogonal basis. \n\"none\", neither of the factors form an orthogonal basis, and in general are made as symmetrically as possible (depending on the decomposition used).\nwhich_decomp::Union{String, Nothing} = nothing: choose what kind of decomposition is used. \nnothing: choose the decomposition automatically based on the other arguments. For example, when nothing is chosen and ortho = \"left\" or \"right\", and a cutoff is provided, svd or eigen is used depending on the provided cutoff (eigen is only used when the cutoff is greater than 1e-12, since it has a lower precision). When no truncation is requested qr is used for dense ITensors and svd for block-sparse ITensors (in the future qr will be used also for block-sparse ITensors in this case).\n\"svd\": L = U and R = S * V for ortho = \"left\", L = U * S and R = V for ortho = \"right\", and L = U * sqrt.(S) and R = sqrt.(S) * V for ortho = \"none\". To control which svd algorithm is choose, use the svd_alg keyword argument. See the documentation for svd for the supported algorithms, which are the same as those accepted by the alg keyword argument.\n\"eigen\": L = U and R = U^dagger A where U is determined from the eigendecompositon A A^dagger = U D U^dagger for ortho = \"left\" (and vice versa for ortho = \"right\"). \"eigen\" is not supported for ortho = \"none\".\n\"qr\": L=Q and R an upper-triangular matrix when ortho = \"left\", and R = Q and L a lower-triangular matrix when ortho = \"right\" (currently supported for dense ITensors only).\n\nIn the future, other decompositions like QR (for block-sparse ITensors), polar, cholesky, LU, etc. are expected to be supported.\n\nFor truncation arguments, see: svd\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Operations-1","page":"ITensor","title":"Operations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"permute(::ITensor, ::Any)","category":"page"},{"location":"ITensorType.html#ITensors.permute-Tuple{ITensor,Any}","page":"ITensor","title":"ITensors.permute","text":"permute(T::ITensors, inds; always_copy::Bool = false)\npermute(T::ITensors, inds::Index...; always_copy::Bool = false)\n\nReturn a new ITensor T with indices permuted according to the input indices inds. The storage of the ITensor is permuted accordingly.\n\nIf always_copy = false, it avoids copying data if possible. Therefore, it may return a view. Use always_copy = true if you never want it to return an ITensor with a view of the original ITensor.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#IndexSet-1","page":"IndexSet","title":"IndexSet","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"IndexSet(::Vector{<:Index})","category":"page"},{"location":"IndexSetType.html#ITensors.IndexSet-Tuple{Array{#s76,1} where #s76<:Index}","page":"IndexSet","title":"ITensors.IndexSet","text":"IndexSet{N, IndexT}(inds)\nIndexSet{N, IndexT}(inds::Index...)\n\nConstruct an IndexSet of order N and element type IndexT from a collection of indices (any collection that is convertable to a Tuple).\n\n\n\n\n\nIndexSet{N}(inds)\nIndexSet{N}(inds::Index...)\n\nConstruct an IndexSet of order N from a collection of indices (any collection that is convertable to a Tuple).\n\n\n\n\n\nIndexSet(inds)\nIndexSet(inds::Index...)\n\nConstruct an IndexSet from a collection of indices (any collection that is convertable to a Tuple).\n\n\n\n\n\nIndexSet(inds::Vector{<:Index})\n\nConvert a Vector of indices to an IndexSet.\n\nWarning: this is not type stable, since a Vector is dynamically sized and an IndexSet is statically sized. Consider using the constructor IndexSet{N}(inds::Vector).\n\n\n\n\n\nIndexSet{N}(inds::Vector{<:Index})\n\nConvert a Vector of indices to an IndexSet of size N.\n\nType stable conversion of a Vector of indices to an IndexSet (in contrast to IndexSet(::Vector{<:Index})).\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Priming_and_tagging_IndexSet-1","page":"IndexSet","title":"Priming and tagging","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"Documentation for IndexSet priming and tagging methods can be found in the ITensor Priming and tagging section.","category":"page"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"map(::Function, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#Base.map-Tuple{Function,IndexSet}","page":"IndexSet","title":"Base.map","text":"map(f, is::IndexSet)\n\nApply the function to the elements of the IndexSet, returning a new IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Set-operations-1","page":"IndexSet","title":"Set operations","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"Documentation for IndexSet set operations can be found in the ITensor IndexSet set operations section.","category":"page"},{"location":"IndexSetType.html#Subsets-1","page":"IndexSet","title":"Subsets","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"getfirst(::Function, ::IndexSet)\ngetfirst(::IndexSet)\nfilter(::Function, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#ITensors.getfirst-Tuple{Function,IndexSet}","page":"IndexSet","title":"ITensors.getfirst","text":"getfirst(f::Function, is::IndexSet)\n\nGet the first Index matching the pattern function, return nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#ITensors.getfirst-Tuple{IndexSet}","page":"IndexSet","title":"ITensors.getfirst","text":"getfirst(is::IndexSet)\n\nReturn the first Index in the IndexSet. If the IndexSet is empty, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Base.filter-Tuple{Function,IndexSet}","page":"IndexSet","title":"Base.filter","text":"filter(f::Function, inds::IndexSet)\n\nfilter(f::Function, ::Order{N}, inds::IndexSet)\n\nFilter the IndexSet by the given function (output a new IndexSet with indices i for which f(i) returns true).\n\nNote that this function is not type stable, since the number of output indices is not known at compile time.\n\nTo make it type stable, specify the desired order by passing an instance of the type Order.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#IndexVal-1","page":"IndexVal","title":"IndexVal","text":"","category":"section"},{"location":"IndexValType.html#Description-1","page":"IndexVal","title":"Description","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"IndexVal","category":"page"},{"location":"IndexValType.html#ITensors.IndexVal","page":"IndexVal","title":"ITensors.IndexVal","text":"An IndexVal represents an Index object set to a certain value.\n\n\n\n\n\n","category":"type"},{"location":"IndexValType.html#Constructors-1","page":"IndexVal","title":"Constructors","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"IndexVal(::Pair{<:Index, Int})","category":"page"},{"location":"IndexValType.html#ITensors.IndexVal-Tuple{Pair{#s76,Int64} where #s76<:Index}","page":"IndexVal","title":"ITensors.IndexVal","text":"IndexVal(i::Index, n::Int)\n\nIndexVal(iv::Pair{<:Index, Int})\n\n(i::Index)(n::Int)\n\nCreate an IndexVal from a pair of Index and Int.\n\nAlternatively, you can use the syntax i(n).\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#Properties-1","page":"IndexVal","title":"Properties","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"ind(::IndexVal)\nval(::IndexVal)\nisindequal(::Index, ::IndexVal)","category":"page"},{"location":"IndexValType.html#NDTensors.ind-Tuple{IndexVal}","page":"IndexVal","title":"NDTensors.ind","text":"ind(iv::IndexVal)\n\nReturn the Index of the IndexVal.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#ITensors.val-Tuple{IndexVal}","page":"IndexVal","title":"ITensors.val","text":"val(iv::IndexVal)\n\nReturn the value of the IndexVal.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#ITensors.isindequal-Tuple{Index,IndexVal}","page":"IndexVal","title":"ITensors.isindequal","text":"isindequal(i::Index, iv::IndexVal)\n\nisindequal(i::IndexVal, iv::Index)\n\nisindequal(i::IndexVal, iv::IndexVal)\n\nCheck if the Index and IndexVal have the same indices.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Documentation\n(Image: ) (Image: )","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Build Status\n(Image: Tests) (Image: codecov)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Citation\n(Image: arXiv)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"ITensors is a library for rapidly creating correct and efficient tensor network algorithms. ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"An ITensor is a tensor whose interface  is independent of its memory layout. ITensor indices are objects which carry extra information and which 'recognize' each other (compare equal to each other).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The ITensor library also includes composable and extensible  algorithms for optimizing and transforming tensor networks, such as  matrix product state and matrix product operators, such as the DMRG algorithm.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Development of ITensor is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"page"},{"location":"index.html#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The ITensors package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"~ julia","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"julia> ]\n\npkg> add ITensors","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"julia> import Pkg; Pkg.add(\"ITensors\")","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Please note that right now, ITensors.jl requires that you use Julia v1.3 or later (since ITensors.jl relies on a feature that was introduced in Julia v1.3).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We recommend using ITensors.jl with Intel MKL in order to get the best possible performance. If you have not done so already, you can replace your current BLAS and LAPACK implementation with MKL by using the MKL.jl package. Please follow the instructions here.","category":"page"},{"location":"index.html#Documentation-1","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"STABLE –  documentation of the most recently tagged version.\nDEVEL – documentation of the in-development version.","category":"page"},{"location":"index.html#Citation-1","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"If you use ITensors.jl in your work, for now please cite the arXiv preprint:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"@misc{itensor,\n    title={The \\mbox{ITensor} Software Library for Tensor Network Calculations},\n    author={Matthew Fishman and Steven R. White and E. Miles Stoudenmire},\n    year={2020},\n    eprint={2007.14822},\n    archivePrefix={arXiv}\n}","category":"page"},{"location":"index.html#Code-Examples-1","page":"Introduction","title":"Code Examples","text":"","category":"section"},{"location":"index.html#Basic-Overview-1","page":"Introduction","title":"Basic Overview","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"ITensor construction, setting of elements, contraction, and addition. Before constructing an ITensor, one constructs Index objects representing tensor indices.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(3)\n  j = Index(5)\n  k = Index(2)\n  l = Index(7)\n\n  A = ITensor(i,j,k)\n  B = ITensor(j,l)\n\n  # Set elements of A\n  A[i=>1,j=>1,k=>1] = 11.1\n  A[i=>2,j=>1,k=>2] = -21.2\n  A[k=>1,i=>3,j=>1] = 31.1  # can provide Index values in any order\n  # ...\n\n  # A[k(1),i(3),j(1)] = 31.1  # alternative notation\n\n  # Contract over shared index j\n  C = A * B\n\n  @show hasinds(C,i,k,l) # = true\n\n  D = randomITensor(k,j,i) # ITensor with random elements\n\n  # Add two ITensors\n  # must have same set of indices\n  # but can be in any order\n  R = A + D\n\n  nothing\nend","category":"page"},{"location":"index.html#Singular-Value-Decomposition-(SVD)-of-a-Matrix-1","page":"Introduction","title":"Singular Value Decomposition (SVD) of a Matrix","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this example, we create a random 10x20 matrix  and compute its SVD. The resulting factors can  be simply multiplied back together using the ITensor * operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(10)           # index of dimension 10\n  j = Index(20)           # index of dimension 20\n  M = randomITensor(i,j)  # random matrix, indices i,j\n  U,S,V = svd(M,i)        # compute SVD with i as row index\n  @show M ≈ U*S*V         # = true\n\n  nothing\nend","category":"page"},{"location":"index.html#Singular-Value-Decomposition-(SVD)-of-a-Tensor-1","page":"Introduction","title":"Singular Value Decomposition (SVD) of a Tensor","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this example, we create a random 4x4x4x4 tensor  and compute its SVD, temporarily treating the first and third indices (i and k) as the \"row\" index and the second and fourth indices (j and l) as the \"column\" index for the purposes of the SVD. The resulting factors can  be simply multiplied back together using the ITensor * operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(4,\"i\")\n  j = Index(4,\"j\")\n  k = Index(4,\"k\")\n  l = Index(4,\"l\")\n  T = randomITensor(i,j,k,l)\n  U,S,V = svd(T,i,k)   # compute SVD with (i,k) as row indices (indices of U)\n  @show hasinds(U,i,k) # = true\n  @show hasinds(V,j,l) # = true\n  @show T ≈ U*S*V      # = true\n\n  nothing\nend","category":"page"},{"location":"index.html#Tensor-Indices:-Tags-and-Prime-Levels-1","page":"Introduction","title":"Tensor Indices: Tags and Prime Levels","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Before making an ITensor, you have to define its indices. Tensor Index objects carry extra information beyond just their dimension.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"All Index objects carry a permanent, immutable id number which is  determined when it is constructed, and allow it to be matched (compare equal) with copies of itself.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Additionally, an Index can have up to four tag strings, and an integer primelevel. If two Index objects have different tags or  different prime levels, they do not compare equal even if they have the same id.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Tags are also useful for identifying Index objects when printing tensors, and for performing certain Index manipulations (e.g. priming indices having certain sets of tags).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(3)     # Index of dimension 3\n  @show dim(i)     # = 3\n  @show id(i)      # = 0x5d28aa559dd13001 or similar\n\n  ci = copy(i)\n  @show ci == i    # = true\n\n  j = Index(5,\"j\") # Index with a tag \"j\"\n\n  @show j == i     # = false\n\n  s = Index(2,\"n=1,Site\") # Index with two tags,\n                          # \"Site\" and \"n=1\"\n  @show hastags(s,\"Site\") # = true\n  @show hastags(s,\"n=1\")  # = true\n\n  i1 = prime(i) # i1 has a \"prime level\" of 1\n                # but otherwise same properties as i\n  @show i1 == i # = false, prime levels do not match\n\n  nothing\nend","category":"page"},{"location":"index.html#DMRG-Calculation-1","page":"Introduction","title":"DMRG Calculation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"DMRG is an iterative algorithm for finding the dominant eigenvector of an exponentially large, Hermitian matrix. It originates in physics with the purpose of finding eigenvectors of Hamiltonian (energy) matrices which model the behavior of quantum systems.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  # Create 100 spin-one indices\n  N = 100\n  sites = siteinds(\"S=1\",N)\n\n  # Input operator terms which define \n  # a Hamiltonian matrix, and convert\n  # these terms to an MPO tensor network\n  # (here we make the 1D Heisenberg model)\n  ampo = AutoMPO()\n  for j=1:N-1\n    ampo += \"Sz\",j,\"Sz\",j+1\n    ampo += 0.5,\"S+\",j,\"S-\",j+1\n    ampo += 0.5,\"S-\",j,\"S+\",j+1\n  end\n  H = MPO(ampo,sites)\n\n  # Create an initial random matrix product state\n  psi0 = randomMPS(sites)\n\n  # Plan to do 5 passes or 'sweeps' of DMRG,\n  # setting maximum MPS internal dimensions \n  # for each sweep and maximum truncation cutoff\n  # used when adapting internal dimensions:\n  sweeps = Sweeps(5)\n  maxdim!(sweeps, 10,20,100,100,200)\n  cutoff!(sweeps, 1E-10)\n  @show sweeps\n\n  # Run the DMRG algorithm, returning energy \n  # (dominant eigenvalue) and optimized MPS\n  energy, psi = dmrg(H,psi0, sweeps)\n  println(\"Final energy = $energy\")\n\n  nothing\nend","category":"page"},{"location":"index.html#More-examples-1","page":"Introduction","title":"More examples","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The ITensors.jl package contains a directory of examples, which we will continue to add to. You can run them as follows:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"julia> using ITensors\n\njulia> cd(ITensors.examples_dir())\n\njulia> readdir()\n7-element Array{String,1}:\n \"basic_ops\"\n \"ctmrg\"\n \"dmrg\"\n \"gate_evolution\"\n \"krylov_methods\"\n \"src\"\n \"trg\"\n\njulia> cd(\"dmrg\")\n\njulia> readdir()\n8-element Array{String,1}:\n \"1d_heisenberg.jl\"\n \"1d_heisenberg_conserve_spin.jl\"\n \"1d_hubbard_extendend.jl\"\n \"1d_ising_with_observer.jl\"\n \"2d_heisenberg_conserve_spin.jl\"\n \"2d_hubbard_conserve_momentum.jl\"\n \"2d_hubbard_conserve_particles.jl\"\n \"input_files\"\n\njulia> include(\"1d_heisenberg.jl\")\nsweeps = Sweeps\n1 cutoff=1.0E-11, maxdim=10, mindim=1, noise=0.0E+00\n2 cutoff=1.0E-11, maxdim=20, mindim=1, noise=0.0E+00\n3 cutoff=1.0E-11, maxdim=100, mindim=1, noise=0.0E+00\n4 cutoff=1.0E-11, maxdim=100, mindim=1, noise=0.0E+00\n5 cutoff=1.0E-11, maxdim=200, mindim=1, noise=0.0E+00\n\nAfter sweep 1 energy=-138.837988775764 maxlinkdim=10 time=13.760\nAfter sweep 2 energy=-138.937408365962 maxlinkdim=20 time=0.249\nAfter sweep 3 energy=-138.940084788852 maxlinkdim=100 time=1.867\nAfter sweep 4 energy=-138.940086091070 maxlinkdim=100 time=3.824\nAfter sweep 5 energy=-138.940086113999 maxlinkdim=122 time=4.527\nFinal energy = -138.940086113999\n\njulia> pwd()\n\"[path_to_package_installation]/ITensors/examples/dmrg\"","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"You can use your favorite text editor to view these examples. If you would like to modify them, either copy them into your own directory, or checkout ITensors.jl in development mode using the instructions in Developing ITensors.jl.","category":"page"}]
}
