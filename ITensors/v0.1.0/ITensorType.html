<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/ITensorDocs/'</script><script charset="utf-8" src="../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>ITensor · ITensors.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="assets/themeswap.js"></script><link href="https://itensor.github.io/ITensorDocs/ITensors/stable/ITensorType.html" rel="canonical"/><link href="../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><a class="brand" href="https://itensor.org"><img alt="home" src="../../assets/logo.png"/></a><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../Overview/">Home</a><a class="nav-link active nav-item" href="../">ITensors</a><a class="nav-link nav-item" href="../../ITensorMPS/">ITensorMPS</a><div class="search nav-item"><input id="search-input" placeholder="Search everywhere..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img alt="ITensors.jl logo" src="assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">ITensors.jl</span></div><form action="search.html" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="IndexType.html">Index</a></li><li><a class="tocitem" href="IndexValType.html">IndexVal</a></li><li><a class="tocitem" href="IndexSetType.html">IndexSet</a></li><li class="is-active"><a class="tocitem" href="ITensorType.html">ITensor</a><ul class="internal"><li><a class="tocitem" href="#Description-1"><span>Description</span></a></li><li><a class="tocitem" href="#Dense-Constructors-1"><span>Dense Constructors</span></a></li><li><a class="tocitem" href="#QN-BlockSparse-Constructors-1"><span>QN BlockSparse Constructors</span></a></li><li><a class="tocitem" href="#Empty-Constructors-1"><span>Empty Constructors</span></a></li><li><a class="tocitem" href="#QN-Empty-Constructors-1"><span>QN Empty Constructors</span></a></li><li><a class="tocitem" href="#Diagonal-constructors-1"><span>Diagonal constructors</span></a></li><li><a class="tocitem" href="#QN-Diagonal-constructors-1"><span>QN Diagonal constructors</span></a></li><li><a class="tocitem" href="#Getting-and-setting-elements-1"><span>Getting and setting elements</span></a></li><li><a class="tocitem" href="#Properties-1"><span>Properties</span></a></li><li><a class="tocitem" href="#Priming-and-tagging-1"><span>Priming and tagging</span></a></li><li><a class="tocitem" href="#Index-Manipulations-1"><span>Index Manipulations</span></a></li><li><a class="tocitem" href="#Math-operations-1"><span>Math operations</span></a></li><li><a class="tocitem" href="#Decompositions-1"><span>Decompositions</span></a></li><li><a class="tocitem" href="#Operations-1"><span>Operations</span></a></li></ul></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="QN.html">QN</a></li><li><a class="tocitem" href="DMRG.html">DMRG</a></li><li><a class="tocitem" href="AutoMPO.html">AutoMPO</a></li><li><a class="tocitem" href="ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="ProjMPOSum.html">ProjMPOSum</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/master/docs/src/ITensorType.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="ITensor-1"><a class="docs-heading-anchor" href="#ITensor-1">ITensor</a><a class="docs-heading-anchor-permalink" href="#ITensor-1" title="Permalink"></a></h1><h2 id="Description-1"><a class="docs-heading-anchor" href="#Description-1">Description</a><a class="docs-heading-anchor-permalink" href="#Description-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor" id="ITensors.ITensor"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An ITensor is a tensor whose interface is  independent of its memory layout. Therefore it is not necessary to know the ordering of an ITensor's indices, only which indices an ITensor has. Operations like contraction and addition of ITensors automatically handle any memory permutations.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L2-L10" target="_blank">source</a></section></article><h2 id="Dense-Constructors-1"><a class="docs-heading-anchor" href="#Dense-Constructors-1">Dense Constructors</a><a class="docs-heading-anchor-permalink" href="#Dense-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.ITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor([::Type{ElT} = Float64, ]inds)
ITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor filled with zeros having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L150-L157" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor-Tuple{Type{#s125} where #s125&lt;:Number,UndefInitializer,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.ITensor-Tuple{Type{#s125} where #s125&lt;:Number,UndefInitializer,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)
ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...)</code></pre><p>Construct an ITensor filled with undefined elements having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L177-L184" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.randomITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.randomITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.randomITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomITensor([::Type{ElT &lt;: Number} = Float64, ]inds)

randomITensor([::Type{ElT &lt;: Number} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor with type <code>ElT</code> and indices <code>inds</code>, whose elements are normally distributed random numbers. If the element type is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L903-L909" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.setelt-Tuple{IndexVal}" id="ITensors.setelt-Tuple{IndexVal}"><code>ITensors.setelt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setelt(iv)</code></pre><p>Create an ITensor with all zeros except the specified value, which is set to 1.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L391-L396" target="_blank">source</a></section></article><h2 id="QN-BlockSparse-Constructors-1"><a class="docs-heading-anchor" href="#QN-BlockSparse-Constructors-1">QN BlockSparse Constructors</a><a class="docs-heading-anchor-permalink" href="#QN-BlockSparse-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor-Tuple{Type{#s125} where #s125&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.ITensor-Tuple{Type{#s125} where #s125&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds)
ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds::Index...)</code></pre><p>Construct an ITensor with BlockSparse storage filled with <code>zero(ElT)</code> where the nonzero blocks are determined by <code>flux</code>.</p><p>If <code>ElT</code> is not specified it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/qn/qnitensor.jl#L2-L9" target="_blank">source</a></section></article><h2 id="Empty-Constructors-1"><a class="docs-heading-anchor" href="#Empty-Constructors-1">Empty Constructors</a><a class="docs-heading-anchor-permalink" href="#Empty-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.emptyITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.emptyITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.emptyITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">emptyITensor([::Type{ElT} = Float64, ]inds)
emptyITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor with storage type <code>NDTensors.Empty</code>, indices <code>inds</code>, and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L223-L228" target="_blank">source</a></section></article><h2 id="QN-Empty-Constructors-1"><a class="docs-heading-anchor" href="#QN-Empty-Constructors-1">QN Empty Constructors</a><a class="docs-heading-anchor-permalink" href="#QN-Empty-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.emptyITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}, IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}}} where N}" id="ITensors.emptyITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}, IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}}} where N}"><code>ITensors.emptyITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">emptyITensor([::Type{ElT} = Float64, ]inds)
emptyITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor with storage type <code>NDTensors.Empty</code>, indices <code>inds</code>, and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L223-L228" target="_blank">source</a></section><section><div><pre><code class="language-none">emptyITensor([::Type{ElT} = Float64, ]inds)
emptyITensor([::Type{ElT} = Float64, ]inds::QNIndex...)</code></pre><p>Construct an ITensor with <code>NDTensors.BlockSparse</code> storage of element type <code>ElT</code> with the no blocks.</p><p>If <code>ElT</code> is not specified it defaults to <code>Float64</code>.</p><p>In the future, this will use the storage <code>NDTensors.EmptyBlockSparse</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/qn/qnitensor.jl#L42-L51" target="_blank">source</a></section></article><h2 id="Diagonal-constructors-1"><a class="docs-heading-anchor" href="#Diagonal-constructors-1">Diagonal constructors</a><a class="docs-heading-anchor-permalink" href="#Diagonal-constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor([::Type{ElT} = Float64, ]inds)
diagITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Make a sparse ITensor of element type <code>ElT</code> with only elements along the diagonal stored. Defaults to having <code>zero(T)</code> along  the diagonal.</p><p>The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L304-L313" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Array{#s125,1} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Array{#s125,1} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(v::Vector{T}, inds)
diagITensor(v::Vector{T}, inds::Index...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the values stored in <code>v</code> and  the ITensor will have element type <code>float(T)</code>. The storage will have type <code>NDTensors.Diag</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L327-L335" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(x::Number, inds)
diagITensor(x::Number, inds::Index...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the value <code>float(x)</code> and the ITensor will have element type <code>float(eltype(x))</code>. The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L347-L355" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.delta-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.delta-Tuple{Type{#s125} where #s125&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delta([::Type{ElT} = Float64, ]inds)
delta([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Make a uniform diagonal ITensor with all diagonal elements <code>one(ElT)</code>. Only a single diagonal element is stored.</p><p>This function has an alias <code>δ</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L366-L374" target="_blank">source</a></section></article><h2 id="QN-Diagonal-constructors-1"><a class="docs-heading-anchor" href="#QN-Diagonal-constructors-1">QN Diagonal constructors</a><a class="docs-heading-anchor-permalink" href="#QN-Diagonal-constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Type{#s125} where #s125&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Type{#s125} where #s125&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)
diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)</code></pre><p>Make an ITensor with storage type <code>NDTensors.DiagBlockSparse</code> with elements <code>zero(ElT)</code>. The ITensor only has diagonal blocks consistent with the specified <code>flux</code>.</p><p>If the element type is not specified, it defaults to <code>Float64</code>. If theflux is not specified, it defaults to <code>QN()</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/qn/qnitensor.jl#L121-L128" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.delta-Tuple{Type{#s125} where #s125&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.delta-Tuple{Type{#s125} where #s125&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)
delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)</code></pre><p>Make an ITensor with storage type <code>NDTensors.DiagBlockSparse</code> with uniform elements <code>one(ElT)</code>. The ITensor only has diagonal blocks consistent with the specified <code>flux</code>.</p><p>If the element type is not specified, it defaults to <code>Float64</code>. If theflux is not specified, it defaults to <code>QN()</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/qn/qnitensor.jl#L160-L167" target="_blank">source</a></section></article><h2 id="Getting-and-setting-elements-1"><a class="docs-heading-anchor" href="#Getting-and-setting-elements-1">Getting and setting elements</a><a class="docs-heading-anchor-permalink" href="#Getting-and-setting-elements-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}" id="Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(T::ITensor, ivs...)</code></pre><p>Get the specified element of the ITensor, using a list of <code>IndexVal</code>s or <code>Pair{&lt;:Index, Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(2.0, i, i')
A[i =&gt; 1, i' =&gt; 2] # 2.0, same as: A[i' =&gt; 2, i =&gt; 1]</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L541-L553" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N" id="Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(T::ITensor, I::Int...)</code></pre><p>Get the specified element of the ITensor, using internal Index ordering of the ITensor.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(2.0, i, i')
A[1, 2] # 2.0, same as: A[i =&gt; 1, i' =&gt; 2]</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L518-L530" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}" id="Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(T::ITensor, x::Number, ivs...)</code></pre><p>Set the specified element of the ITensor using a list of <code>IndexVal</code>s or <code>Pair{&lt;:Index, Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(i, i')
A[i =&gt; 1, i' =&gt; 2] = 1.0 # same as: A[i' =&gt; 2, i =&gt; 1] = 1.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L585-L597" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}" id="Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(T::ITensor, x::Number, I::Int...)</code></pre><p>Set the specified element of the ITensor, using internal Index ordering of the ITensor.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(i, i')
A[1, 2] = 1.0 # same as: A[i =&gt; 1, i' =&gt; 2] = 1.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L562-L574" target="_blank">source</a></section></article><h2 id="Properties-1"><a class="docs-heading-anchor" href="#Properties-1">Properties</a><a class="docs-heading-anchor-permalink" href="#Properties-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#NDTensors.inds-Tuple{ITensor}" id="NDTensors.inds-Tuple{ITensor}"><code>NDTensors.inds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inds(T::ITensor)</code></pre><p>Return the indices of the ITensor as an IndexSet.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L53-L57" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#NDTensors.ind-Tuple{ITensor,Int64}" id="NDTensors.ind-Tuple{ITensor,Int64}"><code>NDTensors.ind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ind(T::ITensor, i::Int)</code></pre><p>Get the Index of the ITensor along dimension i.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L60-L64" target="_blank">source</a></section></article><h2 id="Priming-and-tagging-1"><a class="docs-heading-anchor" href="#Priming-and-tagging-1">Priming and tagging</a><a class="docs-heading-anchor-permalink" href="#Priming-and-tagging-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prime(A::ITensor, plinc::Int = 1; &lt;keyword arguments&gt;) -&gt; ITensor

prime!(A::ITensor, plinc::Int = 1; &lt;keyword arguments&gt;)</code></pre><p>Increase the prime level of the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L735-L743" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setprime(A::ITensor, plev::Int; &lt;keyword arguments&gt;) -&gt; ITensor

setprime!(A::ITensor, plev::Int; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L745-L753" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">noprime(A::ITensor; &lt;keyword arguments&gt;) -&gt; ITensor

noprime!(A::ITensor; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor to zero.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L755-L763" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.mapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapprime(A::ITensor, plold::Int, plnew::Int; &lt;keyword arguments&gt;) -&gt; ITensor

mapprime!(A::ITensor, plold::Int, plnew::Int; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor with prime level <code>plold</code> to <code>plnew</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L765-L773" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swapprime(A::ITensor, pl1::Int, pl2::Int; &lt;keyword arguments&gt;) -&gt; ITensor

swapprime!(A::ITensor, pl1::Int, pl2::Int; &lt;keyword arguments&gt;)</code></pre><p>Set the prime level of the indices of an ITensor with prime level <code>pl1</code> to <code>pl2</code>, and those with prime level <code>pl2</code> to <code>pl1</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L775-L783" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addtags(A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

addtags!(A::ITensor, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Add the tags <code>ts</code> to the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L785-L793" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">removetags(A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

removetags!(A::ITensor, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Remove the tags <code>ts</code> from the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L795-L803" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replacetags(A::ITensor, tsold::String, tsnew::String; &lt;keyword arguments&gt;) -&gt; ITensor

replacetags!(A::ITensor, tsold::String, tsnew::String; &lt;keyword arguments&gt;)</code></pre><p>Replace the tags <code>tsold</code> with <code>tsnew</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L815-L823" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">settags(A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

settags!(A::ITensor, ts::String; &lt;keyword arguments&gt;)</code></pre><p>Set the tags of the indices of an ITensor to <code>ts</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L805-L813" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swaptags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swaptags(A::ITensor, ts1::String, ts2::String; &lt;keyword arguments&gt;) -&gt; ITensor

swaptags!(A::ITensor, ts1::String, ts2::String; &lt;keyword arguments&gt;)</code></pre><p>Swap the tags <code>ts1</code> with <code>ts2</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>In both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L825-L833" target="_blank">source</a></section></article><h2 id="Index-Manipulations-1"><a class="docs-heading-anchor" href="#Index-Manipulations-1">Index Manipulations</a><a class="docs-heading-anchor-permalink" href="#Index-Manipulations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replaceind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replaceind(A::ITensor, i1::Index, i2::Index) -&gt; ITensor

replaceind!(A::ITensor, i1::Index, i2::Index)</code></pre><p>Replace the Index <code>i1</code> with the Index <code>i2</code> in the ITensor.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L835-L843" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replaceinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replaceinds(A::ITensor, inds1, inds2) -&gt; ITensor

replaceinds!(A::ITensor, inds1, inds2)</code></pre><p>Replace the Index <code>inds1[n]</code> with the Index <code>inds2[n]</code> in the ITensor, where <code>n</code> runs from <code>1</code> to <code>length(inds1) == length(inds2)</code>.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p><p>The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L845-L855" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swapind-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swapind-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swapind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swapind(A::ITensor, i1::Index, i2::Index) -&gt; ITensor

swapind!(A::ITensor, i1::Index, i2::Index)</code></pre><p>Swap the Index <code>i1</code> with the Index <code>i2</code> in the ITensor.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L857-L865" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swapinds-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swapinds-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swapinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swapinds(A::ITensor, inds1, inds2) -&gt; ITensor

swapinds!(A::ITensor, inds1, inds2)</code></pre><p>Swap the Index <code>inds1[n]</code> with the Index <code>inds2[n]</code> in the ITensor, where <code>n</code> runs from <code>1</code> to <code>length(inds1) == length(inds2)</code>.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p><p>The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L867-L877" target="_blank">source</a></section></article><h2 id="Math-operations-1"><a class="docs-heading-anchor" href="#Math-operations-1">Math operations</a><a class="docs-heading-anchor-permalink" href="#Math-operations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Base.:*-Tuple{ITensor,ITensor}" id="Base.:*-Tuple{ITensor,ITensor}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(A::ITensor, B::ITensor)</code></pre><p>Contract ITensors A and B to obtain a new ITensor. This  contraction <code>*</code> operator finds all matching indices common to A and B and sums over them, such that the result will  have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be  modified such that they no longer compare equal - for more information see the documentation on Index objects.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L1022-L1032" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.exp-Tuple{ITensor,Any}" id="Base.exp-Tuple{ITensor,Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(A::ITensor, Lis; hermitian = false)</code></pre><p>Compute the exponential of the tensor <code>A</code> by treating it as a matrix <span>$A_{lr}$</span> with the left index <code>l</code> running over all indices in <code>Lis</code> and <code>r</code> running over all indices not in <code>Lis</code>. Must have <code>dim(Lis) == dim(inds(A))/dim(Lis)</code> for the exponentiation to be defined. When <code>ishermitian=true</code> the exponential of <code>Hermitian(A_{lr})</code> is computed internally.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L1077-L1086" target="_blank">source</a></section></article><h2 id="Decompositions-1"><a class="docs-heading-anchor" href="#Decompositions-1">Decompositions</a><a class="docs-heading-anchor-permalink" href="#Decompositions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}" id="LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}"><code>LinearAlgebra.svd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svd(A::ITensor, inds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Singular value decomposition (SVD) of an ITensor <code>A</code>, computed by treating the "left indices" provided collectively as a row index, and the remaining "right indices" as a column index (matricization of a tensor).</p><p>The first three return arguments are <code>U</code>, <code>S</code>, and <code>V</code>, such that <code>A ≈ U * S * V</code>.</p><p>Whether or not the SVD performs a trunction depends on the keyword arguments provided. </p><p><strong>Arguments</strong></p><ul><li><code>maxdim::Int</code>: the maximum number of singular values to keep.</li><li><code>mindim::Int</code>: the minimum number of singular values to keep.</li><li><code>cutoff::Float64</code>: set the desired truncation error of the SVD, by default defined as the sum of the squares of the smallest singular values.</li><li><code>lefttags::String = "Link,u"</code>: set the tags of the Index shared by <code>U</code> and <code>S</code>.</li><li><code>righttags::String = "Link,v"</code>: set the tags of the Index shared by <code>S</code> and <code>V</code>.</li><li><code>alg::String = "recursive"</code>. Options:<ul><li><code>"recursive"</code> - ITensor's custom svd. Very reliable, but may be slow if high precision is needed. To get an <code>svd</code> of a matrix <code>A</code>, an eigendecomposition of <span>$A^{\dagger} A$</span> is used to compute <code>U</code> and then a <code>qr</code> of <span>$A^{\dagger} U$</span> is used to compute <code>V</code>. This is performed recursively to compute small singular values.</li><li><code>"divide_and_conquer"</code> - A divide-and-conquer algorithm. LAPACK's gesdd.</li><li><code>"qr_iteration"</code> - Typically slower but more accurate than <code>"divide_and_conquer"</code>. LAPACK's gesvd.</li></ul></li><li><code>use_absolute_cutoff::Bool = false</code>: set if all probability weights below the <code>cutoff</code> value should be discarded, rather than the sum of discarded weights.</li><li><code>use_relative_cutoff::Bool = true</code>: set if the singular values should be normalized for the sake of truncation.</li></ul><p>See also: <a href="ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}"><code>factorize</code></a></p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/decomp.jl#L26-L54" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}" id="LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}"><code>LinearAlgebra.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factorize(A::ITensor, Linds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Perform a factorization of <code>A</code> into ITensors <code>L</code> and <code>R</code> such that <code>A ≈ L * R</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ortho::String = "left"</code>: Choose orthogonality properties of the factorization.<ul><li><code>"left"</code>: the left factor <code>L</code> is an orthogonal basis such that <code>L * dag(prime(L, commonind(L,R))) ≈ I</code>. </li><li><code>"right"</code>: the right factor <code>R</code> forms an orthogonal basis. </li><li><code>"none"</code>, neither of the factors form an orthogonal basis, and in general are made as symmetrically as possible (depending on the decomposition used).</li></ul></li><li><code>which_decomp::Union{String, Nothing} = nothing</code>: choose what kind of decomposition is used. <ul><li><code>nothing</code>: choose the decomposition automatically based on the other arguments. For example, when <code>"automatic"</code> is chosen and <code>ortho = "left"</code> or <code>"right"</code>, <code>svd</code> or <code>eigen</code> is used depending on the provided cutoff (<code>eigen</code> is only used when the cutoff is greater than <code>1e-12</code>, since it has a lower precision).</li><li><code>"svd"</code>: <code>L = U</code> and <code>R = S * V</code> for <code>ortho = "left"</code>, <code>L = U * S</code> and <code>R = V</code> for <code>ortho = "right"</code>, and <code>L = U * sqrt.(S)</code> and <code>R = sqrt.(S) * V</code> for <code>ortho = "none"</code>. To control which <code>svd</code> algorithm is choose, use the <code>svd_alg</code> keyword argument. See the documentation for <code>svd</code> for the supported algorithms, which are the same as those accepted by the <code>alg</code> keyword argument.</li><li><code>"eigen"</code>: <code>L = U</code> and <span>$R = U^{\dagger} A$</span> where <code>U</code> is determined from the eigendecompositon <span>$A A^{\dagger} = U D U^{\dagger}$</span> for <code>ortho = "left"</code> (and vice versa for <code>ortho = "right"</code>). <code>"eigen"</code> is not supported for <code>ortho = "none"</code>.</li></ul></li></ul><p>In the future, other decompositions like QR, polar, cholesky, LU, etc. are expected to be supported.</p><p>For truncation arguments, see: <a href="ITensorType.html#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}"><code>svd</code></a></p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/decomp.jl#L323-L341" target="_blank">source</a></section></article><h2 id="Operations-1"><a class="docs-heading-anchor" href="#Operations-1">Operations</a><a class="docs-heading-anchor-permalink" href="#Operations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.permute-Tuple{ITensor,Any}" id="ITensors.permute-Tuple{ITensor,Any}"><code>ITensors.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute(T::ITensors, inds; always_copy::Bool = false)
permute(T::ITensors, inds::Index...; always_copy::Bool = false)</code></pre><p>Return a new ITensor T with indices permuted according to the input indices inds. The storage of the ITensor is permuted accordingly.</p><p>If <code>always_copy = false</code>, it avoids copying data if possible. Therefore, it may return a view. Use <code>always_copy = true</code> if you never want it to return an ITensor with a view of the original ITensor.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/08de9d725d5f56b936a1d684553ae0012e4d34a0/src/itensor.jl#L967-L979" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="IndexSetType.html">« IndexSet</a><a class="docs-footer-nextpage" href="MPSandMPO.html">MPS and MPO »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 19 May 2020 20:43">Tuesday 19 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>