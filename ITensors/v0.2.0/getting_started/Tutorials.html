<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/ITensorDocs/'</script><script charset="utf-8" src="../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Tutorials · ITensors.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" data-theme-name="documenter-dark" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="https://itensor.github.io/ITensorDocs/ITensors/stable/getting_started/Tutorials.html" rel="canonical"/><link href="../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../../Overview/">Home</a><a class="nav-link active nav-item" href="../../">ITensors</a><a class="nav-link nav-item" href="../../../ITensorMPS/">ITensorMPS</a><div class="search nav-item"><input id="search-input" placeholder="Search everywhere..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img alt="ITensors.jl logo" src="../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">ITensors.jl</span></div><form action="../search.html" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><span class="tocitem">Getting Started with ITensor</span><ul><li><a class="tocitem" href="Installing.html">Installing Julia and ITensor</a></li><li><a class="tocitem" href="RunningCodes.html">Running ITensor and Julia Codes</a></li><li class="is-active"><a class="tocitem" href="Tutorials.html">Tutorials</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started-with-DMRG-1"><span>Getting Started with DMRG</span></a></li><li><a class="tocitem" href="#Conserving-Quantum-Numbers-(QNs)-in-DMRG-1"><span>Conserving Quantum Numbers (QNs) in DMRG</span></a></li><li><a class="tocitem" href="#Getting-Started-with-MPS-Time-Evolution-1"><span>Getting Started with MPS Time Evolution</span></a></li></ul></li><li><a class="tocitem" href="NextSteps.html">Next Steps</a></li></ul></li><li><span class="tocitem">Code Examples</span><ul><li><a class="tocitem" href="../examples/ITensor.html">ITensor Examples</a></li><li><a class="tocitem" href="../examples/MPSandMPO.html">MPS and MPO Examples</a></li><li><a class="tocitem" href="../examples/DMRG.html">DMRG Examples</a></li><li><a class="tocitem" href="../examples/Physics.html">Physics System Examples</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../IndexType.html">Index</a></li><li><a class="tocitem" href="../IndexSetType.html">Index collections</a></li><li><a class="tocitem" href="../ITensorType.html">ITensor</a></li><li><a class="tocitem" href="../MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="../QN.html">QN</a></li><li><a class="tocitem" href="../SiteType.html">SiteType and op</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DMRG.html">DMRG</a></li><li><a class="tocitem" href="../Sweeps.html">Sweeps</a></li><li><a class="tocitem" href="../ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="../ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="../Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="../DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="../OpSum.html">OpSum</a></li></ul></li><li><span class="tocitem">Upgrade guides</span><ul><li><a class="tocitem" href="../UpgradeGuide_0.1_to_0.2.html">Upgrading from 0.1 to 0.2</a></li></ul></li><li><a class="tocitem" href="../Einsum.html">ITensor indices and Einstein notation</a></li><li><span class="tocitem">Advanced usage guide</span><ul><li><a class="tocitem" href="../AdvancedUsageGuide.html">Advanced usage guide</a></li><li><a class="tocitem" href="../Multithreading.html">Multithreading</a></li><li><a class="tocitem" href="../QNTricks.html">Symmetric tensor background and usage</a></li><li><a class="tocitem" href="../CodeTiming.html">Timing and profiling</a></li><li><a class="tocitem" href="../ContractionSequenceOptimization.html">Contraction sequence optimization</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started with ITensor</a></li><li class="is-active"><a href="Tutorials.html">Tutorials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Tutorials.html">Tutorials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/master/docs/src/getting_started/Tutorials.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorials-1"><a class="docs-heading-anchor" href="#Tutorials-1">Tutorials</a><a class="docs-heading-anchor-permalink" href="#Tutorials-1" title="Permalink"></a></h1><h2 id="Getting-Started-with-DMRG-1"><a class="docs-heading-anchor" href="#Getting-Started-with-DMRG-1">Getting Started with DMRG</a><a class="docs-heading-anchor-permalink" href="#Getting-Started-with-DMRG-1" title="Permalink"></a></h2><p>The <a href="https://tensornetwork.org/mps/algorithms/dmrg/">density matrix renormalization group (DMRG)</a> is an algorithm for computing eigenstates of Hamiltonians (or extremal eigenvectors of large, Hermitian matrices).  It computes these eigenstates in the  <a href="https://tensornetwork.org/mps/">matrix product state (MPS)</a> format.</p><p>Let's see how to set up and run a DMRG calculation using the ITensor library. We will be interested in finding the ground state of the quantum Hamiltonian <span>$H$</span> given by:</p><div>\[H = \sum_{j=1}^{N-1} \mathbf{S}_{j} \cdot \mathbf{S}_{j+1} = \sum_{j=1}^{N-1} S^z_{j} S^z_{j+1} + \frac{1}{2} S^+_{j} S^-_{j+1} + \frac{1}{2} S^-_{j} S^+_{j+1}\]</div><p>This Hamiltonian is known as the one-dimensional Heisenberg model and we will take the spins to be <span>$S=1$</span> spins (spin-one spins). We will consider the case of <span>$N=100$</span> and plan to do five sweeps of DMRG (five passes over the system).</p><p><strong>ITensor DMRG Code</strong></p><p>Let's look at an entire, working ITensor code that will do this calculation then discuss the main steps. If you need help running the code below, see the getting started page on <a href="RunningCodes.html#Running-ITensor-and-Julia-Codes-1">Running ITensor and Julia Codes</a>.</p><pre><code class="language-julia">using ITensors
let
  N = 100
  sites = siteinds("S=1",N)

  ampo = OpSum()
  for j=1:N-1
    ampo += "Sz",j,"Sz",j+1
    ampo += 1/2,"S+",j,"S-",j+1
    ampo += 1/2,"S-",j,"S+",j+1
  end
  H = MPO(ampo,sites)

  psi0 = randomMPS(sites,10)

  sweeps = Sweeps(5)
  setmaxdim!(sweeps, 10,20,100,100,200)
  setcutoff!(sweeps, 1E-10)

  energy, psi = dmrg(H,psi0, sweeps)

  return
end</code></pre><p><strong>Steps of The Code</strong></p><p>The first two lines</p><pre><code class="language-julia">N = 100
sites = siteinds("S=1",N)</code></pre><p>tells the function <code>siteinds</code> to make an array of ITensor <a href="https://itensor.github.io/ITensors.jl/stable/IndexType.html">Index</a> objects which have the properties of <span>$S=1$</span> spins. This means their dimension will be 3 and  they will carry the <code>"S=1"</code> tag, which will enable the next part of the code to know how to make appropriate operators for them.</p><p>Try printing out some of these indices to verify their properties:</p><pre><code class="language-julia">@show sites[1]</code></pre><pre><code class="language-none">(dim=3|id=816|"S=1,Site,n=1")</code></pre><p>The next part of the code builds the Hamiltonian:</p><pre><code class="language-julia">ampo = OpSum()
for j=1:N-1
  ampo += "Sz",j,"Sz",j+1
  ampo += 1/2,"S+",j,"S-",j+1
  ampo += 1/2,"S-",j,"S+",j+1
end
H = MPO(ampo,sites)</code></pre><p>An <code>OpSum</code> is an object which accumulates Hamiltonian terms such as <code>"Sz",1,"Sz",2</code> so that they can be summed afterward into a matrix product operator (MPO) tensor network.  The line of code <code>H = MPO(ampo,sites)</code> constructs the Hamiltonian in the MPO format, with physical indices given by the array <code>sites</code>.</p><p>The line</p><pre><code class="language-julia">psi0 = randomMPS(sites,10)</code></pre><p>constructs an MPS <code>psi0</code> which has the physical indices <code>sites</code> and a bond dimension of 10. It is made by a random quantum circuit that is reshaped into an MPS, so that it will have as generic and unbiased properties as an MPS of that size can have. This choice can help prevent the DMRG calculation from getting stuck in a local minimum.</p><p>The lines</p><pre><code class="language-julia">sweeps = Sweeps(5)
setmaxdim!(sweeps, 10,20,100,100,200)
setcutoff!(sweeps, 1E-10)</code></pre><p>construct a <code>Sweeps</code> objects which is initialized to define 5 sweeps of DMRG. The call to <code>setmaxdim!</code> sets the maximum dimension allowed for each sweep and the call to <code>setcutoff!</code> sets the truncation error goal of each sweep (if fewer values are specified than sweeps, the last value is used for all remaining sweeps).</p><p>Finally the call </p><pre><code class="language-julia">energy, psi = dmrg(H,psi0,sweeps)</code></pre><p>runs the DMRG algorithm included in ITensor, using <code>psi0</code> as an initial guess for the ground state wavefunction. The optimized MPS <code>psi</code> and its eigenvalue <code>energy</code> are returned.</p><p>After the <code>dmrg</code> function returns, you can take the returned MPS <code>psi</code> and do further calculations with it, such as measuring local operators or computing entanglement entropy.</p><h2 id="Conserving-Quantum-Numbers-(QNs)-in-DMRG-1"><a class="docs-heading-anchor" href="#Conserving-Quantum-Numbers-(QNs)-in-DMRG-1">Conserving Quantum Numbers (QNs) in DMRG</a><a class="docs-heading-anchor-permalink" href="#Conserving-Quantum-Numbers-(QNs)-in-DMRG-1" title="Permalink"></a></h2><p>An important technique in DMRG calculations of quantum Hamiltonians is the conservation of <em>quantum numbers</em>. Examples of these are the total number of particles of a model of fermions, or the total of all <span>$S^z$</span> components of a system of spins. Not only can conserving quantum numbers make DMRG calculations run more quickly and use less memory, but it can be important for simulating physical systems with conservation laws and for obtaining ground states in different symmetry sectors. Note that ITensor currently only supports Abelian quantum numbers.</p><h4 id="Necessary-Changes-1"><a class="docs-heading-anchor" href="#Necessary-Changes-1">Necessary Changes</a><a class="docs-heading-anchor-permalink" href="#Necessary-Changes-1" title="Permalink"></a></h4><p>Setting up a quantum-number conserving DMRG calculation in ITensor requires only very small changes to a DMRG code. The main changes are:</p><ol><li>using tensor indices (<code>Index</code> objects) which carry quantum number (QN) information to build your Hamiltonian and  initial state</li><li>initializing your MPS to have well-defined total quantum numbers</li></ol><p>Importantly, <em>the total QN of your state throughout the calculation will  remain the same as the initial state passed to DMRG</em>. The total QN of your state is not set separately, but determined  implicitly from the initial QN of the state when it is first constructed.</p><p>Of course, your Hamiltonian should conserve all of the QN's that you would like to use. If it doesn't, you will get an error when you try to construct it out of the QN-enabled tensor indices.</p><h4 id="Making-the-Changes-1"><a class="docs-heading-anchor" href="#Making-the-Changes-1">Making the Changes</a><a class="docs-heading-anchor-permalink" href="#Making-the-Changes-1" title="Permalink"></a></h4><p>Let's see how to make these two changes to the DMRG code from the  <a href="Tutorials.html#Getting-Started-with-DMRG-1">Getting Started with DMRG</a> tutorial above. At the end, we will put together these changes for a complete, working code.</p><p><strong>Change 1: QN Site Indices</strong></p><p>To make change (1), we will change the line</p><pre><code class="language-julia">sites = siteinds("S=1",N)</code></pre><p>by setting the <code>conserve_qns</code> keyword argument to <code>true</code>:</p><pre><code class="language-julia">sites = siteinds("S=1",N; conserve_qns=true)</code></pre><p>Setting <code>conserve_qns=true</code> tells the <code>siteinds</code> function to conserve every possible quantum number associated to the site type (which is <code>"S=1"</code> in this example). For <span>$S=1$</span> spins, this will turn on total-<span>$S^z$</span> conservation. (For other site types that conserve multiple QNs, there are specific keyword  arguments available to track just a subset of conservable QNs.) We can check this by printing out some of the site indices, and seeing that the subspaces of each <code>Index</code> are labeled by QN values:</p><pre><code class="language-julia">@show sites[1]
@show sites[2]</code></pre><p>Sample output:</p><pre><code class="language-none"> sites[1] = (dim=3|id=794|"S=1,Site,n=1") &lt;Out&gt;
 1: QN("Sz",2) =&gt; 1
 2: QN("Sz",0) =&gt; 1
 3: QN("Sz",-2) =&gt; 1
 sites[2] = (dim=3|id=806|"S=1,Site,n=2") &lt;Out&gt;
 1: QN("Sz",2) =&gt; 1
 2: QN("Sz",0) =&gt; 1
 3: QN("Sz",-2) =&gt; 1</code></pre><p>In the sample output above, note than in addition to the dimension of these indices being 3, each of the three settings of the Index have a unique QN associated to them. The number after the QN on each line is the dimension of that subspace, which is 1 for each subspace of the Index objects above. Note also that <code>"Sz"</code> quantum numbers in ITensor are measured in units of <span>$1/2$</span>, so <code>QN("Sz",2)</code> corresponds to <span>$S^z=1$</span> in conventional physics units.</p><p><strong>Change 2: Initial State</strong></p><p>To make change (2), instead of constructing the initial MPS <code>psi0</code> to be an arbitrary, random MPS, we will make it a specific state with a well-defined total <span>$S^z$</span>.  So we will replace the line</p><pre><code class="language-julia">psi0 = randomMPS(sites,10)</code></pre><p>by the lines</p><pre><code class="language-julia">state = [isodd(n) ? "Up" : "Dn" for n=1:N]
psi0 = productMPS(sites,state)</code></pre><p>The first line of the new code above makes an array of strings which  alternate between <code>"Up"</code> and <code>"Dn"</code> on odd and even numbered sites. These names <code>"Up"</code> and <code>"Dn"</code> are special values associated to the <code>"S=1"</code>  site type which indicate up and down spin values. The second line takes the array of site Index objects <code>sites</code> and the array of strings <code>state</code> and returns an MPS which is a product state (classical, unentangled state) with each site's state given by the strings in the <code>state</code> array. In this example, <code>psi0</code> will be a Neel state with alternating up and down  spins, so it will have a total <span>$S^z$</span> of zero. We could check this by computing the quantum-number flux of <code>psi0</code></p><pre><code class="language-julia">@show flux(psi0)
# Output: flux(psi0) = QN("Sz",0)</code></pre><div class="admonition is-info"><header class="admonition-header">Setting Other Total QN Values</header><div class="admonition-body"><p>The above example shows the case of setting a total "Sz" quantum number of zero, since the initial state alternates between "Up" and "Dn" on every site with an even number of sites.</p><p>To obtain other total QN values, just set the initial state to be one which has the total QN you want. To be concrete let's take the example of a system with <code>N=10</code> sites of  <span>$S=1$</span> spins.</p><p>For example if you want a total "Sz" of +20 (= <code>QN("Sz",20)</code>) in ITensor units, or <span>$S^z=10$</span> in physical units, for a system with 10 sites,  use the initial state:</p><pre><code class="language-julia">state = ["Up" for n=1:N]
psi0 = productMPS(sites,state)</code></pre><p>Or to initialize this 10-site system to have a total "Sz" of +16 in ITensor units (<span>$S^z=8$</span> in physical units):</p><pre><code class="language-julia">state = ["Dn","Up","Up","Up","Up","Up","Up","Up","Up","Up"]
psi0 = productMPS(sites,state)</code></pre><p>would work (as would any <code>state</code> with one "Dn" and nine "Up"'s in any order). Or you could initialize to a total "Sz" of +18 in ITensor units (<span>$S^z=9$</span> in physical units) as</p><pre><code class="language-julia">state = ["Z0","Up","Up","Up","Up","Up","Up","Up","Up","Up"]
psi0 = productMPS(sites,state)</code></pre><p>where "Z0" refers to the <span>$S^z=0$</span> state of a spin-one spin.</p><p>Finally, the same kind of logic as above applies to other physical site types, whether "S=1/2", "Electron", "Boson", etc.</p></div></div><h4 id="Putting-it-All-Together-1"><a class="docs-heading-anchor" href="#Putting-it-All-Together-1">Putting it All Together</a><a class="docs-heading-anchor-permalink" href="#Putting-it-All-Together-1" title="Permalink"></a></h4><p>Let's take the DMRG code from the <em>Getting Started with DMRG</em> tutorial above and make the changes above to it, to turn it into a code which conserves  the total <span>$S^z$</span> quantum number throughout the DMRG calculation. The resulting code is:</p><pre><code class="language-julia">using ITensors
let
  N = 100
  sites = siteinds("S=1",N;conserve_qns=true)

  ampo = OpSum()
  for j=1:N-1
    ampo += "Sz",j,"Sz",j+1
    ampo += 1/2,"S+",j,"S-",j+1
    ampo += 1/2,"S-",j,"S+",j+1
  end
  H = MPO(ampo,sites)

  state = [isodd(n) ? "Up" : "Dn" for n=1:N]
  psi0 = productMPS(sites,state)
  @show flux(psi0)

  sweeps = Sweeps(5)
  setmaxdim!(sweeps, 10,20,100,100,200)
  setcutoff!(sweeps, 1E-10)

  energy, psi = dmrg(H,psi0, sweeps)

  return
end</code></pre><h2 id="Getting-Started-with-MPS-Time-Evolution-1"><a class="docs-heading-anchor" href="#Getting-Started-with-MPS-Time-Evolution-1">Getting Started with MPS Time Evolution</a><a class="docs-heading-anchor-permalink" href="#Getting-Started-with-MPS-Time-Evolution-1" title="Permalink"></a></h2><p>An important application of <a href="https://tensornetwork.org/mps/">matrix product state (MPS)</a>  tensor networks in physics is computing the time evolution of a quantum state under the dynamics of a Hamiltonian <span>$H$</span>. An accurate, efficient, and simple way to time evolve a matrix product state (MPS) is by using a Trotter decomposition of the time evolution operator <span>$U(t) = e^{-i H t}$</span>.</p><p>The technique we will use is "time evolving block decimation" (TEBD).  More simply it is just the idea of decomposing the time-evolution operator into a circuit of quantum 'gates' (two-site unitaries) using the Trotter-Suzuki approximation and applying these gates in a controlled way to an MPS.</p><p>Let's see how to set up and run a TEBD calculation using ITensor.</p><p>The Hamiltonian <span>$H$</span> we will use is the one-dimensional Heisenberg model which is given by:</p><div>\[\begin{aligned}
H &amp; = \sum_{j=1}^{N-1} \mathbf{S}_{j} \cdot \mathbf{S}_{j+1}  \\
&amp; = \sum_{j=1}^{N-1} S^z_{j} S^z_{j+1} + \frac{1}{2} S^+_{j} S^-_{j+1} + \frac{1}{2} S^-_{j} S^+_{j+1}
\end{aligned} \]</div><p><strong>The TEBD Method</strong></p><p>When the Hamiltonian, like the one above, is a sum of local terms,</p><div>\[H = \sum_j h_{j,j+1}\]</div><p>where <span>$h_{j,j+1}$</span> acts on sites j and j+1, then a Trotter decomposition that is particularly well suited for use with MPS techniques is</p><div>\[e^{-i \tau H} \approx e^{-i h_{1,2} \tau/2} e^{-i h_{2,3} \tau/2} \cdots e^{-i h_{N-1,N} \tau/2}
e^{-i h_{N-1,N} \tau/2} e^{-i h_{N-2,N-1} \tau/2} \cdots e^{-i h_{1,2} \tau/2} + O(\tau^3)\]</div><p>Note the factors of two in each exponential. Each factored exponential is known as a Trotter "gate".</p><p>We can visualize the resulting circuit that will be applied to the MPS as follows:</p><p><img alt="" src="trotter_tevol.png"/></p><p>The error in the above decomposition is of order <span>$\tau^3$</span>, so that will be the error accumulated <em>per time step</em>. Because of the time-step error, one takes <span>$\tau$</span> to be small and then applies the above set of operators to an MPS as a single sweep, then does a number <span>$(t/\tau)$</span> of sweeps to evolve for a total time <span>$t$</span>. The total error will therefore scale as <span>$\tau^2$</span> with this scheme, though other sources of error may dominate for long times, or very small <span>$\tau$</span>, such as truncation errors.</p><p>Let's take a look at the code to apply these Trotter gates to an MPS to time evolve it. Then we will break down the steps of the code in more detail.</p><p><strong>ITensor TEBD Time Evolution Code</strong></p><p>Let's look at an entire, working ITensor code that will do this calculation then discuss the main steps. (If you need help running the code below, see the getting started page on running ITensor codes.)</p><pre><code class="language-julia">using ITensors

let
  N = 100
  cutoff = 1E-8
  tau = 0.1
  ttotal = 5.0

  # Compute the number of steps to do
  Nsteps = Int(ttotal/tau)

  # Make an array of 'site' indices
  s = siteinds("S=1/2",N;conserve_qns=true)

  # Make gates (1,2),(2,3),(3,4),...
  gates = ITensor[]
  for j=1:N-1
    s1 = s[j]
    s2 = s[j+1]
    hj =       op("Sz",s1) * op("Sz",s2) +
         1/2 * op("S+",s1) * op("S-",s2) +
         1/2 * op("S-",s1) * op("S+",s2)
    Gj = exp(-1.0im * tau/2 * hj)
    push!(gates,Gj)
  end
  # Include gates in reverse order too
  # (N,N-1),(N-1,N-2),...
  append!(gates,reverse(gates))

  # Function that measures &lt;Sz&gt; on site n
  function measure_Sz(psi,n)
    psi = orthogonalize(psi,n)
    sn = siteind(psi,n)
    Sz = scalar(dag(prime(psi[n],"Site"))*op("Sz",sn)*psi[n])
    return real(Sz)
  end

  # Initialize psi to be a product state (alternating up and down)
  psi = productMPS(s, n -&gt; isodd(n) ? "Up" : "Dn")

  c = div(N,2)

  # Compute and print initial &lt;Sz&gt; value
  t = 0.0
  Sz = measure_Sz(psi,c)
  println("$t $Sz")

  # Do the time evolution by applying the gates
  # for Nsteps steps
  for step=1:Nsteps
    psi = apply(gates, psi; cutoff=cutoff)
    t += tau
    Sz = measure_Sz(psi,c)
    println("$t $Sz")
  end

  return
end</code></pre><p><strong>Steps of The Code</strong></p><p>After setting some parameters, like the system size N and time step <span>$\tau$</span> to use, we compute the number of time evolution steps <code>Nsteps</code> that will be needed.</p><p>The line <code>s = siteinds("S=1/2",N;conserve_qns=true)</code> defines an array of  spin 1/2 tensor indices (Index objects) which will be the site or physical indices of the MPS.</p><p>Next we make an empty array <code>gates = ITensor[]</code> that will hold ITensors  that will be our Trotter gates. Inside the <code>for n=1:N-1</code> loop that follows the lines</p><pre><code class="language-julia">hj =      op("Sz",s1) * op("Sz",s2) +
    1/2 * op("S+",s1) * op("S-",s2) +
    1/2 * op("S-",s1) * op("S+",s2)</code></pre><p>call the <code>op</code> function which reads the "S=1/2" tag on our site indices (sites j and j+1) and which then knows that we want the spin 1/ 2 version of the "Sz", "S+", and "S-" operators.  The <code>op</code> function returns these operators as ITensors and we  tensor product and add them together to compute the operator <span>$h_{j,j+1}$</span> defined as</p><div>\[h_{j,j+1} = S^z_j S^z_{j+1} + \frac{1}{2} S^+_j S^-_{j+1} + \frac{1}{2} S^-_j S^+_{j+1} \]</div><p>which we call <code>hj</code> in the code.</p><p>To make the corresponding Trotter gate <code>Gj</code> we exponentiate <code>hj</code> times a factor <span>$-i \tau/2$</span> and then append or push this onto the end of the gate array <code>gates</code>.</p><pre><code class="language-julia">Gj = exp(-1.0im * tau/2 * hj)
push!(gates,Gj)</code></pre><p>Having made the gates for bonds (1,2),(2,3),(3,4), etc. we still need to append the gates in reverse order to complete the correct Trotter formula. Here we can conveniently do that by just calling the Julia <code>append!</code> function and supply a reversed version of the array of gates we have made so far. This can be done in a single line of code <code>append!(gates,reverse(gates))</code>.</p><p>So that the code produces interesting output, we define a function called <code>measure_Sz</code> that we will pass our MPS into and which will return the expected value of <span>$S^z$</span> on a given site, which we will take to be near the center of the MPS. The details of this  function are outside the scope of this tutorial, but are explained in the example code for measuring MPS.</p><p>The line of code <code>psi = productMPS(s, n -&gt; isodd(n) ? "Up" : "Dn")</code> initializes our MPS <code>psi</code> as a product state of alternating  up and down spins. We call <code>measure_Sz</code> before starting the time evolution.</p><p>Finally, to carry out the time evolution we loop over the step number <code>for step=1:Nsteps</code> and during each step call the function </p><pre><code class="language-julia">psi = apply(gates, psi; cutoff=cutoff)</code></pre><p>which applies the array of ITensors called <code>gates</code> to our current MPS <code>psi</code>, truncating the MPS at each step using the truncation error threshold supplied as the variable <code>cutoff</code>. </p><p>The <code>apply</code> function is smart enough to determine which site indices each gate has, and then figure out where to apply it to our MPS. It automatically handles truncating the MPS and can even handle non-nearest-neighbor gates, though that  feature is not used in this example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="RunningCodes.html">« Running ITensor and Julia Codes</a><a class="docs-footer-nextpage" href="NextSteps.html">Next Steps »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 9 June 2021 18:13">Wednesday 9 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>