<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/ITensorDocs/'</script><script charset="utf-8" src="../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>ITensor · ITensors.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" data-theme-name="documenter-dark" href="assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="assets/themeswap.js"></script><link href="https://itensor.github.io/ITensorDocs/ITensors/stable/ITensorType.html" rel="canonical"/><link href="../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../Overview/">Home</a><a class="nav-link active nav-item" href="../">ITensors</a><a class="nav-link nav-item" href="../../ITensorMPS/">ITensorMPS</a><div class="search nav-item"><input id="search-input" placeholder="Search everywhere..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img alt="ITensors.jl logo" src="assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">ITensors.jl</span></div><form action="search.html" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="IndexType.html">Index</a></li><li><a class="tocitem" href="IndexValType.html">IndexVal</a></li><li><a class="tocitem" href="IndexSetType.html">IndexSet</a></li><li class="is-active"><a class="tocitem" href="ITensorType.html">ITensor</a><ul class="internal"><li><a class="tocitem" href="#Description-1"><span>Description</span></a></li><li><a class="tocitem" href="#Dense-Constructors-1"><span>Dense Constructors</span></a></li><li><a class="tocitem" href="#QN-BlockSparse-Constructors-1"><span>QN BlockSparse Constructors</span></a></li><li><a class="tocitem" href="#Empty-Constructors-1"><span>Empty Constructors</span></a></li><li><a class="tocitem" href="#QN-Empty-Constructors-1"><span>QN Empty Constructors</span></a></li><li><a class="tocitem" href="#Diagonal-constructors-1"><span>Diagonal constructors</span></a></li><li><a class="tocitem" href="#QN-Diagonal-constructors-1"><span>QN Diagonal constructors</span></a></li><li><a class="tocitem" href="#Convert-to-Array-1"><span>Convert to Array</span></a></li><li><a class="tocitem" href="#Getting-and-setting-elements-1"><span>Getting and setting elements</span></a></li><li><a class="tocitem" href="#Properties-1"><span>Properties</span></a></li><li><a class="tocitem" href="#Priming_and_tagging_ITensor-1"><span>Priming and tagging</span></a></li><li><a class="tocitem" href="#IndexSet-set-operations-1"><span>IndexSet set operations</span></a></li><li><a class="tocitem" href="#Index-Manipulations-1"><span>Index Manipulations</span></a></li><li><a class="tocitem" href="#Math-operations-1"><span>Math operations</span></a></li><li><a class="tocitem" href="#Decompositions-1"><span>Decompositions</span></a></li><li><a class="tocitem" href="#Operations-1"><span>Operations</span></a></li></ul></li><li><a class="tocitem" href="MPSandMPO.html">MPS and MPO</a></li><li><a class="tocitem" href="QN.html">QN</a></li><li><a class="tocitem" href="SiteType.html">SiteType and op</a></li><li><input class="collapse-toggle" id="menuitem-2-8" type="checkbox"/><label class="tocitem" for="menuitem-2-8"><span class="docs-label">DMRG</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="DMRG.html">DMRG</a></li><li><a class="tocitem" href="ProjMPO.html">ProjMPO</a></li><li><a class="tocitem" href="ProjMPOSum.html">ProjMPOSum</a></li><li><a class="tocitem" href="Observer.html">Observer System for DMRG</a></li><li><a class="tocitem" href="DMRGObserver.html">DMRGObserver</a></li></ul></li><li><a class="tocitem" href="AutoMPO.html">AutoMPO</a></li></ul></li><li><span class="tocitem">Advanced usage guide</span><ul><li><a class="tocitem" href="AdvancedUsageGuide.html">Advanced usage guide</a></li><li><a class="tocitem" href="Multithreading.html">Multithreading</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ITensorType.html">ITensor</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ITensor/ITensors.jl/blob/master/docs/src/ITensorType.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="ITensor-1"><a class="docs-heading-anchor" href="#ITensor-1">ITensor</a><a class="docs-heading-anchor-permalink" href="#ITensor-1" title="Permalink"></a></h1><h2 id="Description-1"><a class="docs-heading-anchor" href="#Description-1">Description</a><a class="docs-heading-anchor-permalink" href="#Description-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor" id="ITensors.ITensor"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ITensor{N}</code></pre><p>An ITensor is a tensor whose interface is  independent of its memory layout. Therefore it is not necessary to know the ordering of an ITensor's indices, only which indices an ITensor has. Operations like contraction and addition of ITensors automatically handle any memory permutations.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; i = Index(2, "i")
(dim=2|id=287|"i")

julia&gt; A = randomITensor(i', i)
ITensor ord=2 (dim=2|id=287|"i")' (dim=2|id=287|"i")
NDTensors.Dense{Float64,Array{Float64,1}}

julia&gt; @show A;
A = ITensor ord=2
Dim 1: (dim=2|id=287|"i")'
Dim 2: (dim=2|id=287|"i")
NDTensors.Dense{Float64,Array{Float64,1}}
 2×2
 0.28358594718392427   1.4342219756446355
 1.6620103556283987   -0.40952231269251566

julia&gt; @show inds(A);
inds(A) = IndexSet{2} (dim=2|id=287|"i")' (dim=2|id=287|"i") 

julia&gt; A[i =&gt; 1, i' =&gt; 2] = 1;

julia&gt; @show A;
A = ITensor ord=2
Dim 1: (dim=2|id=287|"i")'
Dim 2: (dim=2|id=287|"i")
NDTensors.Dense{Float64,Array{Float64,1}}
 2×2
 0.28358594718392427   1.4342219756446355
 1.0                  -0.40952231269251566

julia&gt; @show store(A);
store(A) = [0.28358594718392427, 1.0, 1.4342219756446355, -0.40952231269251566]

julia&gt; B = randomITensor(i, i');

julia&gt; @show B;
B = ITensor ord=2
Dim 1: (dim=2|id=287|"i")
Dim 2: (dim=2|id=287|"i")'
NDTensors.Dense{Float64,Array{Float64,1}}
 2×2
 -0.6510816500352691   0.2579101497658179
  0.256266641521826   -0.9464735926768166

julia&gt; @show A + B;
A + B = ITensor ord=2
Dim 1: (dim=2|id=287|"i")'
Dim 2: (dim=2|id=287|"i")
NDTensors.Dense{Float64,Array{Float64,1}}
 2×2
 -0.3674957028513448   1.6904886171664615
  1.2579101497658178  -1.3559959053693322</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L2-L69" target="_blank">source</a></section></article><h2 id="Dense-Constructors-1"><a class="docs-heading-anchor" href="#Dense-Constructors-1">Dense Constructors</a><a class="docs-heading-anchor-permalink" href="#Dense-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.ITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor([::Type{ElT} = Float64, ]inds)
ITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor filled with zeros having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L226-L233" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor-Tuple{Type{#s76} where #s76&lt;:Number,UndefInitializer,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.ITensor-Tuple{Type{#s76} where #s76&lt;:Number,UndefInitializer,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)
ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...)</code></pre><p>Construct an ITensor filled with undefined elements having indices <code>inds</code> and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p><p>The storage will have <code>NDTensors.Dense</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L250-L257" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.randomITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.randomITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.randomITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomITensor([::Type{ElT &lt;: Number} = Float64, ]inds)

randomITensor([::Type{ElT &lt;: Number} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor with type <code>ElT</code> and indices <code>inds</code>, whose elements are normally distributed random numbers. If the element type is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1179-L1185" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.setelt-Tuple{IndexVal}" id="ITensors.setelt-Tuple{IndexVal}"><code>ITensors.setelt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setelt(ivs...)</code></pre><p>Create an ITensor with all zeros except the specified value, which is set to 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia">i = Index(2,"i")
A = setelt(i=&gt;2)
# A[i=&gt;2] == 1, all other elements zero

j = Index(3,"j")
B = setelt(i=&gt;1,j=&gt;3)
# B[i=&gt;1,j=&gt;3] == 1, all other element zero</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L454-L470" target="_blank">source</a></section></article><h2 id="QN-BlockSparse-Constructors-1"><a class="docs-heading-anchor" href="#QN-BlockSparse-Constructors-1">QN BlockSparse Constructors</a><a class="docs-heading-anchor-permalink" href="#QN-BlockSparse-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor-Tuple{Type{#s76} where #s76&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.ITensor-Tuple{Type{#s76} where #s76&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds)
ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds::Index...)</code></pre><p>Construct an ITensor with BlockSparse storage filled with <code>zero(ElT)</code> where the nonzero blocks are determined by <code>flux</code>.</p><p>If <code>ElT</code> is not specified it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/qn/qnitensor.jl#L2-L9" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.ITensor-Tuple{Array,IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}} where N}" id="ITensors.ITensor-Tuple{Array,IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}} where N}"><code>ITensors.ITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ITensor(::Array, ::IndexSet; tol = 0)

ITensor(::Array, ::Index...; tol = 0)</code></pre><p>Create a block sparse ITensor from the input Array, and collection  of QN indices. Zeros are dropped and nonzero blocks are determined from the zero values of the array.</p><p>Optionally, you can set a tolerance such that elements less than or equal to the tolerance are dropped.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; i = Index([QN(0)=&gt;1, QN(1)=&gt;2], "i");

julia&gt; A = [1e-9 0.0 0.0;
            0.0 2.0 3.0;
            0.0 1e-10 4.0];

julia&gt; @show ITensor(A, i', dag(i); tol = 1e-8);
ITensor(A, i', dag(i); tol = 1.0e-8) = ITensor ord=2
Dim 1: (dim=3|id=468|"i")' &lt;Out&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
Dim 2: (dim=3|id=468|"i") &lt;In&gt;
 1: QN(0) =&gt; 1
 2: QN(1) =&gt; 2
NDTensors.BlockSparse{Float64,Array{Float64,1},2}
 3×3
Block: (2, 2)
 [2:3, 2:3]
 2.0  3.0
 0.0  4.0</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/qn/qnitensor.jl#L48-L83" target="_blank">source</a></section></article><h2 id="Empty-Constructors-1"><a class="docs-heading-anchor" href="#Empty-Constructors-1">Empty Constructors</a><a class="docs-heading-anchor-permalink" href="#Empty-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.emptyITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.emptyITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.emptyITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">emptyITensor([::Type{ElT} = Float64, ]inds)
emptyITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor with storage type <code>NDTensors.Empty</code>, indices <code>inds</code>, and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L289-L294" target="_blank">source</a></section></article><h2 id="QN-Empty-Constructors-1"><a class="docs-heading-anchor" href="#QN-Empty-Constructors-1">QN Empty Constructors</a><a class="docs-heading-anchor-permalink" href="#QN-Empty-Constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.emptyITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}, IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}}} where N}" id="ITensors.emptyITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}, IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}}} where N}"><code>ITensors.emptyITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">emptyITensor([::Type{ElT} = Float64, ]inds)
emptyITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Construct an ITensor with storage type <code>NDTensors.Empty</code>, indices <code>inds</code>, and element type <code>ElT</code>. If the element type is not specified, it defaults to <code>Float64</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L289-L294" target="_blank">source</a></section><section><div><pre><code class="language-none">emptyITensor([::Type{ElT} = Float64, ]inds)
emptyITensor([::Type{ElT} = Float64, ]inds::QNIndex...)</code></pre><p>Construct an ITensor with <code>NDTensors.BlockSparse</code> storage of element type <code>ElT</code> with the no blocks.</p><p>If <code>ElT</code> is not specified it defaults to <code>Float64</code>.</p><p>In the future, this will use the storage <code>NDTensors.EmptyBlockSparse</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/qn/qnitensor.jl#L104-L113" target="_blank">source</a></section></article><h2 id="Diagonal-constructors-1"><a class="docs-heading-anchor" href="#Diagonal-constructors-1">Diagonal constructors</a><a class="docs-heading-anchor-permalink" href="#Diagonal-constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor([::Type{ElT} = Float64, ]inds)
diagITensor([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Make a sparse ITensor of element type <code>ElT</code> with only elements along the diagonal stored. Defaults to having <code>zero(T)</code> along  the diagonal.</p><p>The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L370-L379" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Array{#s76,1} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Array{#s76,1} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(v::Vector{T}, inds)
diagITensor(v::Vector{T}, inds::Index...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the values stored in <code>v</code> and  the ITensor will have element type <code>float(T)</code>. The storage will have type <code>NDTensors.Diag</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L390-L398" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor(x::Number, inds)
diagITensor(x::Number, inds::Index...)</code></pre><p>Make a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the value <code>float(x)</code> and the ITensor will have element type <code>float(eltype(x))</code>. The storage will have <code>NDTensors.Diag</code> type.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L410-L418" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.delta-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.delta-Tuple{Type{#s76} where #s76&lt;:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delta([::Type{ElT} = Float64, ]inds)
delta([::Type{ElT} = Float64, ]inds::Index...)</code></pre><p>Make a uniform diagonal ITensor with all diagonal elements <code>one(ElT)</code>. Only a single diagonal element is stored.</p><p>This function has an alias <code>δ</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L429-L437" target="_blank">source</a></section></article><h2 id="QN-Diagonal-constructors-1"><a class="docs-heading-anchor" href="#QN-Diagonal-constructors-1">QN Diagonal constructors</a><a class="docs-heading-anchor-permalink" href="#QN-Diagonal-constructors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.diagITensor-Tuple{Type{#s76} where #s76&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.diagITensor-Tuple{Type{#s76} where #s76&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.diagITensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)
diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)</code></pre><p>Make an ITensor with storage type <code>NDTensors.DiagBlockSparse</code> with elements <code>zero(ElT)</code>. The ITensor only has diagonal blocks consistent with the specified <code>flux</code>.</p><p>If the element type is not specified, it defaults to <code>Float64</code>. If theflux is not specified, it defaults to <code>QN()</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/qn/qnitensor.jl#L174-L181" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.delta-Tuple{Type{#s76} where #s76&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}" id="ITensors.delta-Tuple{Type{#s76} where #s76&lt;:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}"><code>ITensors.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)
delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)</code></pre><p>Make an ITensor with storage type <code>NDTensors.DiagBlockSparse</code> with uniform elements <code>one(ElT)</code>. The ITensor only has diagonal blocks consistent with the specified <code>flux</code>.</p><p>If the element type is not specified, it defaults to <code>Float64</code>. If theflux is not specified, it defaults to <code>QN()</code>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/qn/qnitensor.jl#L232-L239" target="_blank">source</a></section></article><h2 id="Convert-to-Array-1"><a class="docs-heading-anchor" href="#Convert-to-Array-1">Convert to Array</a><a class="docs-heading-anchor-permalink" href="#Convert-to-Array-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor{N},Vararg{Index,N}}} where N where ElT" id="Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor{N},Vararg{Index,N}}} where N where ElT"><code>Core.Array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Array{ElT}(T::ITensor, i:Index...)
Array(T::ITensor, i:Index...)

Matrix{ElT}(T::ITensor, row_i:Index, col_i::Index)
Matrix(T::ITensor, row_i:Index, col_i::Index)

Vector{ElT}(T::ITensor)
Vector(T::ITensor)</code></pre><p>Given an ITensor <code>T</code> with indices <code>i...</code>, returns an Array with a copy of the ITensor's elements. The order in which the indices are provided indicates the order of the data in the resulting Array.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L562-L576" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#NDTensors.array-Tuple{ITensor}" id="NDTensors.array-Tuple{ITensor}"><code>NDTensors.array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">array(T::ITensor)</code></pre><p>Given an ITensor <code>T</code>, returns an Array with a copy of the ITensor's elements, or a view in the case the the ITensor's storage is Dense. The ordering of the elements in the Array, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. <em>Therefore this method is intended for developer use only and not recommended for use in ITensor applications.</em></p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1845-L1856" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#NDTensors.matrix-Tuple{ITensor{2}}" id="NDTensors.matrix-Tuple{ITensor{2}}"><code>NDTensors.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix(T::ITensor)</code></pre><p>Given an ITensor <code>T</code> with two indices, returns a Matrix with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense. The ordering of the elements in the Matrix, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. <em>Therefore this method is intended for developer use only and not recommended for use in ITensor applications.</em></p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1859-L1870" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#NDTensors.vector-Tuple{ITensor{1}}" id="NDTensors.vector-Tuple{ITensor{1}}"><code>NDTensors.vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector(T::ITensor)</code></pre><p>Given an ITensor <code>T</code> with one index, returns a Vector with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1873-L1879" target="_blank">source</a></section></article><h2 id="Getting-and-setting-elements-1"><a class="docs-heading-anchor" href="#Getting-and-setting-elements-1">Getting and setting elements</a><a class="docs-heading-anchor-permalink" href="#Getting-and-setting-elements-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}" id="Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(T::ITensor, ivs...)</code></pre><p>Get the specified element of the ITensor, using a list of <code>IndexVal</code>s or <code>Pair{&lt;:Index, Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(2.0, i, i')
A[i =&gt; 1, i' =&gt; 2] # 2.0, same as: A[i' =&gt; 2, i =&gt; 1]</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L658-L670" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N" id="Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(T::ITensor, I::Int...)</code></pre><p>Get the specified element of the ITensor, using internal Index ordering of the ITensor.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(2.0, i, i')
A[1, 2] # 2.0, same as: A[i =&gt; 1, i' =&gt; 2]</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L630-L642" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}" id="Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(T::ITensor, x::Number, ivs...)</code></pre><p>Set the specified element of the ITensor using a list of <code>IndexVal</code>s or <code>Pair{&lt;:Index, Int}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(i, i')
A[i =&gt; 1, i' =&gt; 2] = 1.0 # same as: A[i' =&gt; 2, i =&gt; 1] = 1.0
A[i =&gt; 2, i' =&gt; :] = [2.0 3.0]</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L714-L727" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}" id="Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex!(T::ITensor, x::Number, I::Int...)

setindex!(T::ITensor, x::Number, I::CartesianIndex)</code></pre><p>Set the specified element of the ITensor, using internal Index ordering of the ITensor.</p><p><strong>Example</strong></p><pre><code class="language-julia">i = Index(2; tags = "i")
A = ITensor(i, i')
A[1, 2] = 1.0 # same as: A[i =&gt; 1, i' =&gt; 2] = 1.0
A[2, :] = [2.0 3.0]</code></pre></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L684-L699" target="_blank">source</a></section></article><h2 id="Properties-1"><a class="docs-heading-anchor" href="#Properties-1">Properties</a><a class="docs-heading-anchor-permalink" href="#Properties-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#NDTensors.inds-Tuple{ITensor}" id="NDTensors.inds-Tuple{ITensor}"><code>NDTensors.inds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inds(T::ITensor)</code></pre><p>Return the indices of the ITensor as an IndexSet.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L108-L112" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#NDTensors.ind-Tuple{ITensor,Int64}" id="NDTensors.ind-Tuple{ITensor,Int64}"><code>NDTensors.ind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ind(T::ITensor, i::Int)</code></pre><p>Get the Index of the ITensor along dimension i.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L115-L119" target="_blank">source</a></section></article><h2 id="Priming_and_tagging_ITensor-1"><a class="docs-heading-anchor" href="#Priming_and_tagging_ITensor-1">Priming and tagging</a><a class="docs-heading-anchor-permalink" href="#Priming_and_tagging_ITensor-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prime[!](A::ITensor, plinc::Int = 1; &lt;keyword arguments&gt;) -&gt; ITensor

prime(is::IndexSet, plinc::Int = 1; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Increase the prime level of the indices of an ITensor or IndexSet.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L990-L998" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.setprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setprime[!](A::ITensor, plev::Int; &lt;keyword arguments&gt;) -&gt; ITensor

setprime(is::IndexSet, plev::Int; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the prime level of the indices of an ITensor or IndexSet.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1000-L1008" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.noprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">noprime[!](A::ITensor; &lt;keyword arguments&gt;) -&gt; ITensor

noprime(is::IndexSet; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the prime level of the indices of an ITensor or IndexSet to zero.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1010-L1018" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.mapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replaceprime[!](A::ITensor, plold::Int, plnew::Int; &lt;keyword arguments&gt;) -&gt; ITensor
replaceprime[!](A::ITensor, plold =&gt; plnew; &lt;keyword arguments&gt;) -&gt; ITensor
mapprime[!](A::ITensor, &lt;arguments&gt;; &lt;keyword arguments&gt;) -&gt; ITensor

replaceprime(is::IndexSet, plold::Int, plnew::Int; &lt;keyword arguments&gt;) -&gt; IndexSet
replaceprime(is::IndexSet, plold =&gt; plnew; &lt;keyword arguments&gt;) -&gt; IndexSet
mapprime(is::IndexSet, &lt;arguments&gt;; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the prime level of the indices of an ITensor or IndexSet with prime level <code>plold</code> to <code>plnew</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1020-L1032" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swapprime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swapprime[!](A::ITensor, pl1::Int, pl2::Int; &lt;keyword arguments&gt;) -&gt; ITensor
swapprime[!](A::ITensor, pl1 =&gt; pl2; &lt;keyword arguments&gt;) -&gt; ITensor

swapprime(is::ITensor, pl1::Int, pl2::Int; &lt;keyword arguments&gt;) -&gt; IndexSet
swapprime(is::ITensor, pl1 =&gt; pl2; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the prime level of the indices of an ITensor or IndexSetwith prime level <code>pl1</code> to <code>pl2</code>, and those with prime level <code>pl2</code> to <code>pl1</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1034-L1044" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.addtags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addtags[!](A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

addtags(is::IndexSet, ts::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Add the tags <code>ts</code> to the indices of an ITensor or IndexSet.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1046-L1054" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.removetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">removetags[!](A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

removetags(is::IndexSet, ts::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Remove the tags <code>ts</code> from the indices of an ITensor or IndexSet.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1056-L1064" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replacetags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replacetags[!](A::ITensor, tsold::String, tsnew::String; &lt;keyword arguments&gt;) -&gt; ITensor

replacetags(is::IndexSet, tsold::String, tsnew::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Replace the tags <code>tsold</code> with <code>tsnew</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1076-L1084" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.settags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">settags[!](A::ITensor, ts::String; &lt;keyword arguments&gt;) -&gt; ITensor

settags(is::IndexSet, ts::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Set the tags of the indices of an ITensor or IndexSet to <code>ts</code>.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1066-L1074" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swaptags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swaptags[!](A::ITensor, ts1::String, ts2::String; &lt;keyword arguments&gt;) -&gt; ITensor

swaptags(is::IndexSet, ts1::String, ts2::String; &lt;keyword arguments&gt;) -&gt; IndexSet</code></pre><p>Swap the tags <code>ts1</code> with <code>ts2</code> for the indices of an ITensor.</p><p>Optionally, only modify the indices with the specified keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>tags = nothing</code>: if specified, only modify Index <code>i</code> if <code>hastags(i, tags) == true</code>. </li><li><code>plev = nothing</code>: if specified, only modify Index <code>i</code> if <code>hasplev(i, plev) == true</code>.</li></ul><p>The ITensor functions come in two versions, <code>f</code> and <code>f!</code>. The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1086-L1094" target="_blank">source</a></section></article><h2 id="IndexSet-set-operations-1"><a class="docs-heading-anchor" href="#IndexSet-set-operations-1">IndexSet set operations</a><a class="docs-heading-anchor-permalink" href="#IndexSet-set-operations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.commoninds" id="ITensors.commoninds"><code>ITensors.commoninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">commoninds(A, B; kwargs...)
commoninds(::Order{N}, A, B; kwargs...)</code></pre><p>Return an IndexSet with indices that are common between the indices of <code>A</code> and <code>B</code> (the set intersection, similar to <code>Base.intersect</code>).</p><p>Optionally, specify the desired number of indices as <code>Order(N)</code>, which adds a check and can be a bit more efficient.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L846-L853" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.commonind" id="ITensors.commonind"><code>ITensors.commonind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">commonind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> common between the indices of <code>A</code> and <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.commoninds"><code>commoninds</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L861-L867" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.uniqueinds" id="ITensors.uniqueinds"><code>ITensors.uniqueinds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uniqueinds(A, B; kwargs...)
uniqueinds(::Order{N}, A, B; kwargs...)</code></pre><p>Return an IndexSet with indices that are unique to the set of indices of <code>A</code> and not in <code>B</code> (the set difference, similar to <code>Base.setdiff</code>).</p><p>Optionally, specify the desired number of indices as <code>Order(N)</code>, which adds a check and can be a bit more efficient.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L898-L905" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.uniqueind" id="ITensors.uniqueind"><code>ITensors.uniqueind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uniqueind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> unique to the set of indices of <code>A</code> and not in <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.uniqueinds"><code>uniqueinds</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L913-L919" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.noncommoninds" id="ITensors.noncommoninds"><code>ITensors.noncommoninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">noncommoninds(A, B; kwargs...)
noncommoninds(::Order{N}, A, B; kwargs...)</code></pre><p>Return an IndexSet with indices that are not common between the indices of <code>A</code> and <code>B</code> (the symmetric set difference, similar to <code>Base.symdiff</code>).</p><p>Optionally, specify the desired number of indices as <code>Order(N)</code>, which adds a check and can be a bit more efficient.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L872-L879" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.noncommonind" id="ITensors.noncommonind"><code>ITensors.noncommonind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">noncommonind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> not common between the indices of <code>A</code> and <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.noncommoninds"><code>noncommoninds</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L887-L893" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.unioninds" id="ITensors.unioninds"><code>ITensors.unioninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unioninds(A, B; kwargs...)
unioninds(::Order{N}, A, B; kwargs...)</code></pre><p>Return an IndexSet with indices that are the union of the indices of <code>A</code> and <code>B</code> (the set union, similar to <code>Base.union</code>).</p><p>Optionally, specify the desired number of indices as <code>Order(N)</code>, which adds a check and can be a bit more efficient.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L924-L931" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.unionind" id="ITensors.unionind"><code>ITensors.unionind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unionind(A, B; kwargs...)</code></pre><p>Return the first <code>Index</code> in the union of the indices of <code>A</code> and <code>B</code>.</p><p>See also <a href="ITensorType.html#ITensors.unioninds"><code>unioninds</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L939-L945" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.hascommoninds" id="ITensors.hascommoninds"><code>ITensors.hascommoninds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hascommoninds(A, B; kwargs...)

hascommoninds(B; kwargs...) -&gt; f::Function</code></pre><p>Check if the ITensors or sets of indices <code>A</code> and <code>B</code> have common indices.</p><p>If only one ITensor or set of indices <code>B</code> is passed, return a function <code>f</code> such that <code>f(A) = hascommoninds(A, B; kwargs...)</code></p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L825-L835" target="_blank">source</a></section></article><h2 id="Index-Manipulations-1"><a class="docs-heading-anchor" href="#Index-Manipulations-1">Index Manipulations</a><a class="docs-heading-anchor-permalink" href="#Index-Manipulations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replaceind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replaceind[!](A::ITensor, i1::Index, i2::Index) -&gt; ITensor</code></pre><p>Replace the Index <code>i1</code> with the Index <code>i2</code> in the ITensor.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1096-L1102" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.replaceinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replaceinds(A::ITensor, inds1, inds2) -&gt; ITensor

replaceinds!(A::ITensor, inds1, inds2)</code></pre><p>Replace the Index <code>inds1[n]</code> with the Index <code>inds2[n]</code> in the ITensor, where <code>n</code> runs from <code>1</code> to <code>length(inds1) == length(inds2)</code>.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p><p>The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1104-L1114" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swapind-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swapind-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swapind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swapind(A::ITensor, i1::Index, i2::Index) -&gt; ITensor

swapind!(A::ITensor, i1::Index, i2::Index)</code></pre><p>Swap the Index <code>i1</code> with the Index <code>i2</code> in the ITensor.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1116-L1124" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#ITensors.swapinds-Tuple{ITensor,Vararg{Any,N} where N}" id="ITensors.swapinds-Tuple{ITensor,Vararg{Any,N} where N}"><code>ITensors.swapinds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">swapinds(A::ITensor, inds1, inds2) -&gt; ITensor

swapinds!(A::ITensor, inds1, inds2)</code></pre><p>Swap the Index <code>inds1[n]</code> with the Index <code>inds2[n]</code> in the ITensor, where <code>n</code> runs from <code>1</code> to <code>length(inds1) == length(inds2)</code>.</p><p>The indices must have the same space (i.e. the same dimension and QNs, if applicable).</p><p>The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1126-L1136" target="_blank">source</a></section></article><h2 id="Math-operations-1"><a class="docs-heading-anchor" href="#Math-operations-1">Math operations</a><a class="docs-heading-anchor-permalink" href="#Math-operations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Base.:*-Tuple{ITensor,ITensor}" id="Base.:*-Tuple{ITensor,ITensor}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A::ITensor * B::ITensor</code></pre><p>Contract ITensors A and B to obtain a new ITensor. This  contraction <code>*</code> operator finds all matching indices common to A and B and sums over them, such that the result will  have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be  modified such that they no longer compare equal - for more information see the documentation on Index objects.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1350-L1360" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.exp-Tuple{ITensor,Any,Any}" id="Base.exp-Tuple{ITensor,Any,Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(A::ITensor, Linds=Rinds', Rinds=inds(A,plev=0); ishermitian = false)</code></pre><p>Compute the exponential of the tensor <code>A</code> by treating it as a matrix <span>$A_{lr}$</span> with the left index <code>l</code> running over all indices in <code>Linds</code> and <code>r</code> running over all indices in <code>Rinds</code>.</p><p>Only accepts index lists <code>Linds</code>,<code>Rinds</code> such that: (1) <code>length(Linds) + length(Rinds) == length(inds(A))</code> (2) <code>length(Linds) == length(Rinds)</code> (3) For each pair of indices <code>(Linds[n],Rinds[n])</code>, <code>Linds[n]</code> and <code>Rinds[n]</code> represent the same Hilbert space (the same QN structure in the QN case, or just the same length in the dense case), and appear in <code>A</code> with opposite directions.</p><p>When <code>ishermitian=true</code> the exponential of <code>Hermitian(A_{lr})</code> is computed internally.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1428-L1443" target="_blank">source</a></section></article><h2 id="Decompositions-1"><a class="docs-heading-anchor" href="#Decompositions-1">Decompositions</a><a class="docs-heading-anchor-permalink" href="#Decompositions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}" id="LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}"><code>LinearAlgebra.svd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svd(A::ITensor, inds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Singular value decomposition (SVD) of an ITensor <code>A</code>, computed by treating the "left indices" provided collectively as a row index, and the remaining "right indices" as a column index (matricization of a tensor).</p><p>The first three return arguments are <code>U</code>, <code>S</code>, and <code>V</code>, such that <code>A ≈ U * S * V</code>.</p><p>Whether or not the SVD performs a trunction depends on the keyword arguments provided. </p><p><strong>Arguments</strong></p><ul><li><code>maxdim::Int</code>: the maximum number of singular values to keep.</li><li><code>mindim::Int</code>: the minimum number of singular values to keep.</li><li><code>cutoff::Float64</code>: set the desired truncation error of the SVD, by default defined as the sum of the squares of the smallest singular values.</li><li><code>lefttags::String = "Link,u"</code>: set the tags of the Index shared by <code>U</code> and <code>S</code>.</li><li><code>righttags::String = "Link,v"</code>: set the tags of the Index shared by <code>S</code> and <code>V</code>.</li><li><code>alg::String = "divide_and_conquer"</code>. Options:<ul><li><code>"divide_and_conquer"</code> - A divide-and-conquer algorithm. LAPACK's gesdd. Fast, but may lead to some innacurate singular values for very ill-conditioned matrices. Also may sometimes fail to converge, leading to errors (in which case "qr_iteration" or "recursive" can be tried).</li><li><code>"qr_iteration"</code> - Typically slower but more accurate for very ill-conditioned matrices compared to <code>"divide_and_conquer"</code>. LAPACK's gesvd.</li><li><code>"recursive"</code> - ITensor's custom svd. Very reliable, but may be slow if high precision is needed. To get an <code>svd</code> of a matrix <code>A</code>, an eigendecomposition of <span>$A^{\dagger} A$</span> is used to compute <code>U</code> and then a <code>qr</code> of <span>$A^{\dagger} U$</span> is used to compute <code>V</code>. This is performed recursively to compute small singular values.</li></ul></li><li><code>use_absolute_cutoff::Bool = false</code>: set if all probability weights below the <code>cutoff</code> value should be discarded, rather than the sum of discarded weights.</li><li><code>use_relative_cutoff::Bool = true</code>: set if the singular values should be normalized for the sake of truncation.</li></ul><p>See also: <a href="ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}"><code>factorize</code></a></p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/decomp.jl#L26-L54" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}" id="LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}"><code>LinearAlgebra.factorize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factorize(A::ITensor, Linds::Index...; &lt;keyword arguments&gt;)</code></pre><p>Perform a factorization of <code>A</code> into ITensors <code>L</code> and <code>R</code> such that <code>A ≈ L * R</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ortho::String = "left"</code>: Choose orthogonality properties of the factorization.<ul><li><code>"left"</code>: the left factor <code>L</code> is an orthogonal basis such that <code>L * dag(prime(L, commonind(L,R))) ≈ I</code>. </li><li><code>"right"</code>: the right factor <code>R</code> forms an orthogonal basis. </li><li><code>"none"</code>, neither of the factors form an orthogonal basis, and in general are made as symmetrically as possible (depending on the decomposition used).</li></ul></li><li><code>which_decomp::Union{String, Nothing} = nothing</code>: choose what kind of decomposition is used. <ul><li><code>nothing</code>: choose the decomposition automatically based on the other arguments. For example, when <code>nothing</code> is chosen and <code>ortho = "left"</code> or <code>"right"</code>, and a cutoff is provided, <code>svd</code> or <code>eigen</code> is used depending on the provided cutoff (<code>eigen</code> is only used when the cutoff is greater than <code>1e-12</code>, since it has a lower precision). When no truncation is requested <code>qr</code> is used for dense ITensors and <code>svd</code> for block-sparse ITensors (in the future <code>qr</code> will be used also for block-sparse ITensors in this case).</li><li><code>"svd"</code>: <code>L = U</code> and <code>R = S * V</code> for <code>ortho = "left"</code>, <code>L = U * S</code> and <code>R = V</code> for <code>ortho = "right"</code>, and <code>L = U * sqrt.(S)</code> and <code>R = sqrt.(S) * V</code> for <code>ortho = "none"</code>. To control which <code>svd</code> algorithm is choose, use the <code>svd_alg</code> keyword argument. See the documentation for <code>svd</code> for the supported algorithms, which are the same as those accepted by the <code>alg</code> keyword argument.</li><li><code>"eigen"</code>: <code>L = U</code> and <span>$R = U^{\dagger} A$</span> where <code>U</code> is determined from the eigendecompositon <span>$A A^{\dagger} = U D U^{\dagger}$</span> for <code>ortho = "left"</code> (and vice versa for <code>ortho = "right"</code>). <code>"eigen"</code> is not supported for <code>ortho = "none"</code>.</li><li><code>"qr"</code>: <code>L=Q</code> and <code>R</code> an upper-triangular matrix when <code>ortho = "left"</code>, and <code>R = Q</code> and <code>L</code> a lower-triangular matrix when <code>ortho = "right"</code> (currently supported for dense ITensors only).</li></ul></li></ul><p>In the future, other decompositions like QR (for block-sparse ITensors), polar, cholesky, LU, etc. are expected to be supported.</p><p>For truncation arguments, see: <a href="ITensorType.html#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}"><code>svd</code></a></p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/decomp.jl#L354-L372" target="_blank">source</a></section></article><h2 id="Operations-1"><a class="docs-heading-anchor" href="#Operations-1">Operations</a><a class="docs-heading-anchor-permalink" href="#Operations-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#ITensors.permute-Tuple{ITensor,Any}" id="ITensors.permute-Tuple{ITensor,Any}"><code>ITensors.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute(T::ITensors, inds; always_copy::Bool = false)
permute(T::ITensors, inds::Index...; always_copy::Bool = false)</code></pre><p>Return a new ITensor T with indices permuted according to the input indices inds. The storage of the ITensor is permuted accordingly.</p><p>If <code>always_copy = false</code>, it avoids copying data if possible. Therefore, it may return a view. Use <code>always_copy = true</code> if you never want it to return an ITensor with a view of the original ITensor.</p></div><a class="docs-sourcelink" href="https://github.com/ITensor/ITensors.jl/blob/4172c935621f124cfb37d2eef39d2a4c2a345f46/src/itensor.jl#L1243-L1255" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="IndexSetType.html">« IndexSet</a><a class="docs-footer-nextpage" href="MPSandMPO.html">MPS and MPO »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 February 2021 16:18">Monday 1 February 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>