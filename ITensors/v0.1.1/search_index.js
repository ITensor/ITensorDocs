var documenterSearchIndex = {"docs":
[{"location":"DMRG.html#DMRG-1","page":"DMRG","title":"DMRG","text":"","category":"section"},{"location":"DMRG.html#","page":"DMRG","title":"DMRG","text":"dmrg","category":"page"},{"location":"DMRG.html#ITensors.dmrg","page":"DMRG","title":"ITensors.dmrg","text":"dmrg(H::MPO,psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, represented as a matrix product operator (MPO). The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\ndmrg(Hs::Vector{MPO},psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H. The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nThis version of dmrg accepts a representation of H as a Vector of MPOs, Hs = [H1,H2,H3,...] such that H is defined as H = H1+H2+H3+... Note that this sum of MPOs is not actually computed; rather the set of MPOs [H1,H2,H3,..] is efficiently looped over at  each step of the DMRG algorithm when optimizing the MPS.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\ndmrg(H::MPO,Ms::Vector{MPS},psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, subject to the constraint that the MPS is orthogonal to each of the MPS provided in the Vector Ms. The orthogonality constraint is approximately enforced by adding to H terms of  the form w|M1><M1| + w|M2><M2| + ... where Ms=[M1,M2,...] and w is the \"weight\" parameter, which can be adjusted through the optional weight keyword argument. The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\n","category":"function"},{"location":"QN.html#QN-1","page":"QN","title":"QN","text":"","category":"section"},{"location":"QN.html#Description-1","page":"QN","title":"Description","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"QN","category":"page"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"A QN object stores a collection of up to four named values such as (\"Sz\",1) or (\"N\",0).  These values can include a third integer \"m\" which makes them obey addition modulo m, for  example (\"P\",1,2) for a value obeying addition mod 2. (The default is regular integer addition).\n\nAdding or subtracting pairs of QN objects performs addition and subtraction element-wise on each of the named values. If a name is missing from the  collection, its value is treated as zero.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#Constructors-1","page":"QN","title":"Constructors","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"QN(qvs...)\nQN(name,val::Int,modulus::Int=1)\nQN(val::Int,modulus::Int=1)","category":"page"},{"location":"QN.html#ITensors.QN-Tuple","page":"QN","title":"ITensors.QN","text":"QN(qvs...)\n\nConstruct a QN from a set of up to four named value tuples.\n\nExamples\n\nq = QN((\"Sz\",1))\nq = QN((\"N\",1),(\"Sz\",-1))\nq = QN((\"P\",0,2),(\"Sz\",0)).\n\n\n\n\n\n","category":"method"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"QN(name,val::Int,modulus::Int=1)\n\nConstruct a QN with a single named value by providing the name, value, and optional modulus.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"QN(val::Int,modulus::Int=1)\n\nConstruct a QN with a single unnamed value (equivalent to the name being the empty string) with optional modulus.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#Properties-1","page":"QN","title":"Properties","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"val(q::QN,name)\nmodulus(q::QN,name)","category":"page"},{"location":"QN.html#ITensors.val-Tuple{QN,Any}","page":"QN","title":"ITensors.val","text":"val(q::QN,name)\n\nGet the value within the QN q corresponding to the string name\n\n\n\n\n\n","category":"method"},{"location":"QN.html#ITensors.modulus-Tuple{QN,Any}","page":"QN","title":"ITensors.modulus","text":"modulus(q::QN,name)\n\nGet the modulus within the QN q corresponding to the string name\n\n\n\n\n\n","category":"method"},{"location":"QN.html#Related-Functions-1","page":"QN","title":"Related Functions","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"zero(q::QN)","category":"page"},{"location":"QN.html#Base.zero-Tuple{QN}","page":"QN","title":"Base.zero","text":"zero(q::QN)\n\nReturns a QN object containing the same names as q, but with all values set to zero.\n\n\n\n\n\n","category":"method"},{"location":"AutoMPO.html#AutoMPO-1","page":"AutoMPO","title":"AutoMPO","text":"","category":"section"},{"location":"AutoMPO.html#Description-1","page":"AutoMPO","title":"Description","text":"","category":"section"},{"location":"AutoMPO.html#","page":"AutoMPO","title":"AutoMPO","text":"AutoMPO","category":"page"},{"location":"AutoMPO.html#ITensors.AutoMPO","page":"AutoMPO","title":"ITensors.AutoMPO","text":"An AutoMPO stores a collection of operator terms, to be later summed together into an MPO by calling the function MPO on the AutoMPO object.  Each term is a product of local operators specified by names such as \"Sz\" or \"N\", times an optional coefficient which can be real or complex.\n\nWhich local operator names are available is determined by the function op associated with the TagType defined by special Index tags, such as \"S=1/2\",\"S=1\", \"Fermion\", and \"Electron\".\n\n\n\n\n\n","category":"type"},{"location":"AutoMPO.html#Methods-1","page":"AutoMPO","title":"Methods","text":"","category":"section"},{"location":"AutoMPO.html#","page":"AutoMPO","title":"AutoMPO","text":"add!\nMPO(::AutoMPO,::Vector{<:Index})","category":"page"},{"location":"AutoMPO.html#ITensors.add!","page":"AutoMPO","title":"ITensors.add!","text":"add!(ampo::AutoMPO,\n     op1::String, i1::Int)\n\nadd!(ampo::AutoMPO,\n     coef::Number,\n     op1::String, i1::Int)\n\nadd!(ampo::AutoMPO,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\nadd!(ampo::AutoMPO,\n     coef::Number,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\n+(ampo:AutoMPO, term::Tuple)\n\nAdd a single- or multi-site operator  term to the AutoMPO ampo. Each operator is specified by a name (String) and a site number (Int). The second version accepts a real or complex coefficient.\n\nThe + operator version of this function accepts a tuple with entries either (String,Int,String,Int,...) or (Number,String,Int,String,Int,...) where these tuple values are the same as valid inputs to the add! function. For inputting a very large number of terms (tuples) to an AutoMPO, consider using the broadcasted operator .+= which avoids reallocating the AutoMPO after each addition.\n\nExamples\n\nampo = AutoMPO()\n\nadd!(ampo,\"Sz\",2,\"Sz\",3)\n\nampo += (\"Sz\",3,\"Sz\",4)\n\nampo += (0.5,\"S+\",4,\"S-\",5)\n\nampo .+= (0.5,\"S+\",5,\"S-\",6)\n\n\n\n\n\n","category":"function"},{"location":"AutoMPO.html#ITensors.MPO-Tuple{AutoMPO,Array{#s125,1} where #s125<:Index}","page":"AutoMPO","title":"ITensors.MPO","text":"MPO(ampo::AutoMPO,sites::Vector{<:Index};kwargs...)\n\nConvert an AutoMPO object ampo to an MPO, with indices given by sites. The resulting MPO will have the indices sites[1], sites[1]', sites[2], sites[2]' etc. The conversion is done by an algorithm that compresses the MPO resulting from adding the AutoMPO terms together, often achieving the minimum possible bond dimension.\n\nExamples\n\nampo = AutoMPO()\nampo += (\"Sz\",1,\"Sz\",2)\nampo += (\"Sz\",2,\"Sz\",3)\nampo += (\"Sz\",3,\"Sz\",4)\n\nsites = siteinds(\"S=1/2\",4)\nH = MPO(ampo,sites)\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"IndexType.html#Description-1","page":"Index","title":"Description","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"Index\nITensors.QNIndex","category":"page"},{"location":"IndexType.html#ITensors.Index","page":"Index","title":"ITensors.Index","text":"An Index represents a single tensor index with fixed dimension dim. Copies of an Index compare equal unless their  tags are different.\n\nAn Index carries a TagSet, a set of tags which are small strings that specify properties of the Index to help  distinguish it from other Indices. There is a special tag which is referred to as the integer tag or prime  level which can be incremented or decremented with special priming functions.\n\nInternally, an Index has a fixed id number, which is how the ITensor library knows two indices are copies of a  single original Index. Index objects must have the same id, as well as the tags to compare equal.\n\n\n\n\n\n","category":"type"},{"location":"IndexType.html#ITensors.QNIndex","page":"Index","title":"ITensors.QNIndex","text":"A QN Index is an Index with QN block storage instead of just an integer dimension. The QN block storage is a  vector of pairs of QNs and block dimensions. The total dimension of a QN Index is the sum of the dimensions of the blocks of the Index.\n\n\n\n\n\n","category":"type"},{"location":"IndexType.html#Constructors-1","page":"Index","title":"Constructors","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"Index(::Int)\nIndex(::Int, ::Union{AbstractString, TagSet})\nIndex(::Pair{QN, Int}...)\nIndex(::Vector{Pair{QN, Int}})\nIndex(::Vector{Pair{QN, Int}}, ::Union{AbstractString, TagSet})","category":"page"},{"location":"IndexType.html#ITensors.Index-Tuple{Int64}","page":"Index","title":"ITensors.Index","text":"Index(dim::Int; tags::Union{AbstractString, TagSet} = \"\",\n                plev::Int = 0)\n\nCreate an Index with a unique id, a TagSet given by tags, and a prime level plev.\n\nExamples\n\njulia> i = Index(2; tags = \"l\", plev = 1)\n(dim=2|id=818|\"l\")'\n\njulia> dim(i)\n2\n\njulia> plev(i)\n1\n\njulia> tags(i)\n\"l\"\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Int64,Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.Index","text":"Index(dim::Integer, tags::Union{AbstractString, TagSet}; plev::Int = 0)\n\nCreate an Index with a unique id and a tagset given by tags.\n\nExamples\n\njulia> i = Index(2, \"l,tag\")\n(dim=2|id=58|\"l,tag\")\n\njulia> dim(i)\n2\n\njulia> plev(i)\n0\n\njulia> tags(i)\n\"l,tag\"\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Vararg{Pair{QN,Int64},N} where N}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Pair{QN, Int64}...; dir::Arrow = Out,\n                                    tags = \"\",\n                                    plev::Int = 0)\n\nConstruct a QN Index from a list of pairs of QN and block  dimensions.\n\nExample\n\nIndex(QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1; tags = \"i\")\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Array{Pair{QN,Int64},1}}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Vector{Pair{QN, Int64}}; dir::Arrow = Out,\n                                         tags = \"\",\n                                         plev::Int = 0)\n\nConstruct a QN Index from a Vector of pairs of QN and block  dimensions.\n\nNote: in the future, this may enforce that all blocks have the same QNs (which would allow for some optimizations, for example when constructing random QN ITensors).\n\nExample\n\nIndex([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1]; tags = \"i\")\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Array{Pair{QN,Int64},1},Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Vector{Pair{QN, Int64}}, tags; dir::Arrow = Out,\n                                               plev::Int = 0)\n\nConstruct a QN Index from a Vector of pairs of QN and block  dimensions.\n\nExample\n\nIndex([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1], \"i\"; dir = In)\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Properties-1","page":"Index","title":"Properties","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"id(::Index)\nhasid(::Index, ::ITensors.IDType)\ntags(::Index)\nhastags(::Index, ::Union{AbstractString,TagSet})\nplev(::Index)\nhasplev(::Index, ::Int)\ndim(::Index)\n==(::Index, ::Index)\ndir(::Index)\nhasqns(::Index)","category":"page"},{"location":"IndexType.html#ITensors.id-Tuple{Index}","page":"Index","title":"ITensors.id","text":"id(i::Index)\n\nObtain the id of an Index, which is a unique 64 digit integer.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasid-Tuple{Index,UInt64}","page":"Index","title":"ITensors.hasid","text":"hasid(i::Index, id::ITensors.IDType)\n\nCheck if an Index i has the provided id.\n\nExamples\n\njulia> i = Index(2)\n(dim=2|id=321)\n\njulia> hasid(i, id(i))\ntrue\n\njulia> j = Index(2)\n(dim=2|id=17)\n\njulia> hasid(i, id(j))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.tags-Tuple{Index}","page":"Index","title":"ITensors.tags","text":"tags(i::Index)\n\nObtain the TagSet of an Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hastags-Tuple{Index,Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.hastags","text":"hastags(i::Index, ts::Union{AbstractString,TagSet})\n\nCheck if an Index i has the provided tags, which can be a string of comma-separated tags or  a TagSet object.\n\nExamples\n\njulia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=861|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"SpinHalf,Site\")\ntrue\n\njulia> hastags(i, \"Link\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.plev-Tuple{Index}","page":"Index","title":"ITensors.plev","text":"plev(i::Index)\n\nObtain the prime level of an Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasplev-Tuple{Index,Int64}","page":"Index","title":"ITensors.hasplev","text":"hasplev(i::Index, plev::Int)\n\nCheck if an Index i has the provided prime level.\n\nExamples\n\njulia> i = Index(2; plev=2)\n(dim=2|id=543)''\n\njulia> hasplev(i, 2)\ntrue\n\njulia> hasplev(i, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#NDTensors.dim-Tuple{Index}","page":"Index","title":"NDTensors.dim","text":"dim(i::Index)\n\nObtain the dimension of an Index.\n\nFor a QN Index, this is the sum of the block dimensions.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.:==-Tuple{Index,Index}","page":"Index","title":"Base.:==","text":"==(i1::Index, i1::Index)\n\nCompare indices for equality. First the id's are compared, then the prime levels are compared, and finally the tags are compared.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.dir-Tuple{Index}","page":"Index","title":"ITensors.dir","text":"dir(i::Index)\n\nObtain the direction of an Index (In, Out, or Neither).\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasqns-Tuple{Index}","page":"Index","title":"ITensors.hasqns","text":"hasqns(::Index)\n\nChecks of the Index has QNs or not.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Priming-and-tagging-methods-1","page":"Index","title":"Priming and tagging methods","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"prime(::Index, ::Int)\nadjoint(::Index)\n^(::Index, ::Int)\nsetprime(::Index, ::Int)\nnoprime(::Index)\nsettags(::Index, ::Any)\naddtags(::Index, ::Any)\nremovetags(::Index, ::Any)\nreplacetags(::Index, ::Any, ::Any)","category":"page"},{"location":"IndexType.html#ITensors.prime-Tuple{Index,Int64}","page":"Index","title":"ITensors.prime","text":"prime(i::Index, plinc::Int = 1)\n\nReturn a copy of Index i with its prime level incremented by the amount plinc\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.adjoint-Tuple{Index}","page":"Index","title":"Base.adjoint","text":"adjoint(i::Index)\n\nPrime an Index using the notation i'.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.:^-Tuple{Index,Int64}","page":"Index","title":"Base.:^","text":"^(i::Index, pl::Int)\n\nPrime an Index using the notation i^3.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.setprime-Tuple{Index,Int64}","page":"Index","title":"ITensors.setprime","text":"setprime(i::Index, plev::Int)\n\nReturn a copy of Index i with its prime level set to plev\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.noprime-Tuple{Index}","page":"Index","title":"ITensors.noprime","text":"noprime(i::Index)\n\nReturn a copy of Index i with its prime level set to zero.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.settags-Tuple{Index,Any}","page":"Index","title":"ITensors.settags","text":"settags(i::Index, ts)\n\nReturn a copy of Index i with tags replaced by the ones given The ts argument can be a comma-separated  string of tags or a TagSet.\n\nExamples\n\njulia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=543|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"Link\")\nfalse\n\njulia> j = settags(i,\"Link,n=4\")\n(dim=2|id=543|\"Link,n=4\")\n\njulia> hastags(j, \"Link\")\ntrue\n\njulia> hastags(j, \"n=4,Link\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.addtags-Tuple{Index,Any}","page":"Index","title":"ITensors.addtags","text":"addtags(i::Index,ts)\n\nReturn a copy of Index i with the specified tags added to the existing ones. The ts argument can be a comma-separated  string of tags or a TagSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.removetags-Tuple{Index,Any}","page":"Index","title":"ITensors.removetags","text":"removetags(i::Index, ts)\n\nReturn a copy of Index i with the specified tags removed. The ts argument can be a comma-separated string of tags or a TagSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.replacetags-Tuple{Index,Any,Any}","page":"Index","title":"ITensors.replacetags","text":"replacetags(i::Index, tsold, tsnew)\n\nIf the tag set of i contains the tags specified by tsold, replaces these with the tags specified by tsnew, preserving any other tags. The arguments tsold and tsnew can be comma-separated strings of tags, or TagSet objects.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Methods-1","page":"Index","title":"Methods","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"sim(::Index)\ndag(::Index)\nremoveqns(::Index)","category":"page"},{"location":"IndexType.html#ITensors.sim-Tuple{Index}","page":"Index","title":"ITensors.sim","text":"sim(i::Index; tags = tags(i), plev = plev(i), dir = dir(i))\n\nProduces an Index with the same properties (dimension or QN structure) but with a new id.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.dag-Tuple{Index}","page":"Index","title":"ITensors.dag","text":"dag(i::Index)\n\nCopy an index i and reverse its direction.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.removeqns-Tuple{Index}","page":"Index","title":"ITensors.removeqns","text":"removeqns(::Index)\n\nRemoves the QNs from the Index, if it has any.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Iterating-1","page":"Index","title":"Iterating","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"iterate(::Index)","category":"page"},{"location":"IndexType.html#Base.iterate-Tuple{Index}","page":"Index","title":"Base.iterate","text":"Iterating over Index I gives the IndexVals I(1) through I(dim(I)).\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPS-and-MPO-1","page":"MPS and MPO","title":"MPS and MPO","text":"","category":"section"},{"location":"MPSandMPO.html#Types-1","page":"MPS and MPO","title":"Types","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPS\nMPO","category":"page"},{"location":"MPSandMPO.html#ITensors.MPS","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS\n\nA finite size matrix product state type. Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#ITensors.MPO","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO\n\nA finite size matrix product operator type.  Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#MPS-Constructors-1","page":"MPS and MPO","title":"MPS Constructors","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPS(::Int)\nMPS(::Type{<:Number}, ::Vector{<:Index})\nrandomMPS(sites::Vector{<:Index}; linkdim=1)\nrandomMPS(::Type{<:Number}, sites::Vector{<:Index}; linkdim=1)\nrandomMPS(sites::Vector{<:Index}, state; linkdim=1)\nproductMPS(::Vector{<:Index},states)\nproductMPS(::Type{<:Number},::Vector{<:Index},states)\nproductMPS(::Vector{<:IndexVal})\nproductMPS(::Type{<:Number}, ::Vector{<:IndexVal})","category":"page"},{"location":"MPSandMPO.html#ITensors.MPS-Tuple{Int64}","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS(N::Int)\n\nConstruct an MPS with N sites with default constructed ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPS-Tuple{Type{#s125} where #s125<:Number,Array{#s124,1} where #s124<:Index}","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS([::Type{ElT} = Float64, ]sites)\n\nConstruct an MPS filled with Empty ITensors of type ElT from a collection of indices.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Array{#s125,1} where #s125<:Index}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(sites::Vector{<:Index}; linkdim=1)\n\nConstruct a random MPS with link dimension linkdim of  type Float64.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Type{#s125} where #s125<:Number,Array{#s124,1} where #s124<:Index}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(::Type{ElT<:Number}, sites::Vector{<:Index}; linkdim=1)\n\nConstruct a random MPS with link dimension linkdim of  type ElT.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Array{#s125,1} where #s125<:Index,Any}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(sites::Vector{<:Index}, state; linkdim=1)\n\nConstruct a real, random MPS with link dimension linkdim, made by randomizing an initial product state specified by state. This version of randomMPS is necessary when creating QN-conserving random MPS (consisting of QNITensors). The initial state array provided determines the total QN of the resulting random MPS.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Array{#s125,1} where #s125<:Index,Any}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(sites::Vector{<:Index},states)\n\nConstruct a product state MPS having site indices sites, and which corresponds to the initial state given by the array states. The states array may consist of either an array of integers or strings, as  recognized by the state function defined for the relevant Index tag type.\n\n#Examples\n\nN = 10\nsites = siteinds(\"S=1/2\",N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi = productMPS(sites,states)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Type{#s125} where #s125<:Number,Array{#s124,1} where #s124<:Index,Any}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(::Type{T},sites::Vector{<:Index},states)\n\nConstruct a product state MPS of element type T, having site indices sites, and which corresponds to the initial state given by the array states. The states array may consist of either an array of integers or strings, as  recognized by the state function defined for the relevant Index tag type.\n\n#Examples\n\nN = 10\nsites = siteinds(\"S=1/2\",N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi = productMPS(ComplexF64,sites,states)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Array{#s125,1} where #s125<:IndexVal}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(ivals::Vector{<:IndexVal})\n\nConstruct a product state MPS with element type Float64 and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Type{#s125} where #s125<:Number,Array{#s124,1} where #s124<:IndexVal}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(::Type{T<:Number}, ivals::Vector{<:IndexVal})\n\nConstruct a product state MPS with element type T and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPO-Constructors-1","page":"MPS and MPO","title":"MPO Constructors","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPO(::Int)\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::Vector{String})\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::String)","category":"page"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Int64}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO(N::Int)\n\nMake an MPO of length N filled with default ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Type{#s125} where #s125<:Number,Array{#s124,1} where #s124<:Index,Array{String,1}}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO([::Type{ElT} = Float64}, ]sites, ops::Vector{String})\n\nMake an MPO with pairs of sites s[i] and s[i]' and operators ops on each site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Type{#s125} where #s125<:Number,Array{#s124,1} where #s124<:Index,String}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO([::Type{ElT} = Float64, ]sites, op::String)\n\nMake an MPO with pairs of sites s[i] and s[i]' and operator op on every site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Properties-1","page":"MPS and MPO","title":"Properties","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"length(::ITensors.AbstractMPS)\nmaxlinkdim(::ITensors.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#Base.length-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"Base.length","text":"length(::MPS/MPO)\n\nThe number of sites of an MPS/MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.maxlinkdim-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.maxlinkdim","text":"maxlinkdim(M::MPS)\n\nmaxlinkdim(M::MPO)\n\nGet the maximum link dimension of the MPS or MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Priming-and-tagging-1","page":"MPS and MPO","title":"Priming and tagging","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"prime(::ITensors.AbstractMPS)\nprime!(::ITensors.AbstractMPS)\nsetprime(::ITensors.AbstractMPS)\nsetprime!(::ITensors.AbstractMPS)\nnoprime(::ITensors.AbstractMPS)\nnoprime!(::ITensors.AbstractMPS)\naddtags(::ITensors.AbstractMPS)\naddtags!(::ITensors.AbstractMPS)\nremovetags(::ITensors.AbstractMPS)\nremovetags!(::ITensors.AbstractMPS)\nreplacetags(::ITensors.AbstractMPS)\nreplacetags!(::ITensors.AbstractMPS)\nsettags(::ITensors.AbstractMPS)\nsettags!(::ITensors.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime(M::MPS, args...; kwargs...)\n\nprime(M::MPO, args...; kwargs...)\n\nApply prime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.prime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime!","text":"prime!(M::MPS, args...; kwargs...)\n\nprime!(M::MPO, args...; kwargs...)\n\nApply prime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime(M::MPS, args...; kwargs...)\n\nsetprime(M::MPO, args...; kwargs...)\n\nApply setprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime!","text":"setprime!(M::MPS, args...; kwargs...)\n\nsetprime!(M::MPO, args...; kwargs...)\n\nApply setprime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime(M::MPS, args...; kwargs...)\n\nnoprime(M::MPO, args...; kwargs...)\n\nApply noprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime!","text":"noprime!(M::MPS, args...; kwargs...)\n\nnoprime!(M::MPO, args...; kwargs...)\n\nApply noprime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.addtags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.addtags","text":"addtags(M::MPS, args...; kwargs...)\n\naddtags(M::MPO, args...; kwargs...)\n\nApply addtags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.addtags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.addtags!","text":"addtags!(M::MPS, args...; kwargs...)\n\naddtags!(M::MPO, args...; kwargs...)\n\nApply addtags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.removetags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.removetags","text":"removetags(M::MPS, args...; kwargs...)\n\nremovetags(M::MPO, args...; kwargs...)\n\nApply removetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.removetags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.removetags!","text":"removetags!(M::MPS, args...; kwargs...)\n\nremovetags!(M::MPO, args...; kwargs...)\n\nApply removetags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.replacetags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.replacetags","text":"replacetags(M::MPS, args...; kwargs...)\n\nreplacetags(M::MPO, args...; kwargs...)\n\nApply replacetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.replacetags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.replacetags!","text":"replacetags!(M::MPS, args...; kwargs...)\n\nreplacetags!(M::MPO, args...; kwargs...)\n\nApply replacetags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags(M::MPS, args...; kwargs...)\n\nsettags(M::MPO, args...; kwargs...)\n\nApply settags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags!","text":"settags!(M::MPS, args...; kwargs...)\n\nsettags!(M::MPO, args...; kwargs...)\n\nApply settags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Operations-1","page":"MPS and MPO","title":"Operations","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"dag(::ITensors.AbstractMPS)\ndag!(::ITensors.AbstractMPS)\northogonalize!\ntruncate!\nreplacebond!(::MPS, ::Int, ::ITensor)\nsample(::MPS)\nsample!(::MPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.dag-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.dag","text":"dag(M::MPS, args...; kwargs...)\n\ndag(M::MPO, args...; kwargs...)\n\nApply dag to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.dag!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.dag!","text":"dag!(M::MPS, args...; kwargs...)\n\ndag!(M::MPO, args...; kwargs...)\n\nApply dag to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.orthogonalize!","page":"MPS and MPO","title":"ITensors.orthogonalize!","text":"orthogonalize!(M::MPS, j::Int; kwargs...)\n\northogonalize!(M::MPO, j::Int; kwargs...)\n\nMove the orthogonality center of the MPS to site j. No observable property of the MPS will be changed, and no truncation of the bond indices is performed. Afterward, tensors 1,2,...,j-1 will be left-orthogonal and tensors j+1,j+2,...,N will be right-orthogonal.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#NDTensors.truncate!","page":"MPS and MPO","title":"NDTensors.truncate!","text":"truncate!(M::MPS; kwargs...)\n\ntruncate!(M::MPO; kwargs...)\n\nPerform a truncation of all bonds of an MPS/MPO, using the truncation parameters (cutoff,maxdim, etc.) provided as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensors.replacebond!-Tuple{MPS,Int64,ITensor}","page":"MPS and MPO","title":"ITensors.replacebond!","text":"replacebond!(M::MPS, b::Int, phi::ITensor; kwargs...)\n\nFactorize the ITensor phi and replace the ITensors b and b+1 of MPS M with the factors. Choose the orthogonality with ortho=\"left\"/\"right\".\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.sample-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.sample","text":"sample(m::MPS)\n\nGiven a normalized MPS m with orthocenter(m)==1, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.sample!-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.sample!","text":"sample!(m::MPS)\n\nGiven a normalized MPS m, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents. If the MPS does not have an orthogonality center, orthogonalize!(m,1) will be called before computing the sample.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Algebra-Operations-1","page":"MPS and MPO","title":"Algebra Operations","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"dot(::MPS, ::MPS)\n+(::MPS, ::MPS)\n+(::MPO, ::MPO)\n*(::MPO, ::MPS)","category":"page"},{"location":"MPSandMPO.html#LinearAlgebra.dot-Tuple{MPS,MPS}","page":"MPS and MPO","title":"LinearAlgebra.dot","text":"dot(psi::MPS, phi::MPS; make_inds_match = true)\ninner(psi::MPS, phi::MPS; make_inds_match = true)\n\nCompute <psi|phi>.\n\nIf make_inds_match = true, the function attempts to make the site indices match before contracting (so for example, the inputs can have different site indices, as long as they  have the same dimensions or QN blocks).\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:+-Tuple{MPS,MPS}","page":"MPS and MPO","title":"Base.:+","text":"add(A::MPS, B::MPS; kwargs...)\n+(A::MPS, B::MPS; kwargs...)\n\nadd(A::MPO, B::MPO; kwargs...)\n+(A::MPO, B::MPO; kwargs...)\n\nAdd two MPS/MPO with each other, with some optional truncation.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:+-Tuple{MPO,MPO}","page":"MPS and MPO","title":"Base.:+","text":"add(A::MPS, B::MPS; kwargs...)\n+(A::MPS, B::MPS; kwargs...)\n\nadd(A::MPO, B::MPO; kwargs...)\n+(A::MPO, B::MPO; kwargs...)\n\nAdd two MPS/MPO with each other, with some optional truncation.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:*-Tuple{MPO,MPS}","page":"MPS and MPO","title":"Base.:*","text":"contract(::MPS, ::MPO; kwargs...)\n*(::MPS, ::MPO; kwargs...)\n\ncontract(::MPO, ::MPS; kwargs...)\n*(::MPO, ::MPS; kwargs...)\n\nContract the MPO with the MPS, returning an MPS with the unique site indices of the MPO.\n\nChoose the method with the method keyword, for example \"densitymatrix\" and \"naive\".\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ProjMPO-1","page":"ProjMPO","title":"ProjMPO","text":"","category":"section"},{"location":"ProjMPO.html#Description-1","page":"ProjMPO","title":"Description","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"ProjMPO","category":"page"},{"location":"ProjMPO.html#ITensors.ProjMPO","page":"ProjMPO","title":"ITensors.ProjMPO","text":"A ProjMPO computes and stores the projection of an MPO into a basis defined by an MPS, leaving a certain number of site indices of the MPO unprojected. Which sites are unprojected can be shifted by calling the position! method.\n\nDrawing of the network represented by a ProjMPO P(H),  showing the case of nsite(P)==2 and position!(P,psi,4)  for an MPS psi:\n\no--o--o-      -o--o--o--o--o--o <psi|\n|  |  |  |  |  |  |  |  |  |  |\no--o--o--o--o--o--o--o--o--o--o H\n|  |  |  |  |  |  |  |  |  |  |\no--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPO.html#Methods-1","page":"ProjMPO","title":"Methods","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"product(::ProjMPO,::ITensor)\nposition!(::ProjMPO, ::MPS, ::Int)\nnoiseterm(::ProjMPO,::ITensor,::String)","category":"page"},{"location":"ProjMPO.html#ITensors.product-Tuple{ProjMPO,ITensor}","page":"ProjMPO","title":"ITensors.product","text":"product(P::ProjMPO,v::ITensor)\n\n(P::ProjMPO)(v::ITensor)\n\nEfficiently multiply the ProjMPO P by an ITensor v in the sense that the ProjMPO is a generalized square matrix  or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensors.position!-Tuple{ProjMPO,MPS,Int64}","page":"ProjMPO","title":"ITensors.position!","text":"position!(P::ProjMPO, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPO P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPO on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensors.noiseterm-Tuple{ProjMPO,ITensor,String}","page":"ProjMPO","title":"ITensors.noiseterm","text":"noiseterm(P::ProjMPO,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the  ProjMPO P, and ortho is a String which can take the values \"left\" or \"right\" depending on the  sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Properties-1","page":"ProjMPO","title":"Properties","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"length(::ProjMPO)\neltype(::ProjMPO)\nsize(::ProjMPO)","category":"page"},{"location":"ProjMPO.html#Base.length-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.length","text":"length(P::ProjMPO)\n\nThe length of a ProjMPO is the same as the length of the MPO used to construct it\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.eltype-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.eltype","text":"eltype(P::ProjMPO)\n\nDeduce the element type (such as Float64 or ComplexF64) of the tensors in the ProjMPO P.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.size-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.size","text":"size(P::ProjMPO)\n\nThe size of a ProjMPO are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d. \n\nFor example, if a ProjMPO maps from a space with  indices (a,s1,s2,b) to the space (a',s1',s2',b')  then the size is (d,d) where  d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ProjMPOSum-1","page":"ProjMPOSum","title":"ProjMPOSum","text":"","category":"section"},{"location":"ProjMPOSum.html#Description-1","page":"ProjMPOSum","title":"Description","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"ProjMPOSum","category":"page"},{"location":"ProjMPOSum.html#ITensors.ProjMPOSum","page":"ProjMPOSum","title":"ITensors.ProjMPOSum","text":"A ProjMPOSum computes and stores the projection of an implied sum of MPOs into a basis defined by an MPS,  leaving a certain number of site indices of each MPO  unprojected. Which sites are unprojected can be shifted  by calling the position! method. The MPOs used as  input to a ProjMPOSum are not added together beforehand; instead when the product method of a ProjMPOSum is invoked, each projected MPO in the set of MPOs is multiplied by the input tensor one-by-one in an efficient way.\n\nDrawing of the network represented by a ProjMPOSum  P([H1,H2,...]), showing the case of nsite(P)==2  and position!(P,psi,4) for an MPS psi (note the sum Σⱼ on the left):\n\n     o--o--o-      -o--o--o--o--o--o <psi|\n     |  |  |  |  |  |  |  |  |  |  |\n Σⱼ  o--o--o--o--o--o--o--o--o--o--o Hⱼ\n     |  |  |  |  |  |  |  |  |  |  |\n     o--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPOSum.html#Methods-1","page":"ProjMPOSum","title":"Methods","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"product(::ProjMPOSum,::ITensor)\nposition!(::ProjMPOSum, ::MPS, ::Int)\nnoiseterm(::ProjMPOSum,::ITensor,::String)","category":"page"},{"location":"ProjMPOSum.html#ITensors.product-Tuple{ProjMPOSum,ITensor}","page":"ProjMPOSum","title":"ITensors.product","text":"product(P::ProjMPOSum,v::ITensor)\n\n(P::ProjMPOSum)(v::ITensor)\n\nEfficiently multiply the ProjMPOSum P by an ITensor v in the sense that the ProjMPOSum is a generalized square matrix  or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensors.position!-Tuple{ProjMPOSum,MPS,Int64}","page":"ProjMPOSum","title":"ITensors.position!","text":"position!(P::ProjMPOSum, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPOSum P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPOs on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensors.noiseterm-Tuple{ProjMPOSum,ITensor,String}","page":"ProjMPOSum","title":"ITensors.noiseterm","text":"noiseterm(P::ProjMPOSum,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the  ProjMPOSum P, and ortho is a String which can take the values \"left\" or \"right\" depending on the  sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Properties-1","page":"ProjMPOSum","title":"Properties","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"length(::ProjMPOSum)\neltype(::ProjMPOSum)\nsize(::ProjMPOSum)","category":"page"},{"location":"ProjMPOSum.html#Base.length-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.length","text":"length(is::IndexSet)\n\nThe number of indices in the IndexSet.\n\n\n\n\n\nlength(::Type{<:IndexSet})\n\nThe number of indices in the IndexSet type.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Base.eltype-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.eltype","text":"eltype(::IndexSet)\n\nGet the element type of the IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Base.size-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.size","text":"size(P::ProjMPOSum)\n\nThe size of a ProjMPOSum are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d. \n\nFor example, if a ProjMPOSum maps from a space with  indices (a,s1,s2,b) to the space (a',s1',s2',b')  then the size is (d,d) where  d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensor-1","page":"ITensor","title":"ITensor","text":"","category":"section"},{"location":"ITensorType.html#Description-1","page":"ITensor","title":"Description","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor","category":"page"},{"location":"ITensorType.html#ITensors.ITensor","page":"ITensor","title":"ITensors.ITensor","text":"An ITensor is a tensor whose interface is  independent of its memory layout. Therefore it is not necessary to know the ordering of an ITensor's indices, only which indices an ITensor has. Operations like contraction and addition of ITensors automatically handle any memory permutations.\n\n\n\n\n\n","category":"type"},{"location":"ITensorType.html#Dense-Constructors-1","page":"ITensor","title":"Dense Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor(::Type{<:Number}, ::ITensors.Indices)\nITensor(::Type{<:Number}, ::UndefInitializer, ::ITensors.Indices)\nrandomITensor(::Type{<:Number}, ::ITensors.Indices)\nsetelt(::IndexVal)","category":"page"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s125} where #s125<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ]inds)\nITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor filled with zeros having indices inds and element type ElT. If the element type is not specified, it defaults to Float64.\n\nThe storage will have NDTensors.Dense type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s125} where #s125<:Number,UndefInitializer,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)\nITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...)\n\nConstruct an ITensor filled with undefined elements having indices inds and element type ElT. If the element type is not specified, it defaults to Float64.\n\nThe storage will have NDTensors.Dense type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.randomITensor-Tuple{Type{#s125} where #s125<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.randomITensor","text":"randomITensor([::Type{ElT <: Number} = Float64, ]inds)\n\nrandomITensor([::Type{ElT <: Number} = Float64, ]inds::Index...)\n\nConstruct an ITensor with type ElT and indices inds, whose elements are normally distributed random numbers. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.setelt-Tuple{IndexVal}","page":"ITensor","title":"ITensors.setelt","text":"setelt(iv)\n\nCreate an ITensor with all zeros except the specified value, which is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-BlockSparse-Constructors-1","page":"ITensor","title":"QN BlockSparse Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor(::Type{<:Number}, ::QN, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s125} where #s125<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds)\nITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds::Index...)\n\nConstruct an ITensor with BlockSparse storage filled with zero(ElT) where the nonzero blocks are determined by flux.\n\nIf ElT is not specified it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Empty-Constructors-1","page":"ITensor","title":"Empty Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"emptyITensor(::Type{<:Number}, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.emptyITensor-Tuple{Type{#s125} where #s125<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.emptyITensor","text":"emptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor with storage type NDTensors.Empty, indices inds, and element type ElT. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-Empty-Constructors-1","page":"ITensor","title":"QN Empty Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"emptyITensor(::Type{<:Number}, ::ITensors.QNIndices)","category":"page"},{"location":"ITensorType.html#ITensors.emptyITensor-Tuple{Type{#s125} where #s125<:Number,Union{Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}, IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}}} where N}","page":"ITensor","title":"ITensors.emptyITensor","text":"emptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor with storage type NDTensors.Empty, indices inds, and element type ElT. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\nemptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::QNIndex...)\n\nConstruct an ITensor with NDTensors.BlockSparse storage of element type ElT with the no blocks.\n\nIf ElT is not specified it defaults to Float64.\n\nIn the future, this will use the storage NDTensors.EmptyBlockSparse.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Diagonal-constructors-1","page":"ITensor","title":"Diagonal constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"diagITensor(::Type{<:Number}, ::ITensors.Indices)\ndiagITensor(::Vector{<:Number}, ::ITensors.Indices)\ndiagITensor(::Number, ::ITensors.Indices)\ndelta(::Type{<:Number}, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Type{#s125} where #s125<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor([::Type{ElT} = Float64, ]inds)\ndiagITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nMake a sparse ITensor of element type ElT with only elements along the diagonal stored. Defaults to having zero(T) along  the diagonal.\n\nThe storage will have NDTensors.Diag type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Array{#s125,1} where #s125<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor(v::Vector{T}, inds)\ndiagITensor(v::Vector{T}, inds::Index...)\n\nMake a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the values stored in v and  the ITensor will have element type float(T). The storage will have type NDTensors.Diag.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor(x::Number, inds)\ndiagITensor(x::Number, inds::Index...)\n\nMake a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the value float(x) and the ITensor will have element type float(eltype(x)). The storage will have NDTensors.Diag type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.delta-Tuple{Type{#s125} where #s125<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.delta","text":"delta([::Type{ElT} = Float64, ]inds)\ndelta([::Type{ElT} = Float64, ]inds::Index...)\n\nMake a uniform diagonal ITensor with all diagonal elements one(ElT). Only a single diagonal element is stored.\n\nThis function has an alias δ.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-Diagonal-constructors-1","page":"ITensor","title":"QN Diagonal constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"diagITensor(::Type{<:Number}, ::QN, ::ITensors.Indices)\ndelta(::Type{<:Number}, ::QN, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Type{#s125} where #s125<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndiagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)\n\nMake an ITensor with storage type NDTensors.DiagBlockSparse with elements zero(ElT). The ITensor only has diagonal blocks consistent with the specified flux.\n\nIf the element type is not specified, it defaults to Float64. If theflux is not specified, it defaults to QN().\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.delta-Tuple{Type{#s125} where #s125<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.delta","text":"delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndelta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)\n\nMake an ITensor with storage type NDTensors.DiagBlockSparse with uniform elements one(ElT). The ITensor only has diagonal blocks consistent with the specified flux.\n\nIf the element type is not specified, it defaults to Float64. If theflux is not specified, it defaults to QN().\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Getting-and-setting-elements-1","page":"ITensor","title":"Getting and setting elements","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"getindex(::ITensor, ::Any...)\ngetindex(::ITensor{N}, ::Vararg{Int,N}) where {N}\nsetindex!(::ITensor, ::Number, ::Any...)\nsetindex!(::ITensor, ::Number, ::Int...)","category":"page"},{"location":"ITensorType.html#Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"Base.getindex","text":"getindex(T::ITensor, ivs...)\n\nGet the specified element of the ITensor, using a list of IndexVals or Pair{<:Index, Int}.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(2.0, i, i')\nA[i => 1, i' => 2] # 2.0, same as: A[i' => 2, i => 1]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N","page":"ITensor","title":"Base.getindex","text":"getindex(T::ITensor, I::Int...)\n\nGet the specified element of the ITensor, using internal Index ordering of the ITensor.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(2.0, i, i')\nA[1, 2] # 2.0, same as: A[i => 1, i' => 2]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}","page":"ITensor","title":"Base.setindex!","text":"setindex!(T::ITensor, x::Number, ivs...)\n\nSet the specified element of the ITensor using a list of IndexVals or Pair{<:Index, Int}.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(i, i')\nA[i => 1, i' => 2] = 1.0 # same as: A[i' => 2, i => 1] = 1.0\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}","page":"ITensor","title":"Base.setindex!","text":"setindex!(T::ITensor, x::Number, I::Int...)\n\nSet the specified element of the ITensor, using internal Index ordering of the ITensor.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(i, i')\nA[1, 2] = 1.0 # same as: A[i => 1, i' => 2] = 1.0\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Properties-1","page":"ITensor","title":"Properties","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"inds(::ITensor)\nind(::ITensor, ::Int)","category":"page"},{"location":"ITensorType.html#NDTensors.inds-Tuple{ITensor}","page":"ITensor","title":"NDTensors.inds","text":"inds(T::ITensor)\n\nReturn the indices of the ITensor as an IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.ind-Tuple{ITensor,Int64}","page":"ITensor","title":"NDTensors.ind","text":"ind(T::ITensor, i::Int)\n\nGet the Index of the ITensor along dimension i.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Priming-and-tagging-1","page":"ITensor","title":"Priming and tagging","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"prime(::ITensor, ::Any...)\nsetprime(::ITensor, ::Any...)\nnoprime(::ITensor, ::Any...)\nmapprime(::ITensor, ::Any...)\nswapprime(::ITensor, ::Any...)\naddtags(::ITensor, ::Any...)\nremovetags(::ITensor, ::Any...)\nreplacetags(::ITensor, ::Any...)\nsettags(::ITensor, ::Any...)\nswaptags(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.prime","text":"prime(A::ITensor, plinc::Int = 1; <keyword arguments>) -> ITensor\n\nprime!(A::ITensor, plinc::Int = 1; <keyword arguments>)\n\nIncrease the prime level of the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.setprime","text":"setprime(A::ITensor, plev::Int; <keyword arguments>) -> ITensor\n\nsetprime!(A::ITensor, plev::Int; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.noprime","text":"noprime(A::ITensor; <keyword arguments>) -> ITensor\n\nnoprime!(A::ITensor; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor to zero.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.mapprime","text":"mapprime(A::ITensor, plold::Int, plnew::Int; <keyword arguments>) -> ITensor\n\nmapprime!(A::ITensor, plold::Int, plnew::Int; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor with prime level plold to plnew.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapprime","text":"swapprime(A::ITensor, pl1::Int, pl2::Int; <keyword arguments>) -> ITensor\n\nswapprime!(A::ITensor, pl1::Int, pl2::Int; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor with prime level pl1 to pl2, and those with prime level pl2 to pl1.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.addtags","text":"addtags(A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\naddtags!(A::ITensor, ts::String; <keyword arguments>)\n\nAdd the tags ts to the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.removetags","text":"removetags(A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nremovetags!(A::ITensor, ts::String; <keyword arguments>)\n\nRemove the tags ts from the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replacetags","text":"replacetags(A::ITensor, tsold::String, tsnew::String; <keyword arguments>) -> ITensor\n\nreplacetags!(A::ITensor, tsold::String, tsnew::String; <keyword arguments>)\n\nReplace the tags tsold with tsnew for the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.settags","text":"settags(A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nsettags!(A::ITensor, ts::String; <keyword arguments>)\n\nSet the tags of the indices of an ITensor to ts.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swaptags","text":"swaptags(A::ITensor, ts1::String, ts2::String; <keyword arguments>) -> ITensor\n\nswaptags!(A::ITensor, ts1::String, ts2::String; <keyword arguments>)\n\nSwap the tags ts1 with ts2 for the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Index-Manipulations-1","page":"ITensor","title":"Index Manipulations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"replaceind(::ITensor, ::Any...)\nreplaceinds(::ITensor, ::Any...)\nswapind(::ITensor, ::Any...)\nswapinds(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replaceind","text":"replaceind(A::ITensor, i1::Index, i2::Index) -> ITensor\n\nreplaceind!(A::ITensor, i1::Index, i2::Index)\n\nReplace the Index i1 with the Index i2 in the ITensor.\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replaceinds","text":"replaceinds(A::ITensor, inds1, inds2) -> ITensor\n\nreplaceinds!(A::ITensor, inds1, inds2)\n\nReplace the Index inds1[n] with the Index inds2[n] in the ITensor, where n runs from 1 to length(inds1) == length(inds2).\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\nThe storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapind-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapind","text":"swapind(A::ITensor, i1::Index, i2::Index) -> ITensor\n\nswapind!(A::ITensor, i1::Index, i2::Index)\n\nSwap the Index i1 with the Index i2 in the ITensor.\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapinds-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapinds","text":"swapinds(A::ITensor, inds1, inds2) -> ITensor\n\nswapinds!(A::ITensor, inds1, inds2)\n\nSwap the Index inds1[n] with the Index inds2[n] in the ITensor, where n runs from 1 to length(inds1) == length(inds2).\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\nThe storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Math-operations-1","page":"ITensor","title":"Math operations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"*(::ITensor, ::ITensor)\nexp(::ITensor, ::Any)","category":"page"},{"location":"ITensorType.html#Base.:*-Tuple{ITensor,ITensor}","page":"ITensor","title":"Base.:*","text":"*(A::ITensor, B::ITensor)\n\nContract ITensors A and B to obtain a new ITensor. This  contraction * operator finds all matching indices common to A and B and sums over them, such that the result will  have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be  modified such that they no longer compare equal - for more information see the documentation on Index objects.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.exp-Tuple{ITensor,Any}","page":"ITensor","title":"Base.exp","text":"exp(A::ITensor, Lis; hermitian = false)\n\nCompute the exponential of the tensor A by treating it as a matrix A_lr with the left index l running over all indices in Lis and r running over all indices not in Lis. Must have dim(Lis) == dim(inds(A))/dim(Lis) for the exponentiation to be defined. When ishermitian=true the exponential of Hermitian(A_{lr}) is computed internally.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Decompositions-1","page":"ITensor","title":"Decompositions","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"svd(::ITensor, ::Any...)\nfactorize(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"LinearAlgebra.svd","text":"svd(A::ITensor, inds::Index...; <keyword arguments>)\n\nSingular value decomposition (SVD) of an ITensor A, computed by treating the \"left indices\" provided collectively as a row index, and the remaining \"right indices\" as a column index (matricization of a tensor).\n\nThe first three return arguments are U, S, and V, such that A ≈ U * S * V.\n\nWhether or not the SVD performs a trunction depends on the keyword arguments provided. \n\nArguments\n\nmaxdim::Int: the maximum number of singular values to keep.\nmindim::Int: the minimum number of singular values to keep.\ncutoff::Float64: set the desired truncation error of the SVD, by default defined as the sum of the squares of the smallest singular values.\nlefttags::String = \"Link,u\": set the tags of the Index shared by U and S.\nrighttags::String = \"Link,v\": set the tags of the Index shared by S and V.\nalg::String = \"recursive\". Options:\n\"recursive\" - ITensor's custom svd. Very reliable, but may be slow if high precision is needed. To get an svd of a matrix A, an eigendecomposition of A^dagger A is used to compute U and then a qr of A^dagger U is used to compute V. This is performed recursively to compute small singular values.\n\"divide_and_conquer\" - A divide-and-conquer algorithm. LAPACK's gesdd.\n\"qr_iteration\" - Typically slower but more accurate than \"divide_and_conquer\". LAPACK's gesvd.\nuse_absolute_cutoff::Bool = false: set if all probability weights below the cutoff value should be discarded, rather than the sum of discarded weights.\nuse_relative_cutoff::Bool = true: set if the singular values should be normalized for the sake of truncation.\n\nSee also: factorize\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"LinearAlgebra.factorize","text":"factorize(A::ITensor, Linds::Index...; <keyword arguments>)\n\nPerform a factorization of A into ITensors L and R such that A ≈ L * R.\n\nArguments\n\northo::String = \"left\": Choose orthogonality properties of the factorization.\n\"left\": the left factor L is an orthogonal basis such that L * dag(prime(L, commonind(L,R))) ≈ I. \n\"right\": the right factor R forms an orthogonal basis. \n\"none\", neither of the factors form an orthogonal basis, and in general are made as symmetrically as possible (depending on the decomposition used).\nwhich_decomp::Union{String, Nothing} = nothing: choose what kind of decomposition is used. \nnothing: choose the decomposition automatically based on the other arguments. For example, when \"automatic\" is chosen and ortho = \"left\" or \"right\", svd or eigen is used depending on the provided cutoff (eigen is only used when the cutoff is greater than 1e-12, since it has a lower precision).\n\"svd\": L = U and R = S * V for ortho = \"left\", L = U * S and R = V for ortho = \"right\", and L = U * sqrt.(S) and R = sqrt.(S) * V for ortho = \"none\". To control which svd algorithm is choose, use the svd_alg keyword argument. See the documentation for svd for the supported algorithms, which are the same as those accepted by the alg keyword argument.\n\"eigen\": L = U and R = U^dagger A where U is determined from the eigendecompositon A A^dagger = U D U^dagger for ortho = \"left\" (and vice versa for ortho = \"right\"). \"eigen\" is not supported for ortho = \"none\".\n\nIn the future, other decompositions like QR, polar, cholesky, LU, etc. are expected to be supported.\n\nFor truncation arguments, see: svd\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Operations-1","page":"ITensor","title":"Operations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"permute(::ITensor, ::Any)","category":"page"},{"location":"ITensorType.html#ITensors.permute-Tuple{ITensor,Any}","page":"ITensor","title":"ITensors.permute","text":"permute(T::ITensors, inds; always_copy::Bool = false)\npermute(T::ITensors, inds::Index...; always_copy::Bool = false)\n\nReturn a new ITensor T with indices permuted according to the input indices inds. The storage of the ITensor is permuted accordingly.\n\nIf always_copy = false, it avoids copying data if possible. Therefore, it may return a view. Use always_copy = true if you never want it to return an ITensor with a view of the original ITensor.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#IndexSet-1","page":"IndexSet","title":"IndexSet","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"IndexSet(::Vector{<:Index})","category":"page"},{"location":"IndexSetType.html#ITensors.IndexSet-Tuple{Array{#s125,1} where #s125<:Index}","page":"IndexSet","title":"ITensors.IndexSet","text":"IndexSet(inds::Vector{<:Index})\n\nConvert a Vector of indices to an IndexSet.\n\nWarning: this is not type stable, since a Vector is dynamically sized and an IndexSet is statically sized. Consider using the constructor IndexSet{N}(inds::Vector).\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Priming-and-tagging-methods-1","page":"IndexSet","title":"Priming and tagging methods","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"prime(::IndexSet, ::Int)\nmap(::Function, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#ITensors.prime-Tuple{IndexSet,Int64}","page":"IndexSet","title":"ITensors.prime","text":"prime(A::IndexSet, plinc, ...)\n\nIncrease the prime level of the indices by the specified amount. Filter which indices are primed using keyword arguments tags, plev and id.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Base.map-Tuple{Function,IndexSet}","page":"IndexSet","title":"Base.map","text":"map(f, is::IndexSet)\n\nApply the function to the elements of the IndexSet, returning a new IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Set-operations-1","page":"IndexSet","title":"Set operations","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"intersect(::IndexSet, ::IndexSet)\nfirstintersect(::IndexSet, ::IndexSet)\nsetdiff(::IndexSet, ::IndexSet)\nfirstsetdiff(::IndexSet, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#Base.intersect-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"Base.intersect","text":"intersect(A::IndexSet, B::IndexSet; kwargs...)\n\nOutput the IndexSet in the intersection of A and B, optionally filtering by tags, prime level, etc.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#ITensors.firstintersect-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"ITensors.firstintersect","text":"firstintersect(A::IndexSet, B::IndexSet; kwargs...)\n\nOutput the Index common to A and B, optionally filtering by tags, prime level, etc. If more than one Index is found, throw an error. Otherwise, return a default constructed Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Base.setdiff-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"Base.setdiff","text":"setdiff(A::IndexSet, Bs::IndexSet...)\n\nOutput the IndexSet with Indices in A but not in the IndexSets Bs.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#ITensors.firstsetdiff-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"ITensors.firstsetdiff","text":"firstsetdiff(A::IndexSet, Bs::IndexSet...)\n\nOutput the first Index in A that is not in the IndexSets Bs. Otherwise, return a default constructed Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Subsets-1","page":"IndexSet","title":"Subsets","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"getfirst(::Function, ::IndexSet)\ngetfirst(::IndexSet)\nfilter(::Function, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#ITensors.getfirst-Tuple{Function,IndexSet}","page":"IndexSet","title":"ITensors.getfirst","text":"getfirst(f::Function, is::IndexSet)\n\nGet the first Index matching the pattern function, return nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#ITensors.getfirst-Tuple{IndexSet}","page":"IndexSet","title":"ITensors.getfirst","text":"getfirst(is::IndexSet)\n\nReturn the first Index in the IndexSet. If the IndexSet is empty, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Base.filter-Tuple{Function,IndexSet}","page":"IndexSet","title":"Base.filter","text":"filter(f::Function, inds::IndexSet)\n\nFilter the IndexSet by the given function (output a new IndexSet with indices i for which f(i) returns true).\n\nNote that this function is not type stable, since the number of output indices is not known at compile time.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#IndexVal-1","page":"IndexVal","title":"IndexVal","text":"","category":"section"},{"location":"IndexValType.html#Description-1","page":"IndexVal","title":"Description","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"IndexVal","category":"page"},{"location":"IndexValType.html#ITensors.IndexVal","page":"IndexVal","title":"ITensors.IndexVal","text":"An IndexVal represents an Index object set to a certain value.\n\n\n\n\n\n","category":"type"},{"location":"IndexValType.html#Constructors-1","page":"IndexVal","title":"Constructors","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"IndexVal(::Pair{<:Index, Int})","category":"page"},{"location":"IndexValType.html#ITensors.IndexVal-Tuple{Pair{#s125,Int64} where #s125<:Index}","page":"IndexVal","title":"ITensors.IndexVal","text":"IndexVal(i::Index, n::Int)\n\nIndexVal(iv::Pair{<:Index, Int})\n\n(i::Index)(n::Int)\n\nCreate an IndexVal from a pair of Index and Int.\n\nAlternatively, you can use the syntax i(n).\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#Properties-1","page":"IndexVal","title":"Properties","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"ind(::IndexVal)\nval(::IndexVal)\nisindequal(::Index, ::IndexVal)","category":"page"},{"location":"IndexValType.html#NDTensors.ind-Tuple{IndexVal}","page":"IndexVal","title":"NDTensors.ind","text":"ind(iv::IndexVal)\n\nReturn the Index of the IndexVal.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#ITensors.val-Tuple{IndexVal}","page":"IndexVal","title":"ITensors.val","text":"val(iv::IndexVal)\n\nReturn the value of the IndexVal.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#ITensors.isindequal-Tuple{Index,IndexVal}","page":"IndexVal","title":"ITensors.isindequal","text":"isindequal(i::Index, iv::IndexVal)\n\nisindequal(i::IndexVal, iv::Index)\n\nisindequal(i::IndexVal, iv::IndexVal)\n\nCheck if the Index and IndexVal have the same indices.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Documentation Build Status\n(Image: ) (Image: ) (Image: Tests) (Image: codecov)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"ITensors is a library for rapidly creating correct and efficient tensor network algorithms. ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"An ITensor is a tensor whose interface  is independent of its memory layout. ITensor indices are objects which carry extra information and which 'recognize' each other (compare equal to each other).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The ITensor library also includes composable and extensible  algorithms for optimizing and transforming tensor networks, such as  matrix product state and matrix product operators, such as the DMRG algorithm.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Development of ITensor is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"page"},{"location":"index.html#Steps-to-Install-Pre-Release-Version-1","page":"Introduction","title":"Steps to Install Pre-Release Version","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Install the latest version of Julia: https://julialang.org/downloads/\nRun the julia command to begin an interactive Julia session (entering the so-called REPL). \nType ] on your keyboard to enter Julia's interactive package manager.\nRun the command \nadd https://github.com/ITensor/ITensors.jl\nThe package system will update itself, then install some dependencies before finally installing ITensors.jl.\nHit the backspace key to go back to the normal interactive Julia prompt, or type Ctrl+D to exit the Julia REPL.\nYou can now do using ITensors to use the ITensor library in an interactive session, or run Julia code files (.jl files) which use ITensor, with some examples given below and in our examples folder. The test folder also has many examples of ITensor code you can run.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We recommend using ITensors.jl with Intel MKL in order to get the best possible performance. If you have not done so already, you can replace your current BLAS and LAPACK implementation with MKL by using the MKL.jl package. Please follow the instructions here: https://github.com/JuliaComputing/MKL.jl","category":"page"},{"location":"index.html#Documentation-1","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"STABLE &mdash; documentation of the most recently tagged version.\nDEVEL &mdash; documentation of the in-development version.","category":"page"},{"location":"index.html#Code-Examples-1","page":"Introduction","title":"Code Examples","text":"","category":"section"},{"location":"index.html#Basic-Overview-1","page":"Introduction","title":"Basic Overview","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"ITensor construction, setting of elements, contraction, and addition. Before constructing an ITensor, one constructs Index objects representing tensor indices.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(3)\n  j = Index(5)\n  k = Index(2)\n  l = Index(7)\n\n  A = ITensor(i,j,k)\n  B = ITensor(j,l)\n\n  A[i=>1,j=>1,k=>1] = 11.1\n  A[i=>2,j=>1,k=>2] = -21.2\n  A[k=>1,i=>3,j=>1] = 31.1  # can provide Index values in any order\n  # ...\n\n  # A[k(1),i(3),j(1)] = 31.1  # alternative notation\n\n  # Contract over shared index j\n  C = A * B\n\n  @show hasinds(C,i,k,l) # = true\n\n  D = randomITensor(k,j,i) # ITensor with random elements\n\n  # Add two ITensors\n  # must have same set of indices\n  # but can be in any order\n  R = A + D\n\n  nothing\nend","category":"page"},{"location":"index.html#Singular-Value-Decomposition-(SVD)-of-a-Matrix-1","page":"Introduction","title":"Singular Value Decomposition (SVD) of a Matrix","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this example, we create a random 10x20 matrix  and compute its SVD. The resulting factors can  be simply multiplied back together using the ITensor * operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(10)           # index of dimension 10\n  j = Index(20)           # index of dimension 20\n  M = randomITensor(i,j)  # random matrix, indices i,j\n  U,S,V = svd(M,i)        # compute SVD with i as row index\n  @show M ≈ U*S*V         # = true\n\n  nothing\nend","category":"page"},{"location":"index.html#Singular-Value-Decomposition-(SVD)-of-a-Tensor-1","page":"Introduction","title":"Singular Value Decomposition (SVD) of a Tensor","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this example, we create a random 4x4x4x4 tensor  and compute its SVD, temporarily treating the first and third indices (i and k) as the \"row\" index and the second and fourth indices (j and l) as the \"column\" index for the purposes of the SVD. The resulting factors can  be simply multiplied back together using the ITensor * operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(4,\"i\")\n  j = Index(4,\"j\")\n  k = Index(4,\"k\")\n  l = Index(4,\"l\")\n  T = randomITensor(i,j,k,l)\n  U,S,V = svd(T,i,k)   # compute SVD with (i,k) as row indices (indices of U)\n  @show hasinds(U,i,k) # = true\n  @show hasinds(V,j,l) # = true\n  @show T ≈ U*S*V      # = true\n\n  nothing\nend","category":"page"},{"location":"index.html#Tensor-Indices:-Tags-and-Prime-Levels-1","page":"Introduction","title":"Tensor Indices: Tags and Prime Levels","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Before making an ITensor, you have to define its indices. Tensor Index objects carry extra information beyond just their dimension.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"All Index objects carry a permanent, immutable id number which is  determined when it is constructed, and allow it to be matched (compare equal) with copies of itself.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Additionally, an Index can have up to four tag strings, and an integer primelevel. If two Index objects have different tags or  different prime levels, they do not compare equal even if they have the same id.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Tags are also useful for identifying Index objects when printing tensors, and for performing certain Index manipulations (e.g. priming indices having certain sets of tags).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(3)     # Index of dimension 3\n  @show dim(i)     # = 3\n  @show id(i)      # = 0x5d28aa559dd13001 or similar\n\n  ci = copy(i)\n  @show ci == i    # = true\n\n  j = Index(5,\"j\") # Index with a tag \"j\"\n\n  @show j == i     # = false\n\n  s = Index(2,\"n=1,Site\") # Index with two tags,\n                          # \"Site\" and \"n=1\"\n  @show hastags(s,\"Site\") # = true\n  @show hastags(s,\"n=1\")  # = true\n\n  i1 = prime(i) # i1 has a \"prime level\" of 1\n                # but otherwise same properties as i\n  @show i1 == i # = false, prime levels do not match\n\n  nothing\nend","category":"page"},{"location":"index.html#DMRG-Calculation-1","page":"Introduction","title":"DMRG Calculation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"DMRG is an iterative algorithm for finding the dominant eigenvector of an exponentially large, Hermitian matrix. It originates in physics with the purpose of finding eigenvectors of Hamiltonian (energy) matrices which model the behavior of quantum systems.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  # Create 100 spin-one indices\n  N = 100\n  sites = siteinds(\"S=1\",N)\n\n  # Input operator terms which define \n  # a Hamiltonian matrix, and convert\n  # these terms to an MPO tensor network\n  # (here we make the 1D Heisenberg model)\n  ampo = AutoMPO()\n  for j=1:N-1\n    ampo +=     (\"Sz\",j,\"Sz\",j+1)\n    ampo += (0.5,\"S+\",j,\"S-\",j+1)\n    ampo += (0.5,\"S-\",j,\"S+\",j+1)\n  end\n  H = MPO(ampo,sites)\n\n  # Create an initial random matrix product state\n  psi0 = randomMPS(sites)\n\n  # Plan to do 5 passes or 'sweeps' of DMRG,\n  # setting maximum MPS internal dimensions \n  # for each sweep and maximum truncation cutoff\n  # used when adapting internal dimensions:\n  sweeps = Sweeps(5)\n  maxdim!(sweeps, 10,20,100,100,200)\n  cutoff!(sweeps, 1E-10)\n  @show sweeps\n\n  # Run the DMRG algorithm, returning energy \n  # (dominant eigenvalue) and optimized MPS\n  energy, psi = dmrg(H,psi0, sweeps)\n  println(\"Final energy = $energy\")\n\n  nothing\nend","category":"page"}]
}
