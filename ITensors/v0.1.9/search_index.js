var documenterSearchIndex = {"docs":
[{"location":"DMRG.html#DMRG-1","page":"DMRG","title":"DMRG","text":"","category":"section"},{"location":"DMRG.html#","page":"DMRG","title":"DMRG","text":"dmrg","category":"page"},{"location":"DMRG.html#ITensors.dmrg","page":"DMRG","title":"ITensors.dmrg","text":"dmrg(H::MPO,psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, represented as a matrix product operator (MPO). The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\ndmrg(Hs::Vector{MPO},psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H. The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nThis version of dmrg accepts a representation of H as a Vector of MPOs, Hs = [H1,H2,H3,...] such that H is defined as H = H1+H2+H3+... Note that this sum of MPOs is not actually computed; rather the set of MPOs [H1,H2,H3,..] is efficiently looped over at  each step of the DMRG algorithm when optimizing the MPS.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\ndmrg(H::MPO,Ms::Vector{MPS},psi0::MPS,sweeps::Sweeps;kwargs...)\n\nUse the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix H, subject to the constraint that the MPS is orthogonal to each of the MPS provided in the Vector Ms. The orthogonality constraint is approximately enforced by adding to H terms of  the form w|M1><M1| + w|M2><M2| + ... where Ms=[M1,M2,...] and w is the \"weight\" parameter, which can be adjusted through the optional weight keyword argument. The MPS psi0 is used to initialize the MPS to be optimized, and the sweeps object determines the parameters used to  control the DMRG algorithm.\n\nReturns:\n\nenergy::Float64 - eigenvalue of the optimized MPS\npsi::MPS - optimized MPS\n\n\n\n\n\n","category":"function"},{"location":"QN.html#QN-1","page":"QN","title":"QN","text":"","category":"section"},{"location":"QN.html#Description-1","page":"QN","title":"Description","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"QN","category":"page"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"A QN object stores a collection of up to four named values such as (\"Sz\",1) or (\"N\",0).  These values can include a third integer \"m\" which makes them obey addition modulo m, for  example (\"P\",1,2) for a value obeying addition mod 2. (The default is regular integer addition).\n\nAdding or subtracting pairs of QN objects performs addition and subtraction element-wise on each of the named values. If a name is missing from the  collection, its value is treated as zero.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#Constructors-1","page":"QN","title":"Constructors","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"QN(qvs...)\nQN(name,val::Int,modulus::Int=1)\nQN(val::Int,modulus::Int=1)","category":"page"},{"location":"QN.html#ITensors.QN-Tuple","page":"QN","title":"ITensors.QN","text":"QN(qvs...)\n\nConstruct a QN from a set of up to four named value tuples.\n\nExamples\n\nq = QN((\"Sz\",1))\nq = QN((\"N\",1),(\"Sz\",-1))\nq = QN((\"P\",0,2),(\"Sz\",0)).\n\n\n\n\n\n","category":"method"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"QN(name,val::Int,modulus::Int=1)\n\nConstruct a QN with a single named value by providing the name, value, and optional modulus.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#ITensors.QN","page":"QN","title":"ITensors.QN","text":"QN(val::Int,modulus::Int=1)\n\nConstruct a QN with a single unnamed value (equivalent to the name being the empty string) with optional modulus.\n\n\n\n\n\n","category":"type"},{"location":"QN.html#Properties-1","page":"QN","title":"Properties","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"val(q::QN,name)\nmodulus(q::QN,name)","category":"page"},{"location":"QN.html#ITensors.val-Tuple{QN,Any}","page":"QN","title":"ITensors.val","text":"val(q::QN,name)\n\nGet the value within the QN q corresponding to the string name\n\n\n\n\n\n","category":"method"},{"location":"QN.html#ITensors.modulus-Tuple{QN,Any}","page":"QN","title":"ITensors.modulus","text":"modulus(q::QN,name)\n\nGet the modulus within the QN q corresponding to the string name\n\n\n\n\n\n","category":"method"},{"location":"QN.html#Related-Functions-1","page":"QN","title":"Related Functions","text":"","category":"section"},{"location":"QN.html#","page":"QN","title":"QN","text":"zero(q::QN)","category":"page"},{"location":"QN.html#Base.zero-Tuple{QN}","page":"QN","title":"Base.zero","text":"zero(q::QN)\n\nReturns a QN object containing the same names as q, but with all values set to zero.\n\n\n\n\n\n","category":"method"},{"location":"AutoMPO.html#AutoMPO-1","page":"AutoMPO","title":"AutoMPO","text":"","category":"section"},{"location":"AutoMPO.html#Description-1","page":"AutoMPO","title":"Description","text":"","category":"section"},{"location":"AutoMPO.html#","page":"AutoMPO","title":"AutoMPO","text":"AutoMPO","category":"page"},{"location":"AutoMPO.html#ITensors.AutoMPO","page":"AutoMPO","title":"ITensors.AutoMPO","text":"An AutoMPO stores a collection of operator terms, to be later summed together into an MPO by calling the function MPO on the AutoMPO object.  Each term is a product of local operators specified by names such as \"Sz\" or \"N\", times an optional coefficient which can be real or complex.\n\nWhich local operator names are available is determined by the function op associated with the TagType defined by special Index tags, such as \"S=1/2\",\"S=1\", \"Fermion\", and \"Electron\".\n\n\n\n\n\n","category":"type"},{"location":"AutoMPO.html#Methods-1","page":"AutoMPO","title":"Methods","text":"","category":"section"},{"location":"AutoMPO.html#","page":"AutoMPO","title":"AutoMPO","text":"add!\nMPO(::AutoMPO,::Vector{<:Index})","category":"page"},{"location":"AutoMPO.html#ITensors.add!","page":"AutoMPO","title":"ITensors.add!","text":"add!(ampo::AutoMPO,\n     op1::String, i1::Int)\n\nadd!(ampo::AutoMPO,\n     coef::Number,\n     op1::String, i1::Int)\n\nadd!(ampo::AutoMPO,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\nadd!(ampo::AutoMPO,\n     coef::Number,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\n+(ampo:AutoMPO, term::Tuple)\n\nAdd a single- or multi-site operator  term to the AutoMPO ampo. Each operator is specified by a name (String) and a site number (Int). The second version accepts a real or complex coefficient.\n\nThe + operator version of this function accepts a tuple with entries either (String,Int,String,Int,...) or (Number,String,Int,String,Int,...) where these tuple values are the same as valid inputs to the add! function. For inputting a very large number of terms (tuples) to an AutoMPO, consider using the broadcasted operator .+= which avoids reallocating the AutoMPO after each addition.\n\nExamples\n\nampo = AutoMPO()\n\nadd!(ampo,\"Sz\",2,\"Sz\",3)\n\nampo += (\"Sz\",3,\"Sz\",4)\n\nampo += (0.5,\"S+\",4,\"S-\",5)\n\nampo .+= (0.5,\"S+\",5,\"S-\",6)\n\n\n\n\n\n","category":"function"},{"location":"AutoMPO.html#ITensors.MPO-Tuple{AutoMPO,Array{#s131,1} where #s131<:Index}","page":"AutoMPO","title":"ITensors.MPO","text":"MPO(ampo::AutoMPO,sites::Vector{<:Index};kwargs...)\n\nConvert an AutoMPO object ampo to an MPO, with indices given by sites. The resulting MPO will have the indices sites[1], sites[1]', sites[2], sites[2]' etc. The conversion is done by an algorithm that compresses the MPO resulting from adding the AutoMPO terms together, often achieving the minimum possible bond dimension.\n\nExamples\n\nampo = AutoMPO()\nampo += (\"Sz\",1,\"Sz\",2)\nampo += (\"Sz\",2,\"Sz\",3)\nampo += (\"Sz\",3,\"Sz\",4)\n\nsites = siteinds(\"S=1/2\",4)\nH = MPO(ampo,sites)\n\n\n\n\n\n","category":"method"},{"location":"AdvancedUsageGuide.html#Advanced-ITensor-usage-guide-1","page":"Advanced usage guide","title":"Advanced ITensor usage guide","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#Installing-and-updating-ITensors.jl-1","page":"Advanced usage guide","title":"Installing and updating ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The ITensors package can be installed with the Julia package manager. Assuming you have already downloaded Julia, which you can get here, from the Julia REPL,  type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> add ITensors","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> import Pkg; Pkg.add(\"ITensors\")","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We recommend using ITensors.jl with Intel MKL in order to get the  best possible performance. If you have not done so already, you can  replace the current BLAS and LAPACK implementation used by Julia with  MKL by using the MKL.jl package. Please follow the instructions  here.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To use the latest version of ITensors.jl, use update ITensors.  We will commonly release new minor versions with bug fixes and  improvements. However, make sure to double check before doing this,  because new releases may be breaking.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To try the \"development branch\" of ITensors.jl (for example, if  there is a feature or fix we added that hasn't been released yet),  you can do add ITensors#master. You can switch back to the latest released version with add ITensors. Using the development/master branch is generally not encouraged unless you know what you are doing.","category":"page"},{"location":"AdvancedUsageGuide.html#Using-ITensors.jl-in-the-REPL-1","page":"Advanced usage guide","title":"Using ITensors.jl in the REPL","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"There are many ways you can write code based on ITensors.jl, ranging  from using it in the REPL to writing a small script to making a  package that depends on it.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"For example, you can just start the REPL from your command line like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"assuming you have an available version of Julia with the ITensors.jl package installed. Then just type:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"and start typing ITensor commands. For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> i = Index(2, \"i\")\n(dim=2|id=355|\"i\")\n\njulia> A = randomITensor(i, i')\nITensor ord=2 (dim=2|id=355|\"i\") (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=355|\"i\")\nDim 2: (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 1.2320011464276275  1.8504245734277216\n 1.0763652402177477  0.030353720156277037\n\njulia> (A*dag(A))[]\n3.9627443142240617","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Note that there are some \"gotchas\" with working in the REPL like this. Technically, all commands in the REPL are in the \"global scope\". The global scope might not work as you would expect, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> for _ in 1:3\n         A *= 2\n       end\nERROR: UndefVarError: A not defined\nStacktrace:\n [1] top-level scope at ./REPL[12]:2\n [2] eval(::Module, ::Any) at ./boot.jl:331\n [3] eval_user_input(::Any, ::REPL.REPLBackend) at /home/mfishman/software/julia-1.4.0/share/julia/stdlib/v1.4/REPL/src/REPL.jl:86\n [4] run_backend(::REPL.REPLBackend) at /home/mfishman/.julia/packages/Revise/AMRie/src/Revise.jl:1023\n [5] top-level scope at none:0","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"since the A inside the for-loop introduces a new local variable. Some alternatives are to wrap that part of the code in a let-block or a function:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> function f(A)\n         for _ in 1:3\n           A *= 2\n         end\n         A\n       end\nf (generic function with 1 method)\n\njulia> A = f(A)\nITensor ord=2 (dim=2|id=355|\"i\") (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=355|\"i\")\nDim 2: (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 9.85600917142102   14.803396587421773\n 8.610921921741982   0.2428297612502163","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In this particular case, you can alternatively modify the ITensor in-place:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> for _ in 1:3\n         A ./= 2\n       end\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=355|\"i\")\nDim 2: (dim=2|id=355|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 1.2320011464276275  1.8504245734277216\n 1.0763652402177477  0.030353720156277037","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"A common place you might accidentally come across this is the  following:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> N = 4;\n\njulia> sites = siteinds(\"S=1/2\",N);\n\njulia> ampo = AutoMPO();\n\njulia> for j=1:N-1\n         ampo += (\"Sz\", j, \"Sz\", j+1)\n       end\nERROR: UndefVarError: ampo not defined\nStacktrace:\n [1] top-level scope at ./REPL[16]:2\n [2] eval(::Module, ::Any) at ./boot.jl:331\n [3] eval_user_input(::Any, ::REPL.REPLBackend) at /home/mfishman/software/julia-1.4.0/share/julia/stdlib/v1.4/REPL/src/REPL.jl:86\n [4] run_backend(::REPL.REPLBackend) at /home/mfishman/.julia/packages/Revise/AMRie/src/Revise.jl:1023\n [5] top-level scope at none:0","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In this case, you can use ampo .+= (\"Sz\", j, \"Sz\", j+1), add!(ampo, \"Sz\", j, \"Sz\", j+1), or wrap your code in a let-block or function.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Take a look at Julia's documentation here for rules on scoping. Also note that this behavior is particular to Julia v1.4 and below, and is expected to change in v1.5.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Note that the REPL is very useful for prototyping code quickly, but working directly in the REPL and outside of functions can cause sub-optimal performance. See Julia's performance tips for more information.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We recommend the package OhMyREPL which adds syntax highlighting to the Julia REPL.","category":"page"},{"location":"AdvancedUsageGuide.html#Make-a-small-project-based-on-ITensors.jl-1","page":"Advanced usage guide","title":"Make a small project based on ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Once you start to have longer code, you will want to put your code into one or more files. For example, you may have a short script with one or more functions based on ITensors.jl:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# my_itensor_script.jl\nusing ITensors\n\nfunction norm2(A::ITensor)\n  return (A*dag(A))[]\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, in the same directory as your script my_itensor_script.jl, just type:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> include(\"my_itensor_script.jl\");\n\njulia> i = Index(2; tags=\"i\");\n\njulia> A = randomITensor(i', i);\n\njulia> norm2(A)\n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"As your code gets longer, you can split it into multiple files and include this files into one main project file, for example if you have two files with functions in them:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# file1.jl\n\nfunction norm2(A::ITensor)\n  return (A*dag(A))[]\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"and","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# file2.jl\n\nfunction square(A::ITensor)\n  return A .^ 2\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"# my_itensor_project.jl\n\nusing ITensors\n\ninclude(\"file1.jl\")\n\ninclude(\"file2.jl\")","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, as before, you can use your functions at the Julia REPL by just including the file my_itensor_project.jl:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> include(\"my_itensor_project.jl\");\n\njulia> i = Index(2; tags=\"i\");\n\njulia> A = randomITensor(i', i);\n\njulia> norm2(A)\n[...]\n\njulia> square(A)\n[...]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"As your code gets more complicated and has more files, it is helpful to organize it into a package. That will be covered in the next section.","category":"page"},{"location":"AdvancedUsageGuide.html#Make-a-Julia-package-based-on-ITensors.jl-1","page":"Advanced usage guide","title":"Make a Julia package based on ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In this section, we will describe how to make a Julia package based on ITensors.jl. This is useful to do when your project gets longer, since it helps with:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Code organization.\nAdding dependencies that will get automatically installed through Julia's package system.\nVersioning.\nAutomated testing.\nCode sharing and easier package installation.\nOfficially registering your package with Julia.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"and many more features that we will mention later.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"First enter Julia's standard development directory, ~/.julia/dev.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ cd ~/.julia/dev","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Start up Julia and install PkgTemplates","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia\n\njulia> ]\n\npkg> add PkgTemplates","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"then press backspace and type:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using PkgTemplates\n\njulia> t = Template(; user=\"your_github_username\")\n\njulia> t(\"MyITensorsPkg\")","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, we want to tell Julia about our new package. We do this as follows:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> dev ~/.julia/dev/MyITensorsPkg","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"then you can do:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using MyITensorsPkg","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"from any directory to use your new package. However, it doesn't  have any functions available yet. Additionally, there should be an empty test file already set up here:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"~/.julia/dev/MyITensorsPkg/test/runtests.jl","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"which you can run from any directory like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> test MyITensorsPkg","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"It should show something like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"[...]\nTest Summary:    |\nMyITensorsPkg.jl | No tests\n    Testing MyITensorsPkg tests passed ","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"since there are no tests yet.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"First we want to add ITensors as a dependency of our package. We do this by \"activating\" our package environment and then adding ITensors:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> ]\n\npkg> activate MyITensorsPkg\n\n(MyITensorsPkg) pkg> add ITensors","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This will edit the file ~/.julia/dev/MyITensorsPkg/Project.toml and add the line","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"[deps]\nITensors = \"9136182c-28ba-11e9-034c-db9fb085ebd5\"","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Because your package is under development, back in the main Pkg environment you should type resolve:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"(MyITensorsPkg) pkg> activate\n\npkg> resolve","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now, if you or someone else uses the package, it will automatically install ITensors.jl for you.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now your package is set up to develop! Try editing the file ~/.julia/dev/MyITensorsPkg/src/MyITensorsPkg.jl and add the  norm2 function, which calculates the squared norm of an ITensor:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"module MyITensorsPkg\n\nusing ITensors\n\nexport norm2\n\nnorm2(A::ITensor) = (A*dag(A))[]\n\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The export command makes norm2 available in the namespace without needing to type MyITensorsPkg.norm2 when you do  using MyITensorsPkg. Now in a new Julia session you can do:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors\n\njulia> i = Index(2)\n(dim=2|id=263)\n\njulia> A = randomITensor(i)\nITensor ord=1 (dim=2|id=263)\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> norm(A)^2\n6.884457016011188\n\njulia> norm2(A)\nERROR: UndefVarError: norm2 not defined\n[...]\n\njulia> using MyITensorsPkg\n\njulia> norm2(A)\n6.884457016011188","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Unfortunately, if you continue to edit the file MyITensorsPkg.jl, even if you type using MyITensorsPkg again, if you are in the same Julia session the changes will not be reflected, and you will have to restart your Julia session. The  Revise package will allow you to edit your package files and have the changes reflected in real time in your current Julia session, so you don't have to restart the session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now, we can add some tests for our new functionality. Edit the file ~/.julia/dev/MyITensorsPkg/test/runtests.jl to look like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"using MyITensorsPkg\nusing ITensors\nusing Test\n\n@testset \"MyITensorsPkg.jl\" begin\n  i = Index(2)\n  A = randomITensor(i)\n  @test isapprox(norm2(A), norm(A)^2)\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Now when you test your package you should see:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"pkg> test MyITensorsPkg\n[...]\nTest Summary:    | Pass  Total\nMyITensorsPkg.jl |    1      1\n    Testing MyITensorsPkg tests passed ","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Your package should already be set up as a git repository by  the PkgTemplates commands we started with. We recommend using Github or similar versions control systems for your packages, especially if you plan to make them public and officially register them as Julia packages.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You can set up your local package as a Github repository by following the steps here. Many of the steps may be unnecessary since they were already set up by PkgTemplates.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You may also want to change from HTTPS to SSH authentification as described here.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"There are many more features you can add to your package through  various Julia packages and Github, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Control of precompilation with tools like SnoopCompile.\nAutomatic testing of your package at every pull request/commit with Github Actions, Travis, or similar services.\nAutomated benchmarking of your package at every pull request with BenchmarkTools, PkgBenchmark and BenchmarkCI.\nAutomated building of your documentation with Documenter.\nCompiling your package with PackageCompiler.\nAutomatically check what parts of your code your tests check with code coverage.\nOfficially register your Julia package so that others can easily install it and follow along with updated versions using the Registrator.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You can take a look at the ITensors  Github page for inspiration on setting up some of these services and ideas for organizing your package.","category":"page"},{"location":"AdvancedUsageGuide.html#Developing-ITensors.jl-1","page":"Advanced usage guide","title":"Developing ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To make your own changes to ITensors.jl, type dev ITensors in Pkg mode (by typing ] at the Julia prompt). This  will create a local clone of the Github repository in the directory  ~/.julia/dev/ITensors. Changes to that directory will be reflected  when you do using ITensors in a new session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We highly recommend using the Revise package when you are developing  packages, which automatically detects changes you are making in a  package so you can edit code and not have to restart your Julia  session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"info: Coming soon\nA more extended guide for contributing to ITensors.jl, including  contributing to the related NDTensors.jl as well as a style  guide, is coming soon.","category":"page"},{"location":"AdvancedUsageGuide.html#Compiling-ITensors.jl-1","page":"Advanced usage guide","title":"Compiling ITensors.jl","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"You might notice that the time to load ITensors.jl (with using  ITensors) and the time to run your first few ITensor commands is  slow. This is due to Julia's just-in-time (JIT) compilation. Julia is compiling special versions of each function that is being called based on the inputs that it gets at runtime. This allows it to have fast code, often nearly as fast as fully compiled languages like C++, while still being a dynamic language.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"However, the long startup time can still be annoying. In this section, we will discuss some strategies that can be used to minimize this annoyance, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Precompilation.\nStaying in the same Julia session with Revise.\nUsing PackageCompiler to compile ITensors.jl ahead of time.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Precompilation is performed automatically when you first install ITensors.jl or update a version and run the command using ITensors for the first time. For example, when you first use ITensors after installation or updating, you will see:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors\n[ Info: Precompiling ITensors [9136182c-28ba-11e9-034c-db9fb085ebd5]","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The process is done automatically, and puts some compiled binaries in your ~/.julia directory. The goal is to decrease the time it takes when you first type using ITensors in your next Julia session, and also the time it takes for you to first run ITensor functions in a new Julia session. This helps the startup time, but currently doesn't help enough. This is something both ITensors.jl and the Julia language will try to improve over time.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To avoid this time, it is recommended that you work as much as you can in a single Julia session. You should not need to restart your Julia session very often. For example, if you are writing code in a script, just include the file again which will pull in the new changes to the script (the exception is if you change the definition of a type you made, which would requiring restarting the REPL).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"If you are working on a project, we highly recommend using the Revise package which automatically detects changes you are making in your packages and reflects them real-time in your current REPL session. Using these strategies should minimize the number of times you need to restart your REPL session.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"If you plan to use ITensors.jl directly from the command line (i.e. not from the REPL), and the startup time is an issue, you can try compiling ITensors.jl using PackageCompiler.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Before using PackageCompiler, when we first start using ITensors.jl we might see:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> @time using ITensors\n  3.845253 seconds (10.96 M allocations: 618.071 MiB, 3.95% gc time)\n\njulia> @time i = Index(2);\n  0.000684 seconds (23 allocations: 20.328 KiB)\n\njulia> @time A = randomITensor(i', i);\n  0.071022 seconds (183.24 k allocations: 9.715 MiB)\n\njulia> @time svd(A, i');\n  5.802053 seconds (24.56 M allocations: 1.200 GiB, 7.83% gc time)\n\njulia> @time svd(A, i');\n  0.000177 seconds (450 allocations: 36.609 KiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We would start by making a file precompile_itensors.jl:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"using ITensors\ni = Index(2)\nA = randomITensor(i', i)\nsvd(A, i')","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We make the \"custom system image\", a custom version of Julia that includes a compiled version of ITensors.jl, with the commands:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using PackageCompiler\n\njulia> create_sysimage(:ITensors, sysimage_path=\"sys_itensors.so\", precompile_execution_file=\"precompile_itensors.jl\")\n[ Info: PackageCompiler: creating system image object file, this might take a while...","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, in the same directory that contains the file sys_itensors.so, if we start julia with:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ julia --sysimage sys_itensors.so","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"then we see:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> @time using ITensors\n  0.330587 seconds (977.61 k allocations: 45.807 MiB, 1.89% gc time)\n\njulia> @time i = Index(2);\n  0.000656 seconds (23 allocations: 20.328 KiB)\n\njulia> @time A = randomITensor(i', i);\n  0.000007 seconds (7 allocations: 576 bytes)\n\njulia> @time svd(A, i');\n  0.263526 seconds (290.02 k allocations: 14.220 MiB)\n\njulia> @time svd(A, i');\n  0.000135 seconds (350 allocations: 29.984 KiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"which is much better. ","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"There is a script to partially automate this process in the packagecompiler/ directory of the ITensors.jl library. Additionally, we will investigate pre-packaging a compiled  version of ITensors.jl.","category":"page"},{"location":"AdvancedUsageGuide.html#Multithreading-Support-1","page":"Advanced usage guide","title":"Multithreading Support","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"There are two possible sources of parallelization available in  ITensors.jl, both external to the package right now. These are:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"BLAS/LAPACK multithreading (through whatever flavor you are using, i.e. OpenBLAS or MKL).\nThe Strided.jl package, which implements a multithreaded array permutation.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The BLAS/LAPACK multithreading can be controlled in the usual way with  environment variables, or within Julia. So for example, to control  from Julia, you would do:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using LinearAlgebra\n\njulia> BLAS.vendor()  # Check which BLAS you are using\n:mkl\n\njulia> BLAS.set_num_threads(4)\n\njulia> ccall((:MKL_GET_MAX_THREADS, Base.libblas_name), Cint, ())\n4\n\njulia> BLAS.set_num_threads(2)\n\njulia> ccall((:MKL_GET_MAX_THREADS, Base.libblas_name), Cint, ())\n2","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"if you are using OpenBLAS, the command would be something like  ccall((:openblas_get_num_threads, Base.libblas_name), Cint, ()).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Alternatively, you can use environment variables, so at your command  line prompt you would use:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ export MKL_NUM_THREADS=4","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"if you are using MKL or","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"$ export OPENBLAS_NUM_THREADS=4","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"if you are using OpenBLAS. We would highly recommend using MKL (see the installation instructions for how to do that), especially if you  are using an Intel chip. In general, we have not found MKL/OpenBLAS  multithreading to help much in the context of common ITensor applications (like DMRG), but your mileage may vary and it would depend highly on the  problem you are studying.  How well BLAS multithreading will work would depend on how much your  calculations are dominated by matrix multiplications (which is not  always the case, especially if you are using QN conservation).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then, a separate level of mutlithreading could be turned on, which is  native Julia multithreading. Right now in ITensors.jl, this would  only control array permutation functions we use from  Strided.jl. You would set it  with the environment variable JULIA_NUM_THREADS, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> Threads.nthreads() # By default it is probably off\n1","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Then if you set export JULIA_NUM_THREADS=4 at your command line,  you would see the next time you start up Julia:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> Threads.nthreads()\n4","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"As of this writing, we have not found that using that kind of  multithreading has helped much in the context of DMRG calculation,  but your mileage may vary. Also note that the two kinds of multithreading (BLAS vs. native Julia) may compete with each other for resources, so it is recommended you turn one or the other off.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We plan to incorporate our own multithreading with Julia's native  multithreading capabilities, for example to parallelize over block  sparse contractions. Stay tuned for that!","category":"page"},{"location":"AdvancedUsageGuide.html#Benchmarking-and-profiling-1","page":"Advanced usage guide","title":"Benchmarking and profiling","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Julia has great built-in tools for benchmarking and profiling. For benchmarking fast code at the command line, you can use BenchmarkTools:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using ITensors;\n\njulia> using BenchmarkTools;\n\njulia> i = Index(100, \"i\");\n\njulia> A = randomITensor(i, i');\n\njulia> @btime 2*$A;\n  4.279 μs (8 allocations: 78.73 KiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"We recommend packages like ProfileView  to get detailed profiles of your code, in order to pinpoint functions  or lines of code that are slower than they should be.","category":"page"},{"location":"AdvancedUsageGuide.html#ITensor-type-design-and-writing-performant-code-1","page":"Advanced usage guide","title":"ITensor type design and writing performant code","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Advanced users might notice something strange about the definition of the ITensor type, that it is often not \"type stable\". Some of  this is by design. The definition for ITensor is:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"mutable struct ITensor{N}\n  inds::IndexSet{N}\n  store::TensorStorage\nend","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"These are both abstract types, which is something that is generally  discouraged for peformance.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This has a few disadvantages. Some code that you might expect to be  type stable, like getindex, is not, for example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> i = Index(2, \"i\");\n\njulia> A = randomITensor(i, i');\n\njulia> @code_warntype A[i=>1, i'=>2]\nVariables\n  #self#::Core.Compiler.Const(getindex, false)\n  T::ITensor{1}\n  ivs::Tuple{Pair{Index{Int64},Int64}}\n  p::Tuple{Union{Nothing, Int64}}\n  vals::Tuple{Any}\n\nBody::Number\n1 ─ %1  = NDTensors.getperm::Core.Compiler.Const(NDTensors.getperm, false)\n│   %2  = ITensors.inds(T)::IndexSet{1,IndexT,DataT} where DataT<:Tuple where IndexT<:Index\n│   %3  = Base.broadcasted(ITensors.ind, ivs)::Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple},Nothing,typeof(ind),Tuple{Tuple{Pair{Index{Int64},Int64}}}}\n│   %4  = Base.materialize(%3)::Tuple{Index{Int64}}\n│         (p = (%1)(%2, %4))\n│   %6  = NDTensors.permute::Core.Compiler.Const(NDTensors.permute, false)\n│   %7  = Base.broadcasted(ITensors.val, ivs)::Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple},Nothing,typeof(val),Tuple{Tuple{Pair{Index{Int64},Int64}}}}\n│   %8  = Base.materialize(%7)::Tuple{Int64}\n│         (vals = (%6)(%8, p))\n│   %10 = Core.tuple(T)::Tuple{ITensor{1}}\n│   %11 = Core._apply_iterate(Base.iterate, Base.getindex, %10, vals)::Number\n│   %12 = Core.typeassert(%11, ITensors.Number)::Number\n└──       return %12\n\njulia> typeof(A[i=>1, i'=>2])\nFloat64","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Uh oh, that doesn't look good! Julia can't know ahead of time, based on  the inputs, what the type of the output is, besides that it will be a Number (though at runtime, the output has a concrete type, Float64).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"So why is it designed this way? The main reason is to allow more  generic and dynamic code than traditional, statically-typed Arrays. This allows us to have code like:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"A = randomITensor(i', i)\nA .*= 2+1im","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Here, the type of the storage of A is changed in-place (allocations are performed only when needed). More generally, this allows ITensors to have more generic in-place  functionality, so you can write code where you don't know what the storage is until runtime.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This can lead to certain types of code having perfomance problems,  for example looping through ITensors with many elements can be slow:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> function myscale!(A::ITensor, x::Number)\n         for n in 1:dim(A)\n           A[n] = x * A[n]\n         end\n       end;\n\njulia> d = 10_000;\n\njulia> i = Index(d);\n\njulia> @btime myscale!(A, 2) setup = (A = randomITensor(i));\n  2.169 ms (117958 allocations: 3.48 MiB)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"However, this is fast:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> function myscale!(A::Array, x::Number)\n         for n in 1:length(A)\n           A[n] = x * A[n]\n         end\n       end;\n\njulia> @btime myscale!(A, 2) setup = (A = randn(d));\n  3.451 μs (0 allocations: 0 bytes)\n\njulia> myscale2!(A::ITensor, x::Number) = myscale!(array(A), x)\nmyscale2! (generic function with 1 method)\n\njulia> @btime myscale2!(A, 2) setup = (A = randomITensor(i));\n  3.571 μs (2 allocations: 112 bytes)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"How does this work? It relies on a \"function barrier\" technique.  Julia compiles functions \"just-in-time\", so that calls to an inner  function written in terms of a type-stable type are still fast. That inner function is compiled to very fast code. The main overhead is that Julia has to determine which function  to call at runtime.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Therefore, users should keep this in mind when they are writing  ITensors.jl code, and we warn that explicitly looping over large  ITensors by individual elements should be done with caution in  performance critical sections of your code.  However, be sure to benchmark and profile your code before  prematurely optimizing, since you may be surprised about  what are the fast and slow parts of your code.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Some strategies for avoiding ITensor loops are:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Use broadcasting and other built-in ITensor functionality that makes use of function barriers.\nConvert ITensors to type-stable collections like the Tensor type of NDTensors.jl and write functions in terms of the Tensor type (i.e. the function barrier techique that is used throughout ITensors.jl).\nWhen initializing very large ITensors elementwise, use built-in ITensor constructors, or first construct an equivalent tensor as an Array or Tensor and then convert it to an ITensor.","category":"page"},{"location":"AdvancedUsageGuide.html#ITensor-in-place-operations-1","page":"Advanced usage guide","title":"ITensor in-place operations","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"In-place operations can help with optimizing code, when the memory of the output tensor of an operation is preallocated.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"The main way to access this in ITensor is through broadcasting. For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"A = randomITensor(i, i')\nB = randomITensor(i', i)\nA .+= 2 .* B","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Internally, this is rewritten by Julia as a call to broadcast!. ITensors.jl overloads this call (or more specifically, a lower level function copyto! written in terms of a special lazy type that saves all of the objects and operations). Then, this call is  rewritten as","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"map!((x,y) -> x+2*y, A, A, B)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"This is mostly an optimization to use when you can preallocate storage that can be used multiple times.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Additionally, ITensors makes the unique choice that:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"C .= A .* B","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"is interpreted as an in-place tensor contraction. What this means is that this calls a function:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"mul!(C, A, B)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"(likely to be given an alternative name contract!) which contracts A and B into the pre-allocated memory C.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"Because of the design of the ITensor type (see the section above), there is some flexibility we take in allocating memory for users. For example, if the storage type is more narrow than the result, for convenience we might expand it in-place. If you are worried about memory allocations, we recommend using benchmarking and profiling to pinpoint slow parts of your code (often times, you may be surprised by what is actually slow).","category":"page"},{"location":"AdvancedUsageGuide.html#NDTensors-and-ITensors-1","page":"Advanced usage guide","title":"NDTensors and ITensors","text":"","category":"section"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"ITensors.jl is built on top of another, more traditional tensor  library called NDTensors. NDTensors implements AbstractArrays with  a variety of sparse storage types, with more to come in the future.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"NDTensors implements functionality like permutation of dimensions,  fast get and set index, broadcasting, and tensor contraction (where  labels of the dimensions must be specified).","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"For example:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"using ITensors\nusing NDTensors\n\nT = Tensor(2,2,2)\nT[1,2,1] = 1.3  # Conventional element setting\n\ni = Index(2)\nT = Tensor(i,i',i')  # The identifiers are ignored, just interpreted as above\nT[1,2,1] = 1.3","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"To make performant ITensor code (refer to the the previous section  on type stability and function barriers), ITensor storage data and  indices are passed by reference into Tensors, where the performance  critical operations are performed.","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"An example of a function barrier using NDTensors is the following:","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"julia> using NDTensors\n\njulia> d = 10_000;\n\njulia> i = Index(d);\n\njulia> function myscale!(A::Tensor, x::Number)\n         for n in 1:dim(A)\n           A[n] = x * A[n]\n         end\n       end;\n\njulia> @btime myscale!(A, 2) setup = (A = Tensor(d));\n  3.530 μs (0 allocations: 0 bytes)\n\njulia> myscale2!(A::ITensor, x::Number) = myscale!(tensor(A), x)\nmyscale2! (generic function with 1 method)\n\njulia> @btime myscale2!(A, 2) setup = (A = randomITensor(i));\n  3.549 μs (2 allocations: 112 bytes)","category":"page"},{"location":"AdvancedUsageGuide.html#","page":"Advanced usage guide","title":"Advanced usage guide","text":"A very efficient function is written for the Tensor type. Then, the ITensor version just wraps the Tensor function by calling it after converting the ITensor to a Tensor (without any copying) with the tensor function. This is the basis for the design of all performance critical ITensors.jl functions.","category":"page"},{"location":"IndexType.html#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"IndexType.html#Description-1","page":"Index","title":"Description","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"Index\nITensors.QNIndex","category":"page"},{"location":"IndexType.html#ITensors.Index","page":"Index","title":"ITensors.Index","text":"An Index represents a single tensor index with fixed dimension dim. Copies of an Index compare equal unless their  tags are different.\n\nAn Index carries a TagSet, a set of tags which are small strings that specify properties of the Index to help  distinguish it from other Indices. There is a special tag which is referred to as the integer tag or prime  level which can be incremented or decremented with special priming functions.\n\nInternally, an Index has a fixed id number, which is how the ITensor library knows two indices are copies of a  single original Index. Index objects must have the same id, as well as the tags to compare equal.\n\n\n\n\n\n","category":"type"},{"location":"IndexType.html#ITensors.QNIndex","page":"Index","title":"ITensors.QNIndex","text":"A QN Index is an Index with QN block storage instead of just an integer dimension. The QN block storage is a  vector of pairs of QNs and block dimensions. The total dimension of a QN Index is the sum of the dimensions of the blocks of the Index.\n\n\n\n\n\n","category":"type"},{"location":"IndexType.html#Constructors-1","page":"Index","title":"Constructors","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"Index(::Int)\nIndex(::Int, ::Union{AbstractString, TagSet})\nIndex(::Pair{QN, Int}...)\nIndex(::Vector{Pair{QN, Int}})\nIndex(::Vector{Pair{QN, Int}}, ::Union{AbstractString, TagSet})","category":"page"},{"location":"IndexType.html#ITensors.Index-Tuple{Int64}","page":"Index","title":"ITensors.Index","text":"Index(dim::Int; tags::Union{AbstractString, TagSet} = \"\",\n                plev::Int = 0)\n\nCreate an Index with a unique id, a TagSet given by tags, and a prime level plev.\n\nExamples\n\njulia> i = Index(2; tags = \"l\", plev = 1)\n(dim=2|id=818|\"l\")'\n\njulia> dim(i)\n2\n\njulia> plev(i)\n1\n\njulia> tags(i)\n\"l\"\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Int64,Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.Index","text":"Index(dim::Integer, tags::Union{AbstractString, TagSet}; plev::Int = 0)\n\nCreate an Index with a unique id and a tagset given by tags.\n\nExamples\n\njulia> i = Index(2, \"l,tag\")\n(dim=2|id=58|\"l,tag\")\n\njulia> dim(i)\n2\n\njulia> plev(i)\n0\n\njulia> tags(i)\n\"l,tag\"\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Vararg{Pair{QN,Int64},N} where N}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Pair{QN, Int64}...; dir::Arrow = Out,\n                                    tags = \"\",\n                                    plev::Int = 0)\n\nConstruct a QN Index from a list of pairs of QN and block  dimensions.\n\nExample\n\nIndex(QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1; tags = \"i\")\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Array{Pair{QN,Int64},1}}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Vector{Pair{QN, Int64}}; dir::Arrow = Out,\n                                         tags = \"\",\n                                         plev::Int = 0)\n\nConstruct a QN Index from a Vector of pairs of QN and block  dimensions.\n\nNote: in the future, this may enforce that all blocks have the same QNs (which would allow for some optimizations, for example when constructing random QN ITensors).\n\nExample\n\nIndex([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1]; tags = \"i\")\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.Index-Tuple{Array{Pair{QN,Int64},1},Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.Index","text":"Index(qnblocks::Vector{Pair{QN, Int64}}, tags; dir::Arrow = Out,\n                                               plev::Int = 0)\n\nConstruct a QN Index from a Vector of pairs of QN and block  dimensions.\n\nExample\n\nIndex([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1], \"i\"; dir = In)\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Properties-1","page":"Index","title":"Properties","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"id(::Index)\nhasid(::Index, ::ITensors.IDType)\ntags(::Index)\nhastags(::Index, ::Union{AbstractString,TagSet})\nplev(::Index)\nhasplev(::Index, ::Int)\ndim(::Index)\n==(::Index, ::Index)\ndir(::Index)\nhasqns(::Index)","category":"page"},{"location":"IndexType.html#ITensors.id-Tuple{Index}","page":"Index","title":"ITensors.id","text":"id(i::Index)\n\nObtain the id of an Index, which is a unique 64 digit integer.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasid-Tuple{Index,UInt64}","page":"Index","title":"ITensors.hasid","text":"hasid(i::Index, id::ITensors.IDType)\n\nCheck if an Index i has the provided id.\n\nExamples\n\njulia> i = Index(2)\n(dim=2|id=321)\n\njulia> hasid(i, id(i))\ntrue\n\njulia> j = Index(2)\n(dim=2|id=17)\n\njulia> hasid(i, id(j))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.tags-Tuple{Index}","page":"Index","title":"ITensors.tags","text":"tags(i::Index)\n\nObtain the TagSet of an Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hastags-Tuple{Index,Union{TagSet, AbstractString}}","page":"Index","title":"ITensors.hastags","text":"hastags(i::Index, ts::Union{AbstractString,TagSet})\n\nCheck if an Index i has the provided tags, which can be a string of comma-separated tags or  a TagSet object.\n\nExamples\n\njulia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=861|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"SpinHalf,Site\")\ntrue\n\njulia> hastags(i, \"Link\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.plev-Tuple{Index}","page":"Index","title":"ITensors.plev","text":"plev(i::Index)\n\nObtain the prime level of an Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasplev-Tuple{Index,Int64}","page":"Index","title":"ITensors.hasplev","text":"hasplev(i::Index, plev::Int)\n\nCheck if an Index i has the provided prime level.\n\nExamples\n\njulia> i = Index(2; plev=2)\n(dim=2|id=543)''\n\njulia> hasplev(i, 2)\ntrue\n\njulia> hasplev(i, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#NDTensors.dim-Tuple{Index}","page":"Index","title":"NDTensors.dim","text":"dim(i::Index)\n\nObtain the dimension of an Index.\n\nFor a QN Index, this is the sum of the block dimensions.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.:==-Tuple{Index,Index}","page":"Index","title":"Base.:==","text":"==(i1::Index, i1::Index)\n\nCompare indices for equality. First the id's are compared, then the prime levels are compared, and finally the tags are compared.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.dir-Tuple{Index}","page":"Index","title":"ITensors.dir","text":"dir(i::Index)\n\nObtain the direction of an Index (In, Out, or Neither).\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.hasqns-Tuple{Index}","page":"Index","title":"ITensors.hasqns","text":"hasqns(::Index)\n\nChecks of the Index has QNs or not.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Priming-and-tagging-methods-1","page":"Index","title":"Priming and tagging methods","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"prime(::Index, ::Int)\nadjoint(::Index)\n^(::Index, ::Int)\nsetprime(::Index, ::Int)\nnoprime(::Index)\nsettags(::Index, ::Any)\naddtags(::Index, ::Any)\nremovetags(::Index, ::Any)\nreplacetags(::Index, ::Any, ::Any)","category":"page"},{"location":"IndexType.html#ITensors.prime-Tuple{Index,Int64}","page":"Index","title":"ITensors.prime","text":"prime(i::Index, plinc::Int = 1)\n\nReturn a copy of Index i with its prime level incremented by the amount plinc\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.adjoint-Tuple{Index}","page":"Index","title":"Base.adjoint","text":"adjoint(i::Index)\n\nPrime an Index using the notation i'.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Base.:^-Tuple{Index,Int64}","page":"Index","title":"Base.:^","text":"^(i::Index, pl::Int)\n\nPrime an Index using the notation i^3.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.setprime-Tuple{Index,Int64}","page":"Index","title":"ITensors.setprime","text":"setprime(i::Index, plev::Int)\n\nReturn a copy of Index i with its prime level set to plev\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.noprime-Tuple{Index}","page":"Index","title":"ITensors.noprime","text":"noprime(i::Index)\n\nReturn a copy of Index i with its prime level set to zero.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.settags-Tuple{Index,Any}","page":"Index","title":"ITensors.settags","text":"settags(i::Index, ts)\n\nReturn a copy of Index i with tags replaced by the ones given The ts argument can be a comma-separated  string of tags or a TagSet.\n\nExamples\n\njulia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=543|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"Link\")\nfalse\n\njulia> j = settags(i,\"Link,n=4\")\n(dim=2|id=543|\"Link,n=4\")\n\njulia> hastags(j, \"Link\")\ntrue\n\njulia> hastags(j, \"n=4,Link\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.addtags-Tuple{Index,Any}","page":"Index","title":"ITensors.addtags","text":"addtags(i::Index,ts)\n\nReturn a copy of Index i with the specified tags added to the existing ones. The ts argument can be a comma-separated  string of tags or a TagSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.removetags-Tuple{Index,Any}","page":"Index","title":"ITensors.removetags","text":"removetags(i::Index, ts)\n\nReturn a copy of Index i with the specified tags removed. The ts argument can be a comma-separated string of tags or a TagSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.replacetags-Tuple{Index,Any,Any}","page":"Index","title":"ITensors.replacetags","text":"replacetags(i::Index, tsold, tsnew)\n\nIf the tag set of i contains the tags specified by tsold, replaces these with the tags specified by tsnew, preserving any other tags. The arguments tsold and tsnew can be comma-separated strings of tags, or TagSet objects.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Methods-1","page":"Index","title":"Methods","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"sim(::Index)\ndag(::Index)\nremoveqns(::Index)","category":"page"},{"location":"IndexType.html#ITensors.sim-Tuple{Index}","page":"Index","title":"ITensors.sim","text":"sim(i::Index; tags = tags(i), plev = plev(i), dir = dir(i))\n\nProduces an Index with the same properties (dimension or QN structure) but with a new id.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.dag-Tuple{Index}","page":"Index","title":"ITensors.dag","text":"dag(i::Index)\n\nCopy an index i and reverse its direction.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#ITensors.removeqns-Tuple{Index}","page":"Index","title":"ITensors.removeqns","text":"removeqns(::Index)\n\nRemoves the QNs from the Index, if it has any.\n\n\n\n\n\n","category":"method"},{"location":"IndexType.html#Iterating-1","page":"Index","title":"Iterating","text":"","category":"section"},{"location":"IndexType.html#","page":"Index","title":"Index","text":"iterate(::Index)","category":"page"},{"location":"IndexType.html#Base.iterate-Tuple{Index}","page":"Index","title":"Base.iterate","text":"Iterating over Index I gives the IndexVals I(1) through I(dim(I)).\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPS-and-MPO-1","page":"MPS and MPO","title":"MPS and MPO","text":"","category":"section"},{"location":"MPSandMPO.html#Types-1","page":"MPS and MPO","title":"Types","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPS\nMPO","category":"page"},{"location":"MPSandMPO.html#ITensors.MPS","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS\n\nA finite size matrix product state type. Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#ITensors.MPO","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO\n\nA finite size matrix product operator type.  Keeps track of the orthogonality center.\n\n\n\n\n\n","category":"type"},{"location":"MPSandMPO.html#MPS-Constructors-1","page":"MPS and MPO","title":"MPS Constructors","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPS(::Int)\nMPS(::Type{<:Number}, ::Vector{<:Index})\nrandomMPS(sites::Vector{<:Index}; linkdim=1)\nrandomMPS(::Type{<:Number}, sites::Vector{<:Index}; linkdim=1)\nrandomMPS(sites::Vector{<:Index}, state; linkdim=1)\nproductMPS(::Vector{<:Index},states)\nproductMPS(::Type{<:Number},::Vector{<:Index},states)\nproductMPS(::Vector{<:IndexVal})\nproductMPS(::Type{<:Number}, ::Vector{<:IndexVal})","category":"page"},{"location":"MPSandMPO.html#ITensors.MPS-Tuple{Int64}","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS(N::Int)\n\nConstruct an MPS with N sites with default constructed ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPS-Tuple{Type{#s131} where #s131<:Number,Array{#s130,1} where #s130<:Index}","page":"MPS and MPO","title":"ITensors.MPS","text":"MPS([::Type{ElT} = Float64, ]sites)\n\nConstruct an MPS filled with Empty ITensors of type ElT from a collection of indices.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Array{#s131,1} where #s131<:Index}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(sites::Vector{<:Index}; linkdim=1)\n\nConstruct a random MPS with link dimension linkdim of  type Float64.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Type{#s131} where #s131<:Number,Array{#s130,1} where #s130<:Index}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(::Type{ElT<:Number}, sites::Vector{<:Index}; linkdim=1)\n\nConstruct a random MPS with link dimension linkdim of  type ElT.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.randomMPS-Tuple{Array{#s131,1} where #s131<:Index,Any}","page":"MPS and MPO","title":"ITensors.randomMPS","text":"randomMPS(sites::Vector{<:Index}, state; linkdim=1)\n\nConstruct a real, random MPS with link dimension linkdim, made by randomizing an initial product state specified by state. This version of randomMPS is necessary when creating QN-conserving random MPS (consisting of QNITensors). The initial state array provided determines the total QN of the resulting random MPS.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Array{#s131,1} where #s131<:Index,Any}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(sites::Vector{<:Index},states)\n\nConstruct a product state MPS having site indices sites, and which corresponds to the initial state given by the array states. The states array may consist of either an array of integers or strings, as  recognized by the state function defined for the relevant Index tag type.\n\n#Examples\n\nN = 10\nsites = siteinds(\"S=1/2\",N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi = productMPS(sites,states)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Type{#s131} where #s131<:Number,Array{#s130,1} where #s130<:Index,Any}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(::Type{T},sites::Vector{<:Index},states)\n\nConstruct a product state MPS of element type T, having site indices sites, and which corresponds to the initial state given by the array states. The states array may consist of either an array of integers or strings, as  recognized by the state function defined for the relevant Index tag type.\n\n#Examples\n\nN = 10\nsites = siteinds(\"S=1/2\",N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi = productMPS(ComplexF64,sites,states)\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Array{#s131,1} where #s131<:IndexVal}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(ivals::Vector{<:IndexVal})\n\nConstruct a product state MPS with element type Float64 and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.productMPS-Tuple{Type{#s131} where #s131<:Number,Array{#s130,1} where #s130<:IndexVal}","page":"MPS and MPO","title":"ITensors.productMPS","text":"productMPS(::Type{T<:Number}, ivals::Vector{<:IndexVal})\n\nConstruct a product state MPS with element type T and nonzero values determined from the input IndexVals.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#MPO-Constructors-1","page":"MPS and MPO","title":"MPO Constructors","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"MPO(::Int)\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::Vector{String})\nMPO(::Type{<:Number}, ::Vector{<:Index}, ::String)","category":"page"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Int64}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO(N::Int)\n\nMake an MPO of length N filled with default ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Type{#s131} where #s131<:Number,Array{#s130,1} where #s130<:Index,Array{String,1}}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO([::Type{ElT} = Float64}, ]sites, ops::Vector{String})\n\nMake an MPO with pairs of sites s[i] and s[i]' and operators ops on each site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.MPO-Tuple{Type{#s131} where #s131<:Number,Array{#s130,1} where #s130<:Index,String}","page":"MPS and MPO","title":"ITensors.MPO","text":"MPO([::Type{ElT} = Float64, ]sites, op::String)\n\nMake an MPO with pairs of sites s[i] and s[i]' and operator op on every site.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Properties-1","page":"MPS and MPO","title":"Properties","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"length(::ITensors.AbstractMPS)\nmaxlinkdim(::ITensors.AbstractMPS)\nlinkind(::ITensors.AbstractMPS,::Int)","category":"page"},{"location":"MPSandMPO.html#Base.length-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"Base.length","text":"length(::MPS/MPO)\n\nThe number of sites of an MPS/MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.maxlinkdim-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.maxlinkdim","text":"maxlinkdim(M::MPS)\n\nmaxlinkdim(M::MPO)\n\nGet the maximum link dimension of the MPS or MPO.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.linkind-Tuple{ITensors.AbstractMPS,Int64}","page":"MPS and MPO","title":"ITensors.linkind","text":"linkind(M::MPS, j::Int)\n\nlinkind(M::MPO, j::Int)\n\nGet the link or bond Index connecting the MPS or MPO tensor on site j to site j+1\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Priming-and-tagging-1","page":"MPS and MPO","title":"Priming and tagging","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"prime(::ITensors.AbstractMPS)\nprime!(::ITensors.AbstractMPS)\nsetprime(::ITensors.AbstractMPS)\nsetprime!(::ITensors.AbstractMPS)\nnoprime(::ITensors.AbstractMPS)\nnoprime!(::ITensors.AbstractMPS)\naddtags(::ITensors.AbstractMPS)\naddtags!(::ITensors.AbstractMPS)\nremovetags(::ITensors.AbstractMPS)\nremovetags!(::ITensors.AbstractMPS)\nreplacetags(::ITensors.AbstractMPS)\nreplacetags!(::ITensors.AbstractMPS)\nsettags(::ITensors.AbstractMPS)\nsettags!(::ITensors.AbstractMPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.prime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime","text":"prime(M::MPS, args...; kwargs...)\n\nprime(M::MPO, args...; kwargs...)\n\nApply prime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.prime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.prime!","text":"prime!(M::MPS, args...; kwargs...)\n\nprime!(M::MPO, args...; kwargs...)\n\nApply prime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime","text":"setprime(M::MPS, args...; kwargs...)\n\nsetprime(M::MPO, args...; kwargs...)\n\nApply setprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.setprime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.setprime!","text":"setprime!(M::MPS, args...; kwargs...)\n\nsetprime!(M::MPO, args...; kwargs...)\n\nApply setprime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime","text":"noprime(M::MPS, args...; kwargs...)\n\nnoprime(M::MPO, args...; kwargs...)\n\nApply noprime to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.noprime!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.noprime!","text":"noprime!(M::MPS, args...; kwargs...)\n\nnoprime!(M::MPO, args...; kwargs...)\n\nApply noprime to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.addtags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.addtags","text":"addtags(M::MPS, args...; kwargs...)\n\naddtags(M::MPO, args...; kwargs...)\n\nApply addtags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.addtags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.addtags!","text":"addtags!(M::MPS, args...; kwargs...)\n\naddtags!(M::MPO, args...; kwargs...)\n\nApply addtags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.removetags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.removetags","text":"removetags(M::MPS, args...; kwargs...)\n\nremovetags(M::MPO, args...; kwargs...)\n\nApply removetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.removetags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.removetags!","text":"removetags!(M::MPS, args...; kwargs...)\n\nremovetags!(M::MPO, args...; kwargs...)\n\nApply removetags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.replacetags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.replacetags","text":"replacetags(M::MPS, args...; kwargs...)\n\nreplacetags(M::MPO, args...; kwargs...)\n\nApply replacetags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.replacetags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.replacetags!","text":"replacetags!(M::MPS, args...; kwargs...)\n\nreplacetags!(M::MPO, args...; kwargs...)\n\nApply replacetags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags","text":"settags(M::MPS, args...; kwargs...)\n\nsettags(M::MPO, args...; kwargs...)\n\nApply settags to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.settags!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.settags!","text":"settags!(M::MPS, args...; kwargs...)\n\nsettags!(M::MPO, args...; kwargs...)\n\nApply settags to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Operations-1","page":"MPS and MPO","title":"Operations","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"dag(::ITensors.AbstractMPS)\ndag!(::ITensors.AbstractMPS)\northogonalize!\ntruncate!\nreplacebond!(::MPS, ::Int, ::ITensor)\nsample(::MPS)\nsample!(::MPS)","category":"page"},{"location":"MPSandMPO.html#ITensors.dag-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.dag","text":"dag(M::MPS, args...; kwargs...)\n\ndag(M::MPO, args...; kwargs...)\n\nApply dag to all ITensors of an MPS/MPO, returning a new MPS/MPO.\n\nThe ITensors of the MPS/MPO will be a view of the storage of the original ITensors.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.dag!-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.dag!","text":"dag!(M::MPS, args...; kwargs...)\n\ndag!(M::MPO, args...; kwargs...)\n\nApply dag to all ITensors of an MPS/MPO in-place.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.orthogonalize!","page":"MPS and MPO","title":"ITensors.orthogonalize!","text":"orthogonalize!(M::MPS, j::Int; kwargs...)\n\northogonalize!(M::MPO, j::Int; kwargs...)\n\nMove the orthogonality center of the MPS to site j. No observable property of the MPS will be changed, and no truncation of the bond indices is performed. Afterward, tensors 1,2,...,j-1 will be left-orthogonal and tensors j+1,j+2,...,N will be right-orthogonal.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#NDTensors.truncate!","page":"MPS and MPO","title":"NDTensors.truncate!","text":"truncate!(M::MPS; kwargs...)\n\ntruncate!(M::MPO; kwargs...)\n\nPerform a truncation of all bonds of an MPS/MPO, using the truncation parameters (cutoff,maxdim, etc.) provided as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"MPSandMPO.html#ITensors.replacebond!-Tuple{MPS,Int64,ITensor}","page":"MPS and MPO","title":"ITensors.replacebond!","text":"replacebond!(M::MPS, b::Int, phi::ITensor; kwargs...)\n\nFactorize the ITensor phi and replace the ITensors b and b+1 of MPS M with the factors. Choose the orthogonality with ortho=\"left\"/\"right\".\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.sample-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.sample","text":"sample(m::MPS)\n\nGiven a normalized MPS m with orthocenter(m)==1, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.sample!-Tuple{MPS}","page":"MPS and MPO","title":"ITensors.sample!","text":"sample!(m::MPS)\n\nGiven a normalized MPS m, returns a Vector{Int} of length(m) corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents. If the MPS does not have an orthogonality center, orthogonalize!(m,1) will be called before computing the sample.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Algebra-Operations-1","page":"MPS and MPO","title":"Algebra Operations","text":"","category":"section"},{"location":"MPSandMPO.html#","page":"MPS and MPO","title":"MPS and MPO","text":"dot(::MPST, ::MPST) where {MPST <: ITensors.AbstractMPS}\nlogdot(::MPST, ::MPST) where {MPST <: ITensors.AbstractMPS}\nnorm(::ITensors.AbstractMPS)\nlognorm(::ITensors.AbstractMPS)\n+(::MPS, ::MPS)\n*(::MPO, ::MPS)","category":"page"},{"location":"MPSandMPO.html#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST,MPST}} where MPST<:ITensors.AbstractMPS","page":"MPS and MPO","title":"LinearAlgebra.dot","text":"dot(A::MPS, B::MPS; make_inds_match = true)\ninner(A::MPS, B::MPS; make_inds_match = true)\n\ndot(A::MPO, B::MPO)\ninner(A::MPO, B::MPO)\n\nCompute the inner product <A|B>. If A and B are MPOs, computes the Frobenius inner product.\n\nIf make_inds_match = true, the function attempts to make the site indices match before contracting (so for example, the inputs can have different site indices, as long as they have the same dimensions or QN blocks).\n\nFor now, make_inds_match is only supported for MPSs.\n\nSee also logdot/loginner.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.logdot-Union{Tuple{MPST}, Tuple{MPST,MPST}} where MPST<:ITensors.AbstractMPS","page":"MPS and MPO","title":"ITensors.logdot","text":"logdot(A::MPS, B::MPS; make_inds_match = true)\nloginner(A::MPS, B::MPS; make_inds_match = true)\n\nlogdot(A::MPO, B::MPO)\nloginner(A::MPO, B::MPO)\n\nCompute the logarithm of the inner product <A|B>. If A and B are MPOs, computes the logarithm of the Frobenius inner product.\n\nThis is useful for larger MPS/MPO, where in the limit of large numbers of sites the inner product can diverge or approach zero.\n\nIf make_inds_match = true, the function attempts to make the site indices match before contracting (so for example, the inputs can have different site indices, as long as they have the same dimensions or QN blocks).\n\nFor now, make_inds_match is only supported for MPSs.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#LinearAlgebra.norm-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"LinearAlgebra.norm","text":"norm(A::MPS)\n\nnorm(A::MPO)\n\nCompute the norm of the MPS or MPO.\n\nSee also lognorm.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#ITensors.lognorm-Tuple{ITensors.AbstractMPS}","page":"MPS and MPO","title":"ITensors.lognorm","text":"lognorm(A::MPS)\n\nlognorm(A::MPO)\n\nCompute the logarithm of the norm of the MPS or MPO. \n\nThis is useful for larger MPS/MPO that are not gauged, where in the limit of large numbers of sites the norm can diverge or approach zero.\n\nSee also norm and loginner/logdot.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:+-Tuple{MPS,MPS}","page":"MPS and MPO","title":"Base.:+","text":"add(A::MPS, B::MPS; kwargs...)\n+(A::MPS, B::MPS; kwargs...)\n\nadd(A::MPO, B::MPO; kwargs...)\n+(A::MPO, B::MPO; kwargs...)\n\nAdd two MPS/MPO with each other, with some optional truncation.\n\n\n\n\n\n","category":"method"},{"location":"MPSandMPO.html#Base.:*-Tuple{MPO,MPS}","page":"MPS and MPO","title":"Base.:*","text":"contract(::MPS, ::MPO; kwargs...)\n*(::MPS, ::MPO; kwargs...)\n\ncontract(::MPO, ::MPS; kwargs...)\n*(::MPO, ::MPS; kwargs...)\n\nContract the MPO with the MPS, returning an MPS with the unique site indices of the MPO.\n\nChoose the method with the method keyword, for example \"densitymatrix\" and \"naive\".\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ProjMPO-1","page":"ProjMPO","title":"ProjMPO","text":"","category":"section"},{"location":"ProjMPO.html#Description-1","page":"ProjMPO","title":"Description","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"ProjMPO","category":"page"},{"location":"ProjMPO.html#ITensors.ProjMPO","page":"ProjMPO","title":"ITensors.ProjMPO","text":"A ProjMPO computes and stores the projection of an MPO into a basis defined by an MPS, leaving a certain number of site indices of the MPO unprojected. Which sites are unprojected can be shifted by calling the position! method.\n\nDrawing of the network represented by a ProjMPO P(H),  showing the case of nsite(P)==2 and position!(P,psi,4)  for an MPS psi:\n\no--o--o-      -o--o--o--o--o--o <psi|\n|  |  |  |  |  |  |  |  |  |  |\no--o--o--o--o--o--o--o--o--o--o H\n|  |  |  |  |  |  |  |  |  |  |\no--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPO.html#Methods-1","page":"ProjMPO","title":"Methods","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"product(::ProjMPO,::ITensor)\nposition!(::ProjMPO, ::MPS, ::Int)\nnoiseterm(::ProjMPO,::ITensor,::String)","category":"page"},{"location":"ProjMPO.html#ITensors.product-Tuple{ProjMPO,ITensor}","page":"ProjMPO","title":"ITensors.product","text":"product(P::ProjMPO,v::ITensor{N})::ITensor{N}\n\n(P::ProjMPO)(v::ITensor)\n\nEfficiently multiply the ProjMPO P by an ITensor v in the sense that the ProjMPO is a generalized square matrix or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensors.position!-Tuple{ProjMPO,MPS,Int64}","page":"ProjMPO","title":"ITensors.position!","text":"position!(P::ProjMPO, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPO P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPO on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#ITensors.noiseterm-Tuple{ProjMPO,ITensor,String}","page":"ProjMPO","title":"ITensors.noiseterm","text":"noiseterm(P::ProjMPO,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the  ProjMPO P, and ortho is a String which can take the values \"left\" or \"right\" depending on the  sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Properties-1","page":"ProjMPO","title":"Properties","text":"","category":"section"},{"location":"ProjMPO.html#","page":"ProjMPO","title":"ProjMPO","text":"length(::ProjMPO)\neltype(::ProjMPO)\nsize(::ProjMPO)","category":"page"},{"location":"ProjMPO.html#Base.length-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.length","text":"length(P::ProjMPO)\n\nThe length of a ProjMPO is the same as the length of the MPO used to construct it\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.eltype-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.eltype","text":"eltype(P::ProjMPO)\n\nDeduce the element type (such as Float64 or ComplexF64) of the tensors in the ProjMPO P.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPO.html#Base.size-Tuple{ProjMPO}","page":"ProjMPO","title":"Base.size","text":"size(P::ProjMPO)\n\nThe size of a ProjMPO are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d. \n\nFor example, if a ProjMPO maps from a space with  indices (a,s1,s2,b) to the space (a',s1',s2',b')  then the size is (d,d) where  d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ProjMPOSum-1","page":"ProjMPOSum","title":"ProjMPOSum","text":"","category":"section"},{"location":"ProjMPOSum.html#Description-1","page":"ProjMPOSum","title":"Description","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"ProjMPOSum","category":"page"},{"location":"ProjMPOSum.html#ITensors.ProjMPOSum","page":"ProjMPOSum","title":"ITensors.ProjMPOSum","text":"A ProjMPOSum computes and stores the projection of an implied sum of MPOs into a basis defined by an MPS,  leaving a certain number of site indices of each MPO  unprojected. Which sites are unprojected can be shifted  by calling the position! method. The MPOs used as  input to a ProjMPOSum are not added together beforehand; instead when the product method of a ProjMPOSum is invoked, each projected MPO in the set of MPOs is multiplied by the input tensor one-by-one in an efficient way.\n\nDrawing of the network represented by a ProjMPOSum  P([H1,H2,...]), showing the case of nsite(P)==2  and position!(P,psi,4) for an MPS psi (note the sum Σⱼ on the left):\n\n     o--o--o-      -o--o--o--o--o--o <psi|\n     |  |  |  |  |  |  |  |  |  |  |\n Σⱼ  o--o--o--o--o--o--o--o--o--o--o Hⱼ\n     |  |  |  |  |  |  |  |  |  |  |\n     o--o--o-      -o--o--o--o--o--o |psi>\n\n\n\n\n\n","category":"type"},{"location":"ProjMPOSum.html#Methods-1","page":"ProjMPOSum","title":"Methods","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"product(::ProjMPOSum,::ITensor)\nposition!(::ProjMPOSum, ::MPS, ::Int)\nnoiseterm(::ProjMPOSum,::ITensor,::String)","category":"page"},{"location":"ProjMPOSum.html#ITensors.product-Tuple{ProjMPOSum,ITensor}","page":"ProjMPOSum","title":"ITensors.product","text":"product(P::ProjMPOSum,v::ITensor)\n\n(P::ProjMPOSum)(v::ITensor)\n\nEfficiently multiply the ProjMPOSum P by an ITensor v in the sense that the ProjMPOSum is a generalized square matrix  or linear operator and v is a generalized vector in the space where it acts. The returned ITensor will have the same indices as v. The operator overload P(v) is shorthand for product(P,v).\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensors.position!-Tuple{ProjMPOSum,MPS,Int64}","page":"ProjMPOSum","title":"ITensors.position!","text":"position!(P::ProjMPOSum, psi::MPS, pos::Int)\n\nGiven an MPS psi, shift the projection of the MPO represented by the ProjMPOSum P such that the set of unprojected sites begins with site pos. This operation efficiently reuses previous projections of the MPOs on sites that have already been projected. The MPS psi must have compatible bond indices with the previous projected MPO tensors for this operation to succeed.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#ITensors.noiseterm-Tuple{ProjMPOSum,ITensor,String}","page":"ProjMPOSum","title":"ITensors.noiseterm","text":"noiseterm(P::ProjMPOSum,\n          phi::ITensor,\n          ortho::String)\n\nReturn a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor phi is the contracted product of MPS tensors acted on by the  ProjMPOSum P, and ortho is a String which can take the values \"left\" or \"right\" depending on the  sweeping direction of the DMRG calculation.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Properties-1","page":"ProjMPOSum","title":"Properties","text":"","category":"section"},{"location":"ProjMPOSum.html#","page":"ProjMPOSum","title":"ProjMPOSum","text":"length(::ProjMPOSum)\neltype(::ProjMPOSum)\nsize(::ProjMPOSum)","category":"page"},{"location":"ProjMPOSum.html#Base.length-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.length","text":"length(is::IndexSet)\n\nThe number of indices in the IndexSet.\n\n\n\n\n\nlength(::Type{<:IndexSet})\n\nThe number of indices in the IndexSet type.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Base.eltype-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.eltype","text":"eltype(::IndexSet)\n\nGet the element type of the IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"ProjMPOSum.html#Base.size-Tuple{ProjMPOSum}","page":"ProjMPOSum","title":"Base.size","text":"size(P::ProjMPOSum)\n\nThe size of a ProjMPOSum are its dimensions (d,d) when viewed as a matrix or linear operator acting on a space of dimension d. \n\nFor example, if a ProjMPOSum maps from a space with  indices (a,s1,s2,b) to the space (a',s1',s2',b')  then the size is (d,d) where  d = dim(a)*dim(s1)*dim(s1)*dim(b)\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensor-1","page":"ITensor","title":"ITensor","text":"","category":"section"},{"location":"ITensorType.html#Description-1","page":"ITensor","title":"Description","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor","category":"page"},{"location":"ITensorType.html#ITensors.ITensor","page":"ITensor","title":"ITensors.ITensor","text":"An ITensor is a tensor whose interface is  independent of its memory layout. Therefore it is not necessary to know the ordering of an ITensor's indices, only which indices an ITensor has. Operations like contraction and addition of ITensors automatically handle any memory permutations.\n\n\n\n\n\n","category":"type"},{"location":"ITensorType.html#Dense-Constructors-1","page":"ITensor","title":"Dense Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor(::Type{<:Number}, ::ITensors.Indices)\nITensor(::Type{<:Number}, ::UndefInitializer, ::ITensors.Indices)\nrandomITensor(::Type{<:Number}, ::ITensors.Indices)\nsetelt(::IndexVal)","category":"page"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s131} where #s131<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ]inds)\nITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor filled with zeros having indices inds and element type ElT. If the element type is not specified, it defaults to Float64.\n\nThe storage will have NDTensors.Dense type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s131} where #s131<:Number,UndefInitializer,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)\nITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...)\n\nConstruct an ITensor filled with undefined elements having indices inds and element type ElT. If the element type is not specified, it defaults to Float64.\n\nThe storage will have NDTensors.Dense type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.randomITensor-Tuple{Type{#s131} where #s131<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.randomITensor","text":"randomITensor([::Type{ElT <: Number} = Float64, ]inds)\n\nrandomITensor([::Type{ElT <: Number} = Float64, ]inds::Index...)\n\nConstruct an ITensor with type ElT and indices inds, whose elements are normally distributed random numbers. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.setelt-Tuple{IndexVal}","page":"ITensor","title":"ITensors.setelt","text":"setelt(iv)\n\nCreate an ITensor with all zeros except the specified value, which is set to 1.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-BlockSparse-Constructors-1","page":"ITensor","title":"QN BlockSparse Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"ITensor(::Type{<:Number}, ::QN, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.ITensor-Tuple{Type{#s131} where #s131<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.ITensor","text":"ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds)\nITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds::Index...)\n\nConstruct an ITensor with BlockSparse storage filled with zero(ElT) where the nonzero blocks are determined by flux.\n\nIf ElT is not specified it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Empty-Constructors-1","page":"ITensor","title":"Empty Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"emptyITensor(::Type{<:Number}, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.emptyITensor-Tuple{Type{#s131} where #s131<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.emptyITensor","text":"emptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor with storage type NDTensors.Empty, indices inds, and element type ElT. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-Empty-Constructors-1","page":"ITensor","title":"QN Empty Constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"emptyITensor(::Type{<:Number}, ::ITensors.QNIndices)","category":"page"},{"location":"ITensorType.html#ITensors.emptyITensor-Tuple{Type{#s131} where #s131<:Number,Union{Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}, IndexSet{N,Index{Array{Pair{QN,Int64},1}},Tuple{Vararg{Index{Array{Pair{QN,Int64},1}},N}}}} where N}","page":"ITensor","title":"ITensors.emptyITensor","text":"emptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nConstruct an ITensor with storage type NDTensors.Empty, indices inds, and element type ElT. If the element type is not specified, it defaults to Float64.\n\n\n\n\n\nemptyITensor([::Type{ElT} = Float64, ]inds)\nemptyITensor([::Type{ElT} = Float64, ]inds::QNIndex...)\n\nConstruct an ITensor with NDTensors.BlockSparse storage of element type ElT with the no blocks.\n\nIf ElT is not specified it defaults to Float64.\n\nIn the future, this will use the storage NDTensors.EmptyBlockSparse.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Diagonal-constructors-1","page":"ITensor","title":"Diagonal constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"diagITensor(::Type{<:Number}, ::ITensors.Indices)\ndiagITensor(::Vector{<:Number}, ::ITensors.Indices)\ndiagITensor(::Number, ::ITensors.Indices)\ndelta(::Type{<:Number}, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Type{#s131} where #s131<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor([::Type{ElT} = Float64, ]inds)\ndiagITensor([::Type{ElT} = Float64, ]inds::Index...)\n\nMake a sparse ITensor of element type ElT with only elements along the diagonal stored. Defaults to having zero(T) along  the diagonal.\n\nThe storage will have NDTensors.Diag type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Array{#s131,1} where #s131<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor(v::Vector{T}, inds)\ndiagITensor(v::Vector{T}, inds::Index...)\n\nMake a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the values stored in v and  the ITensor will have element type float(T). The storage will have type NDTensors.Diag.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor(x::Number, inds)\ndiagITensor(x::Number, inds::Index...)\n\nMake a sparse ITensor with non-zero elements only along the diagonal.  The diagonal elements will be set to the value float(x) and the ITensor will have element type float(eltype(x)). The storage will have NDTensors.Diag type.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.delta-Tuple{Type{#s131} where #s131<:Number,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.delta","text":"delta([::Type{ElT} = Float64, ]inds)\ndelta([::Type{ElT} = Float64, ]inds::Index...)\n\nMake a uniform diagonal ITensor with all diagonal elements one(ElT). Only a single diagonal element is stored.\n\nThis function has an alias δ.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#QN-Diagonal-constructors-1","page":"ITensor","title":"QN Diagonal constructors","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"diagITensor(::Type{<:Number}, ::QN, ::ITensors.Indices)\ndelta(::Type{<:Number}, ::QN, ::ITensors.Indices)","category":"page"},{"location":"ITensorType.html#ITensors.diagITensor-Tuple{Type{#s131} where #s131<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.diagITensor","text":"diagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndiagITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)\n\nMake an ITensor with storage type NDTensors.DiagBlockSparse with elements zero(ElT). The ITensor only has diagonal blocks consistent with the specified flux.\n\nIf the element type is not specified, it defaults to Float64. If theflux is not specified, it defaults to QN().\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.delta-Tuple{Type{#s131} where #s131<:Number,QN,Union{Tuple{Vararg{IndexT,N}}, IndexSet{N,IndexT,Tuple{Vararg{IndexT,N}}}} where IndexT where N}","page":"ITensor","title":"ITensors.delta","text":"delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndelta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...)\n\nMake an ITensor with storage type NDTensors.DiagBlockSparse with uniform elements one(ElT). The ITensor only has diagonal blocks consistent with the specified flux.\n\nIf the element type is not specified, it defaults to Float64. If theflux is not specified, it defaults to QN().\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Convert-to-Array-1","page":"ITensor","title":"Convert to Array","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"Array{ElT, N}(::ITensor{N}, ::Vararg{Index, N}) where {ElT, N}\narray(::ITensor)\nmatrix(::ITensor{2})\nvector(::ITensor{1})","category":"page"},{"location":"ITensorType.html#Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor{N},Vararg{Index,N}}} where N where ElT","page":"ITensor","title":"Core.Array","text":"Array{ElT}(T::ITensor, i:Index...)\nArray(T::ITensor, i:Index...)\n\nMatrix{ElT}(T::ITensor, row_i:Index, col_i::Index)\nMatrix(T::ITensor, row_i:Index, col_i::Index)\n\nVector{ElT}(T::ITensor)\nVector(T::ITensor)\n\nGiven an ITensor T with indices i..., returns an Array with a copy of the ITensor's elements. The order in which the indices are provided indicates the order of the data in the resulting Array.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.array-Tuple{ITensor}","page":"ITensor","title":"NDTensors.array","text":"array(T::ITensor)\n\nGiven an ITensor T, returns an Array with a copy of the ITensor's elements, or a view in the case the the ITensor's storage is Dense. The ordering of the elements in the Array, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. Therefore this method is intended for developer use only and not recommended for use in ITensor applications.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.matrix-Tuple{ITensor{2}}","page":"ITensor","title":"NDTensors.matrix","text":"matrix(T::ITensor)\n\nGiven an ITensor T with two indices, returns a Matrix with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense. The ordering of the elements in the Matrix, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. Therefore this method is intended for developer use only and not recommended for use in ITensor applications.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.vector-Tuple{ITensor{1}}","page":"ITensor","title":"NDTensors.vector","text":"vector(T::ITensor)\n\nGiven an ITensor T with one index, returns a Vector with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Getting-and-setting-elements-1","page":"ITensor","title":"Getting and setting elements","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"getindex(::ITensor, ::Any...)\ngetindex(::ITensor{N}, ::Vararg{Int,N}) where {N}\nsetindex!(::ITensor, ::Number, ::Any...)\nsetindex!(::ITensor, ::Number, ::Int...)","category":"page"},{"location":"ITensorType.html#Base.getindex-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"Base.getindex","text":"getindex(T::ITensor, ivs...)\n\nGet the specified element of the ITensor, using a list of IndexVals or Pair{<:Index, Int}.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(2.0, i, i')\nA[i => 1, i' => 2] # 2.0, same as: A[i' => 2, i => 1]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.getindex-Union{Tuple{N}, Tuple{ITensor{N},Vararg{Int64,N}}} where N","page":"ITensor","title":"Base.getindex","text":"getindex(T::ITensor, I::Int...)\n\nGet the specified element of the ITensor, using internal Index ordering of the ITensor.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(2.0, i, i')\nA[1, 2] # 2.0, same as: A[i => 1, i' => 2]\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.setindex!-Tuple{ITensor,Number,Vararg{Any,N} where N}","page":"ITensor","title":"Base.setindex!","text":"setindex!(T::ITensor, x::Number, ivs...)\n\nSet the specified element of the ITensor using a list of IndexVals or Pair{<:Index, Int}.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(i, i')\nA[i => 1, i' => 2] = 1.0 # same as: A[i' => 2, i => 1] = 1.0\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Base.setindex!-Tuple{ITensor,Number,Vararg{Int64,N} where N}","page":"ITensor","title":"Base.setindex!","text":"setindex!(T::ITensor, x::Number, I::Int...)\n\nSet the specified element of the ITensor, using internal Index ordering of the ITensor.\n\nExample\n\ni = Index(2; tags = \"i\")\nA = ITensor(i, i')\nA[1, 2] = 1.0 # same as: A[i => 1, i' => 2] = 1.0\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Properties-1","page":"ITensor","title":"Properties","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"inds(::ITensor)\nind(::ITensor, ::Int)","category":"page"},{"location":"ITensorType.html#NDTensors.inds-Tuple{ITensor}","page":"ITensor","title":"NDTensors.inds","text":"inds(T::ITensor)\n\nReturn the indices of the ITensor as an IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#NDTensors.ind-Tuple{ITensor,Int64}","page":"ITensor","title":"NDTensors.ind","text":"ind(T::ITensor, i::Int)\n\nGet the Index of the ITensor along dimension i.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Priming-and-tagging-1","page":"ITensor","title":"Priming and tagging","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"prime(::ITensor, ::Any...)\nsetprime(::ITensor, ::Any...)\nnoprime(::ITensor, ::Any...)\nmapprime(::ITensor, ::Any...)\nswapprime(::ITensor, ::Any...)\naddtags(::ITensor, ::Any...)\nremovetags(::ITensor, ::Any...)\nreplacetags(::ITensor, ::Any...)\nsettags(::ITensor, ::Any...)\nswaptags(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#ITensors.prime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.prime","text":"prime(A::ITensor, plinc::Int = 1; <keyword arguments>) -> ITensor\n\nprime!(A::ITensor, plinc::Int = 1; <keyword arguments>)\n\nIncrease the prime level of the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.setprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.setprime","text":"setprime(A::ITensor, plev::Int; <keyword arguments>) -> ITensor\n\nsetprime!(A::ITensor, plev::Int; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.noprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.noprime","text":"noprime(A::ITensor; <keyword arguments>) -> ITensor\n\nnoprime!(A::ITensor; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor to zero.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.mapprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.mapprime","text":"mapprime(A::ITensor, plold::Int, plnew::Int; <keyword arguments>) -> ITensor\n\nmapprime!(A::ITensor, plold::Int, plnew::Int; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor with prime level plold to plnew.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapprime-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapprime","text":"swapprime(A::ITensor, pl1::Int, pl2::Int; <keyword arguments>) -> ITensor\n\nswapprime!(A::ITensor, pl1::Int, pl2::Int; <keyword arguments>)\n\nSet the prime level of the indices of an ITensor with prime level pl1 to pl2, and those with prime level pl2 to pl1.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.addtags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.addtags","text":"addtags(A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\naddtags!(A::ITensor, ts::String; <keyword arguments>)\n\nAdd the tags ts to the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.removetags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.removetags","text":"removetags(A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nremovetags!(A::ITensor, ts::String; <keyword arguments>)\n\nRemove the tags ts from the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.replacetags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replacetags","text":"replacetags(A::ITensor, tsold::String, tsnew::String; <keyword arguments>) -> ITensor\n\nreplacetags!(A::ITensor, tsold::String, tsnew::String; <keyword arguments>)\n\nReplace the tags tsold with tsnew for the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.settags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.settags","text":"settags(A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nsettags!(A::ITensor, ts::String; <keyword arguments>)\n\nSet the tags of the indices of an ITensor to ts.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swaptags-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swaptags","text":"swaptags(A::ITensor, ts1::String, ts2::String; <keyword arguments>) -> ITensor\n\nswaptags!(A::ITensor, ts1::String, ts2::String; <keyword arguments>)\n\nSwap the tags ts1 with ts2 for the indices of an ITensor.\n\nOptionally, only modify the indices with the specified keyword arguments.\n\nArguments\n\ntags = nothing: if specified, only modify Index i if hastags(i, tags) == true. \nplev = nothing: if specified, only modify Index i if hasplev(i, plev) == true.\n\nIn both versions above, the ITensor storage is not modified or copied (so the first version returns an ITensor with a view of the original storage).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Index-Manipulations-1","page":"ITensor","title":"Index Manipulations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"replaceind(::ITensor, ::Any...)\nreplaceinds(::ITensor, ::Any...)\nswapind(::ITensor, ::Any...)\nswapinds(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#ITensors.replaceind-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replaceind","text":"replaceind(A::ITensor, i1::Index, i2::Index) -> ITensor\n\nreplaceind!(A::ITensor, i1::Index, i2::Index)\n\nReplace the Index i1 with the Index i2 in the ITensor.\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.replaceinds-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.replaceinds","text":"replaceinds(A::ITensor, inds1, inds2) -> ITensor\n\nreplaceinds!(A::ITensor, inds1, inds2)\n\nReplace the Index inds1[n] with the Index inds2[n] in the ITensor, where n runs from 1 to length(inds1) == length(inds2).\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\nThe storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapind-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapind","text":"swapind(A::ITensor, i1::Index, i2::Index) -> ITensor\n\nswapind!(A::ITensor, i1::Index, i2::Index)\n\nSwap the Index i1 with the Index i2 in the ITensor.\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#ITensors.swapinds-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"ITensors.swapinds","text":"swapinds(A::ITensor, inds1, inds2) -> ITensor\n\nswapinds!(A::ITensor, inds1, inds2)\n\nSwap the Index inds1[n] with the Index inds2[n] in the ITensor, where n runs from 1 to length(inds1) == length(inds2).\n\nThe indices must have the same space (i.e. the same dimension and QNs, if applicable).\n\nThe storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor).\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Math-operations-1","page":"ITensor","title":"Math operations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"*(::ITensor, ::ITensor)\nexp(::ITensor, ::Any)","category":"page"},{"location":"ITensorType.html#Base.:*-Tuple{ITensor,ITensor}","page":"ITensor","title":"Base.:*","text":"*(A::ITensor, B::ITensor)\n\nContract ITensors A and B to obtain a new ITensor. This  contraction * operator finds all matching indices common to A and B and sums over them, such that the result will  have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be  modified such that they no longer compare equal - for more information see the documentation on Index objects.\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Decompositions-1","page":"ITensor","title":"Decompositions","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"svd(::ITensor, ::Any...)\nfactorize(::ITensor, ::Any...)","category":"page"},{"location":"ITensorType.html#LinearAlgebra.svd-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"LinearAlgebra.svd","text":"svd(A::ITensor, inds::Index...; <keyword arguments>)\n\nSingular value decomposition (SVD) of an ITensor A, computed by treating the \"left indices\" provided collectively as a row index, and the remaining \"right indices\" as a column index (matricization of a tensor).\n\nThe first three return arguments are U, S, and V, such that A ≈ U * S * V.\n\nWhether or not the SVD performs a trunction depends on the keyword arguments provided. \n\nArguments\n\nmaxdim::Int: the maximum number of singular values to keep.\nmindim::Int: the minimum number of singular values to keep.\ncutoff::Float64: set the desired truncation error of the SVD, by default defined as the sum of the squares of the smallest singular values.\nlefttags::String = \"Link,u\": set the tags of the Index shared by U and S.\nrighttags::String = \"Link,v\": set the tags of the Index shared by S and V.\nalg::String = \"recursive\". Options:\n\"recursive\" - ITensor's custom svd. Very reliable, but may be slow if high precision is needed. To get an svd of a matrix A, an eigendecomposition of A^dagger A is used to compute U and then a qr of A^dagger U is used to compute V. This is performed recursively to compute small singular values.\n\"divide_and_conquer\" - A divide-and-conquer algorithm. LAPACK's gesdd.\n\"qr_iteration\" - Typically slower but more accurate than \"divide_and_conquer\". LAPACK's gesvd.\nuse_absolute_cutoff::Bool = false: set if all probability weights below the cutoff value should be discarded, rather than the sum of discarded weights.\nuse_relative_cutoff::Bool = true: set if the singular values should be normalized for the sake of truncation.\n\nSee also: factorize\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#LinearAlgebra.factorize-Tuple{ITensor,Vararg{Any,N} where N}","page":"ITensor","title":"LinearAlgebra.factorize","text":"factorize(A::ITensor, Linds::Index...; <keyword arguments>)\n\nPerform a factorization of A into ITensors L and R such that A ≈ L * R.\n\nArguments\n\northo::String = \"left\": Choose orthogonality properties of the factorization.\n\"left\": the left factor L is an orthogonal basis such that L * dag(prime(L, commonind(L,R))) ≈ I. \n\"right\": the right factor R forms an orthogonal basis. \n\"none\", neither of the factors form an orthogonal basis, and in general are made as symmetrically as possible (depending on the decomposition used).\nwhich_decomp::Union{String, Nothing} = nothing: choose what kind of decomposition is used. \nnothing: choose the decomposition automatically based on the other arguments. For example, when \"automatic\" is chosen and ortho = \"left\" or \"right\", svd or eigen is used depending on the provided cutoff (eigen is only used when the cutoff is greater than 1e-12, since it has a lower precision).\n\"svd\": L = U and R = S * V for ortho = \"left\", L = U * S and R = V for ortho = \"right\", and L = U * sqrt.(S) and R = sqrt.(S) * V for ortho = \"none\". To control which svd algorithm is choose, use the svd_alg keyword argument. See the documentation for svd for the supported algorithms, which are the same as those accepted by the alg keyword argument.\n\"eigen\": L = U and R = U^dagger A where U is determined from the eigendecompositon A A^dagger = U D U^dagger for ortho = \"left\" (and vice versa for ortho = \"right\"). \"eigen\" is not supported for ortho = \"none\".\n\nIn the future, other decompositions like QR, polar, cholesky, LU, etc. are expected to be supported.\n\nFor truncation arguments, see: svd\n\n\n\n\n\n","category":"method"},{"location":"ITensorType.html#Operations-1","page":"ITensor","title":"Operations","text":"","category":"section"},{"location":"ITensorType.html#","page":"ITensor","title":"ITensor","text":"permute(::ITensor, ::Any)","category":"page"},{"location":"ITensorType.html#ITensors.permute-Tuple{ITensor,Any}","page":"ITensor","title":"ITensors.permute","text":"permute(T::ITensors, inds; always_copy::Bool = false)\npermute(T::ITensors, inds::Index...; always_copy::Bool = false)\n\nReturn a new ITensor T with indices permuted according to the input indices inds. The storage of the ITensor is permuted accordingly.\n\nIf always_copy = false, it avoids copying data if possible. Therefore, it may return a view. Use always_copy = true if you never want it to return an ITensor with a view of the original ITensor.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#IndexSet-1","page":"IndexSet","title":"IndexSet","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"IndexSet(::Vector{<:Index})","category":"page"},{"location":"IndexSetType.html#ITensors.IndexSet-Tuple{Array{#s131,1} where #s131<:Index}","page":"IndexSet","title":"ITensors.IndexSet","text":"IndexSet(inds::Vector{<:Index})\n\nConvert a Vector of indices to an IndexSet.\n\nWarning: this is not type stable, since a Vector is dynamically sized and an IndexSet is statically sized. Consider using the constructor IndexSet{N}(inds::Vector).\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Priming-and-tagging-methods-1","page":"IndexSet","title":"Priming and tagging methods","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"prime(::IndexSet, ::Int)\nmap(::Function, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#ITensors.prime-Tuple{IndexSet,Int64}","page":"IndexSet","title":"ITensors.prime","text":"prime(A::IndexSet, plinc, ...)\n\nIncrease the prime level of the indices by the specified amount. Filter which indices are primed using keyword arguments tags, plev and id.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Base.map-Tuple{Function,IndexSet}","page":"IndexSet","title":"Base.map","text":"map(f, is::IndexSet)\n\nApply the function to the elements of the IndexSet, returning a new IndexSet.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Set-operations-1","page":"IndexSet","title":"Set operations","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"intersect(::IndexSet, ::IndexSet)\nfirstintersect(::IndexSet, ::IndexSet)\nsetdiff(::IndexSet, ::IndexSet)\nfirstsetdiff(::IndexSet, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#Base.intersect-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"Base.intersect","text":"intersect(A::IndexSet, B::IndexSet; kwargs...)\n\nOutput the IndexSet in the intersection of A and B, optionally filtering by tags, prime level, etc.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#ITensors.firstintersect-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"ITensors.firstintersect","text":"firstintersect(A::IndexSet, B::IndexSet; kwargs...)\n\nOutput the Index common to A and B, optionally filtering by tags, prime level, etc. If more than one Index is found, throw an error. Otherwise, return a default constructed Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Base.setdiff-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"Base.setdiff","text":"setdiff(A::IndexSet, Bs::IndexSet...)\n\nOutput the IndexSet with Indices in A but not in the IndexSets Bs.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#ITensors.firstsetdiff-Tuple{IndexSet,IndexSet}","page":"IndexSet","title":"ITensors.firstsetdiff","text":"firstsetdiff(A::IndexSet, Bs::IndexSet...)\n\nOutput the first Index in A that is not in the IndexSets Bs. Otherwise, return a default constructed Index.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Subsets-1","page":"IndexSet","title":"Subsets","text":"","category":"section"},{"location":"IndexSetType.html#","page":"IndexSet","title":"IndexSet","text":"getfirst(::Function, ::IndexSet)\ngetfirst(::IndexSet)\nfilter(::Function, ::IndexSet)","category":"page"},{"location":"IndexSetType.html#ITensors.getfirst-Tuple{Function,IndexSet}","page":"IndexSet","title":"ITensors.getfirst","text":"getfirst(f::Function, is::IndexSet)\n\nGet the first Index matching the pattern function, return nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#ITensors.getfirst-Tuple{IndexSet}","page":"IndexSet","title":"ITensors.getfirst","text":"getfirst(is::IndexSet)\n\nReturn the first Index in the IndexSet. If the IndexSet is empty, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"IndexSetType.html#Base.filter-Tuple{Function,IndexSet}","page":"IndexSet","title":"Base.filter","text":"filter(f::Function, inds::IndexSet)\n\nFilter the IndexSet by the given function (output a new IndexSet with indices i for which f(i) returns true).\n\nNote that this function is not type stable, since the number of output indices is not known at compile time.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#IndexVal-1","page":"IndexVal","title":"IndexVal","text":"","category":"section"},{"location":"IndexValType.html#Description-1","page":"IndexVal","title":"Description","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"IndexVal","category":"page"},{"location":"IndexValType.html#ITensors.IndexVal","page":"IndexVal","title":"ITensors.IndexVal","text":"An IndexVal represents an Index object set to a certain value.\n\n\n\n\n\n","category":"type"},{"location":"IndexValType.html#Constructors-1","page":"IndexVal","title":"Constructors","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"IndexVal(::Pair{<:Index, Int})","category":"page"},{"location":"IndexValType.html#ITensors.IndexVal-Tuple{Pair{#s131,Int64} where #s131<:Index}","page":"IndexVal","title":"ITensors.IndexVal","text":"IndexVal(i::Index, n::Int)\n\nIndexVal(iv::Pair{<:Index, Int})\n\n(i::Index)(n::Int)\n\nCreate an IndexVal from a pair of Index and Int.\n\nAlternatively, you can use the syntax i(n).\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#Properties-1","page":"IndexVal","title":"Properties","text":"","category":"section"},{"location":"IndexValType.html#","page":"IndexVal","title":"IndexVal","text":"ind(::IndexVal)\nval(::IndexVal)\nisindequal(::Index, ::IndexVal)","category":"page"},{"location":"IndexValType.html#NDTensors.ind-Tuple{IndexVal}","page":"IndexVal","title":"NDTensors.ind","text":"ind(iv::IndexVal)\n\nReturn the Index of the IndexVal.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#ITensors.val-Tuple{IndexVal}","page":"IndexVal","title":"ITensors.val","text":"val(iv::IndexVal)\n\nReturn the value of the IndexVal.\n\n\n\n\n\n","category":"method"},{"location":"IndexValType.html#ITensors.isindequal-Tuple{Index,IndexVal}","page":"IndexVal","title":"ITensors.isindequal","text":"isindequal(i::Index, iv::IndexVal)\n\nisindequal(i::IndexVal, iv::Index)\n\nisindequal(i::IndexVal, iv::IndexVal)\n\nCheck if the Index and IndexVal have the same indices.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Documentation Build Status\n(Image: ) (Image: ) (Image: Tests) (Image: codecov)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"ITensors is a library for rapidly creating correct and efficient tensor network algorithms. ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"An ITensor is a tensor whose interface  is independent of its memory layout. ITensor indices are objects which carry extra information and which 'recognize' each other (compare equal to each other).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The ITensor library also includes composable and extensible  algorithms for optimizing and transforming tensor networks, such as  matrix product state and matrix product operators, such as the DMRG algorithm.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Development of ITensor is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"page"},{"location":"index.html#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The ITensors package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"~ julia","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"julia> ]\n\npkg> add ITensors","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"julia> import Pkg; Pkg.add(\"ITensors\")","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Please note that right now, ITensors.jl requires that you use Julia v1.4 or later (since we are using a feature that was introduced in Julia v1.4). We will work on supporting older minor versions.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We recommend using ITensors.jl with Intel MKL in order to get the best possible performance. If you have not done so already, you can replace your current BLAS and LAPACK implementation with MKL by using the MKL.jl package. Please follow the instructions here.","category":"page"},{"location":"index.html#Documentation-1","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"STABLE –  documentation of the most recently tagged version.\nDEVEL – documentation of the in-development version.","category":"page"},{"location":"index.html#Code-Examples-1","page":"Introduction","title":"Code Examples","text":"","category":"section"},{"location":"index.html#Basic-Overview-1","page":"Introduction","title":"Basic Overview","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"ITensor construction, setting of elements, contraction, and addition. Before constructing an ITensor, one constructs Index objects representing tensor indices.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(3)\n  j = Index(5)\n  k = Index(2)\n  l = Index(7)\n\n  A = ITensor(i,j,k)\n  B = ITensor(j,l)\n\n  # Set elements of A\n  A[i=>1,j=>1,k=>1] = 11.1\n  A[i=>2,j=>1,k=>2] = -21.2\n  A[k=>1,i=>3,j=>1] = 31.1  # can provide Index values in any order\n  # ...\n\n  # A[k(1),i(3),j(1)] = 31.1  # alternative notation\n\n  # Contract over shared index j\n  C = A * B\n\n  @show hasinds(C,i,k,l) # = true\n\n  D = randomITensor(k,j,i) # ITensor with random elements\n\n  # Add two ITensors\n  # must have same set of indices\n  # but can be in any order\n  R = A + D\n\n  nothing\nend","category":"page"},{"location":"index.html#Singular-Value-Decomposition-(SVD)-of-a-Matrix-1","page":"Introduction","title":"Singular Value Decomposition (SVD) of a Matrix","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this example, we create a random 10x20 matrix  and compute its SVD. The resulting factors can  be simply multiplied back together using the ITensor * operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(10)           # index of dimension 10\n  j = Index(20)           # index of dimension 20\n  M = randomITensor(i,j)  # random matrix, indices i,j\n  U,S,V = svd(M,i)        # compute SVD with i as row index\n  @show M ≈ U*S*V         # = true\n\n  nothing\nend","category":"page"},{"location":"index.html#Singular-Value-Decomposition-(SVD)-of-a-Tensor-1","page":"Introduction","title":"Singular Value Decomposition (SVD) of a Tensor","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this example, we create a random 4x4x4x4 tensor  and compute its SVD, temporarily treating the first and third indices (i and k) as the \"row\" index and the second and fourth indices (j and l) as the \"column\" index for the purposes of the SVD. The resulting factors can  be simply multiplied back together using the ITensor * operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(4,\"i\")\n  j = Index(4,\"j\")\n  k = Index(4,\"k\")\n  l = Index(4,\"l\")\n  T = randomITensor(i,j,k,l)\n  U,S,V = svd(T,i,k)   # compute SVD with (i,k) as row indices (indices of U)\n  @show hasinds(U,i,k) # = true\n  @show hasinds(V,j,l) # = true\n  @show T ≈ U*S*V      # = true\n\n  nothing\nend","category":"page"},{"location":"index.html#Tensor-Indices:-Tags-and-Prime-Levels-1","page":"Introduction","title":"Tensor Indices: Tags and Prime Levels","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Before making an ITensor, you have to define its indices. Tensor Index objects carry extra information beyond just their dimension.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"All Index objects carry a permanent, immutable id number which is  determined when it is constructed, and allow it to be matched (compare equal) with copies of itself.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Additionally, an Index can have up to four tag strings, and an integer primelevel. If two Index objects have different tags or  different prime levels, they do not compare equal even if they have the same id.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Tags are also useful for identifying Index objects when printing tensors, and for performing certain Index manipulations (e.g. priming indices having certain sets of tags).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  i = Index(3)     # Index of dimension 3\n  @show dim(i)     # = 3\n  @show id(i)      # = 0x5d28aa559dd13001 or similar\n\n  ci = copy(i)\n  @show ci == i    # = true\n\n  j = Index(5,\"j\") # Index with a tag \"j\"\n\n  @show j == i     # = false\n\n  s = Index(2,\"n=1,Site\") # Index with two tags,\n                          # \"Site\" and \"n=1\"\n  @show hastags(s,\"Site\") # = true\n  @show hastags(s,\"n=1\")  # = true\n\n  i1 = prime(i) # i1 has a \"prime level\" of 1\n                # but otherwise same properties as i\n  @show i1 == i # = false, prime levels do not match\n\n  nothing\nend","category":"page"},{"location":"index.html#DMRG-Calculation-1","page":"Introduction","title":"DMRG Calculation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"DMRG is an iterative algorithm for finding the dominant eigenvector of an exponentially large, Hermitian matrix. It originates in physics with the purpose of finding eigenvectors of Hamiltonian (energy) matrices which model the behavior of quantum systems.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nlet\n  # Create 100 spin-one indices\n  N = 100\n  sites = siteinds(\"S=1\",N)\n\n  # Input operator terms which define \n  # a Hamiltonian matrix, and convert\n  # these terms to an MPO tensor network\n  # (here we make the 1D Heisenberg model)\n  ampo = AutoMPO()\n  for j=1:N-1\n    ampo +=     (\"Sz\",j,\"Sz\",j+1)\n    ampo += (0.5,\"S+\",j,\"S-\",j+1)\n    ampo += (0.5,\"S-\",j,\"S+\",j+1)\n  end\n  H = MPO(ampo,sites)\n\n  # Create an initial random matrix product state\n  psi0 = randomMPS(sites)\n\n  # Plan to do 5 passes or 'sweeps' of DMRG,\n  # setting maximum MPS internal dimensions \n  # for each sweep and maximum truncation cutoff\n  # used when adapting internal dimensions:\n  sweeps = Sweeps(5)\n  maxdim!(sweeps, 10,20,100,100,200)\n  cutoff!(sweeps, 1E-10)\n  @show sweeps\n\n  # Run the DMRG algorithm, returning energy \n  # (dominant eigenvalue) and optimized MPS\n  energy, psi = dmrg(H,psi0, sweeps)\n  println(\"Final energy = $energy\")\n\n  nothing\nend","category":"page"}]
}
