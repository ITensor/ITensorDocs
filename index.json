[{"id":3,"pagetitle":"Contraction sequence optimization","title":"Contraction sequence optimization","ref":"/ITensorDocs/ITensors/stable/#Contraction-sequence-optimization","content":" Contraction sequence optimization When contracting a tensor network, the sequence of contraction makes a big difference in the computational cost. However, the complexity of determining the optimal sequence grows exponentially with the number of tensors, but there are many heuristic algorithms available for computing optimal sequences for small networks [1] [2] [3] [4] [5] [6] . ITensors.jl imports functionality from  TensorOperations.jl  for helping you find the optimal contraction sequence for small tensor network, as we will show below."},{"id":4,"pagetitle":"Contraction sequence optimization","title":"Functions","ref":"/ITensorDocs/ITensors/stable/#Functions","content":" Functions"},{"id":5,"pagetitle":"Contraction sequence optimization","title":"ITensors.optimal_contraction_sequence","ref":"/ITensorDocs/ITensors/stable/#ITensors.optimal_contraction_sequence","content":" ITensors.optimal_contraction_sequence  —  Function optimal_contraction_sequence(T) Returns a contraction sequence for contracting the tensors  T . The sequence is generally optimal and is found via the optimaltree function in TensorOperations.jl which must be loaded. source"},{"id":6,"pagetitle":"Contraction sequence optimization","title":"ITensors.contraction_cost","ref":"/ITensorDocs/ITensors/stable/#ITensors.contraction_cost","content":" ITensors.contraction_cost  —  Function contraction_cost(A; sequence) Return the cost of contracting the collection of ITensors according to the specified sequence, where the cost is measured in the number of floating point operations that would need to be performed to contract dense tensors of the dimensions specified by the indices of the tensors (so for now, sparsity is ignored in computing the costs). Pairwise costs are returned in a vector (contracting  N  tensors requires  N-1  pairwise contractions). You can use  sum(contraction_cost(A; sequence))  to get the total cost of the contraction. If no sequence is specified, left associative contraction is used, in other words the sequence is equivalent to  [[[[1, 2], 3], 4], …] . source"},{"id":7,"pagetitle":"Contraction sequence optimization","title":"NDTensors.contract","ref":"/ITensorDocs/ITensors/stable/#NDTensors.contract","content":" NDTensors.contract  —  Function *(As::ITensor...; sequence = default_sequence(), kwargs...)\n*(As::Vector{<: ITensor}; sequence = default_sequence(), kwargs...)\ncontract(As::ITensor...; sequence = default_sequence(), kwargs...) Contract the set of ITensors according to the contraction sequence. The default sequence is \"automatic\" if  ITensors.using_contraction_sequence_optimization()  is true, otherwise it is \"left_associative\" (the ITensors are contracted from left to right). You can change the default with  ITensors.enable_contraction_sequence_optimization()  and  ITensors.disable_contraction_sequence_optimization() . For a custom sequence, the sequence should be provided as a binary tree where the leaves are integers  n  specifying the ITensor  As[n]  and branches are accessed by indexing with  1  or  2 , i.e.  sequence = Any[Any[1, 3], Any[2, 4]] . source"},{"id":8,"pagetitle":"Contraction sequence optimization","title":"Examples","ref":"/ITensorDocs/ITensors/stable/#Examples","content":" Examples In the following example we show how to compute the contraction sequence cost of a using ITensors\nusing Symbolics\n\nusing ITensors: contraction_cost\n\n@variables m, k, d\n\nl = Index(m, \"l\")\nr = Index(m, \"r\")\nh₁ = Index(k, \"h₁\")\nh₂ = Index(k, \"h₂\")\nh₃ = Index(k, \"h₃\")\ns₁ = Index(d, \"s₁\")\ns₂ = Index(d, \"s₂\")\n\nH₁ = ITensor(dag(s₁), s₁', dag(h₁), h₂)\nH₂ = ITensor(dag(s₂), s₂', dag(h₂), h₃)\nL = ITensor(dag(l), l', h₁)\nR = ITensor(dag(r), r', h₃)\nψ = ITensor(l, s₁, s₂, r)\n\nTN = [ψ, L, H₁, H₂, R]\nsequence1 = Any[2, Any[3, Any[4, Any[1, 5]]]]\nsequence2 = Any[Any[4, 5], Any[1, Any[2, 3]]]\ncost1 = contraction_cost(TN; sequence = sequence1)\ncost2 = contraction_cost(TN; sequence = sequence2)\n\nprintln(\"First sequence\")\ndisplay(sequence1)\ndisplay(cost1)\n@show sum(cost1)\n@show substitute(sum(cost1), Dict(d => 4))\n\nprintln(\"\\nSecond sequence\")\ndisplay(sequence2)\ndisplay(cost2)\n@show sum(cost2)\n@show substitute(sum(cost2), Dict(d => 4)) This example helps us learn that in the limit of large MPS bond dimension  m , the first contraction sequence is faster, while in the limit of large MPO bond dimension  k , the second sequence is faster. This has practical implications for writing an efficient DMRG algorithm in both limits, which we plan to incorporate into ITensors.jl. Here is a more systematic example of searching through the parameter space to find optimal contraction sequences. Note, the TensorOperations.jl library must be loaded to use the optimal contraction sequence function: using ITensors\nusing Symbolics\n\nusing ITensors: contraction_cost, optimal_contraction_sequence\nusing TensorOperations: TensorOperations\n\nfunction tensor_network(; m, k, d)\n  l = Index(m, \"l\")\n  r = Index(m, \"r\")\n  h₁ = Index(k, \"h₁\")\n  h₂ = Index(k, \"h₂\")\n  h₃ = Index(k, \"h₃\")\n  s₁ = Index(d, \"s₁\")\n  s₂ = Index(d, \"s₂\")\n\n  ψ = ITensor(l, s₁, s₂, r)\n  L = ITensor(dag(l), l', h₁)\n  H₁ = ITensor(dag(s₁), s₁', dag(h₁), h₂)\n  H₂ = ITensor(dag(s₂), s₂', dag(h₂), h₃)\n  R = ITensor(dag(r), r', h₃)\n  return [ψ, L, H₁, H₂, R]\nend\n\nfunction main()\n  mrange = 50:10:80\n  krange = 50:10:80\n  sequence_costs = Matrix{Any}(undef, length(mrange), length(krange))\n  for iₘ in eachindex(mrange), iₖ in eachindex(krange)\n    m_val = mrange[iₘ]\n    k_val = krange[iₖ]\n    d_val = 4\n\n    TN = tensor_network(; m = m_val, k = k_val, d = d_val)\n    sequence = optimal_contraction_sequence(TN)\n    cost = contraction_cost(TN; sequence = sequence)\n\n    @variables m, k, d\n    TN_symbolic = tensor_network(; m = m, k = k, d = d)\n    cost_symbolic = contraction_cost(TN_symbolic; sequence = sequence)\n    sequence_cost = (dims = (m = m_val, k = k_val, d = d_val), sequence = sequence, cost = cost, symbolic_cost = cost_symbolic)\n    sequence_costs[iₘ, iₖ] = sequence_cost\n  end\n  return sequence_costs\nend\n\nsequence_costs = main()\n\n# Analyze the results.\nprintln(\"Index dimensions\")\ndisplay(getindex.(sequence_costs, :dims))\n\nprintln(\"\\nContraction sequences\")\ndisplay(getindex.(sequence_costs, :sequence))\n\nprintln(\"\\nSymbolic contraction cost with d = 4\")\n# Fix d to a certain value (such as 4 for a Hubbard site)\n@variables d\nvar_sub = Dict(d => 4)\ndisplay(substitute.(sum.(getindex.(sequence_costs, :symbolic_cost)), (var_sub,))) A future direction will be to allow optimizing over contraction sequences with the dimensions specified symbolically, so that the optimal sequence in limits of certain dimensions can be found. In addition, we plan to implement more algorithms that work for larger networks, as well as algorithms like [2]  which take an optimal sequence for a closed network and generate optimal sequences for environments of each tensor in the network, which is helpful for computing gradients of tensor networks. 1 Faster identification of optimal contraction sequences for tensor networks 2 Improving the efficiency of variational tensor network algorithms 3 Simulating quantum computation by contracting tensor networks 4 Towards a polynomial algorithm for optimal contraction sequence of tensor networks from trees 5 Algorithms for Tensor Network Contraction Ordering 6 Hyper-optimized tensor network contraction"},{"id":11,"pagetitle":"HDF5 File Formats","title":"HDF5 File Formats","ref":"/ITensorDocs/ITensors/stable/#HDF5-File-Formats","content":" HDF5 File Formats This page lists the formats for the HDF5 representations of various types in the  ITensors  module. HDF5 is a portable file format which has a directory structure similar to a file system. In addition to containing \"groups\" (= directories) and \"datasets\" (= files), groups can have \"attributes\" appended to them, which are similar to 'tags' or 'keywords'. Unless otherwise specified, integers are 64 bit and are signed (H5T_STD_I64LE) unless explicitly stated. (For example, the \"id\" field of the  Index  type is stored as an unsigned 64 bit integer (H5T_STD_U64LE).) Each type in ITensor which is writeable to HDF5 is written to its own group, with the name of the group either specified by the user or specified to some default value when it is a subgroup of another ITensor type (for example, the  Index  type saves its  TagSet  in a subgroup named \"tags\"). Each group corresponding to an ITensors type always carries the following attributes: \"type\" –- a string such as  Index  or  TagSet  specifying the information necessary to determine the type of the object saved to the HDF5 group \"version\" –- an integer specifying the file format version used to store the data. This version is in general different from the release version of ITensors.jl. The purpose of the version number is to aid in maintaining backwards compatibility, while allowing the format to be occasionally changed. The C++ version of ITensor uses exactly the same file formats listed below, for the purpose of interoperability with the Julia version of ITensor, even though conventions such as the \"type\" field values are Julia-centric."},{"id":12,"pagetitle":"HDF5 File Formats","title":"TagSet","ref":"/ITensorDocs/ITensors/stable/#tagset_hdf5","content":" TagSet HDF5 file format for the  ITensors.TagSet  type. Attributes: \"version\" = 1 \"type\" = \"TagSet\" Datasets and Subgroups: \"tags\" [string] = a comma separated string of the tags in the  TagSet"},{"id":13,"pagetitle":"HDF5 File Formats","title":"QN","ref":"/ITensorDocs/ITensors/stable/#qn_hdf5","content":" QN HDF5 file format for the  ITensors.QN  type. Attributes: \"version\" = 1 \"type\" = \"QN\" Datasets and Subgroups: \"names\" [group] = array of strings (length 4) of names of quantum numbers \"vals\" [group] = array of integers (length 4) of quantum number values \"mods\" [group] = array of integers (length 4) of moduli of quantum numbers"},{"id":14,"pagetitle":"HDF5 File Formats","title":"QNBlocks","ref":"/ITensorDocs/ITensors/stable/#qnblocks_hdf5","content":" QNBlocks HDF5 file format for the  ITensors.QNBlocks  type. (Note:  QNBlocks  is equivalent to  Vector{Pair{QN, Int64}} .) Attributes: \"version\" = 1 \"type\" = \"QNBlocks\" Datasets and Subgroups: \"length\" [integer] = the number of blocks (length of Vector) \"dims\" [group] = array of (integer) dimensions of each block \"QN[n]\" [group] = these groups \"QN[1]\", \"QN[2]\", etc. correspond to the  QN  of each block"},{"id":15,"pagetitle":"HDF5 File Formats","title":"Index","ref":"/ITensorDocs/ITensors/stable/#index_hdf5","content":" Index HDF5 file format for the  ITensors.Index  type. Attributes: \"version\" = 1 \"type\" = \"Index\" \"space_type\" = \"Int\" if the Index is a regular, dense Index or \"QNBlocks\" if the Index is a QNIndex (carries QN subspace information) Datasets and Subgroups: \"id\" [unsigned integer] = id number of the Index \"dim\" [integer] = dimension of the Index \"dir\" [integer] = arrow direction of the Index, +1 for  ITensors.Out  and -1 for  ITensors.In \"plev\" [integer] = prime level of the Index \"tags\" [group] = the  TagSet  of the Index Optional Datasets and Subgroups: \"space\" [group] = if the  \"space_type\"  attribute is \"QNBlocks\", this group is present and represents a  QNBlocks  object"},{"id":16,"pagetitle":"HDF5 File Formats","title":"IndexSet","ref":"/ITensorDocs/ITensors/stable/#indexset_hdf5","content":" IndexSet HDF5 file format for types in the Union type  ITensors.Indices  which includes  IndexSet  and tuples of Index objects. Attributes: \"version\" = 1 \"type\" = \"IndexSet\" Datasets and Subgroups: \"length\" [integer] = number of indices \"index_n\" [group] = for n=1 to n=length each of these groups contains an Index"},{"id":17,"pagetitle":"HDF5 File Formats","title":"ITensor","ref":"/ITensorDocs/ITensors/stable/#itensor_hdf5","content":" ITensor HDF5 file format for the  ITensors.ITensor  type. Attributes: \"version\" = 1 \"type\" = \"ITensor\" Datasets and Subgroups: \"inds\" [group] = indices of the ITensor \"storage\" [group] = storage of the ITensor (note that some earlier versions of ITensors.jl may call this group \"store\")"},{"id":18,"pagetitle":"HDF5 File Formats","title":"NDTensors.Dense","ref":"/ITensorDocs/ITensors/stable/#dense_hdf5","content":" NDTensors.Dense HDF5 file format for objects which are subtypes of  ITensors.NDTensors.Dense . Attributes: \"version\" = 1 \"type\" = \"Dense{Float64}\" or \"Dense{ComplexF64}\" Datasets and Subgroups: \"data\" = array of either real or complex values (in the same dataset format used by the HDF5.jl library for storing  Vector{Float64}  or  Vector{ComplexF64} )"},{"id":19,"pagetitle":"HDF5 File Formats","title":"NDTensors.BlockSparse","ref":"/ITensorDocs/ITensors/stable/#blocksparse_hdf5","content":" NDTensors.BlockSparse HDF5 file format for objects which are subtypes of  ITensors.NDTensors.BlockSparse . Attributes: \"version\" = 1 \"type\" = \"BlockSparse{Float64}\" or \"BlockSparse{ComplexF64}\" Datasets and Subgroups: \"ndims\" [integer] = number of dimensions (order) of the tensor \"offsets\" = block offset data flattened into an array of integers \"data\" = array of either real or complex values (in the same dataset format used by the HDF5.jl library for storing  Vector{Float64}  or  Vector{ComplexF64} )"},{"id":22,"pagetitle":"ITensor","title":"ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensor","content":" ITensor"},{"id":23,"pagetitle":"ITensor","title":"Description","ref":"/ITensorDocs/ITensors/stable/#Description","content":" Description"},{"id":24,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor","content":" ITensors.ITensor  —  Type ITensor An ITensor is a tensor whose interface is independent of its memory layout. Therefore it is not necessary to know the ordering of an ITensor's indices, only which indices an ITensor has. Operations like contraction and addition of ITensors automatically handle any memory permutations. Examples julia> i = Index(2, \"i\")\n(dim=2|id=287|\"i\")\n\n#\n# Make an ITensor with random elements:\n#\njulia> A = random_itensor(i', i)\nITensor ord=2 (dim=2|id=287|\"i\")' (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")'\nDim 2: (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.28358594718392427   1.4342219756446355\n 1.6620103556283987   -0.40952231269251566\n\njulia> @show inds(A);\ninds(A) = ((dim=2|id=287|\"i\")', (dim=2|id=287|\"i\"))\n\n#\n# Set the i==1, i'==2 element to 1.0:\n#\njulia> A[i => 1, i' => 2] = 1;\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")'\nDim 2: (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.28358594718392427   1.4342219756446355\n 1.0                  -0.40952231269251566\n\njulia> @show storage(A);\nstorage(A) = [0.28358594718392427, 1.0, 1.4342219756446355, -0.40952231269251566]\n\njulia> B = random_itensor(i, i');\n\njulia> @show B;\nB = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")\nDim 2: (dim=2|id=287|\"i\")'\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n -0.6510816500352691   0.2579101497658179\n  0.256266641521826   -0.9464735926768166\n\n#\n# Can add or subtract ITensors as long as they\n# have the same indices, in any order:\n#\njulia> @show A + B;\nA + B = ITensor ord=2\nDim 1: (dim=2|id=287|\"i\")'\nDim 2: (dim=2|id=287|\"i\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n -0.3674957028513448   1.6904886171664615\n  1.2579101497658178  -1.3559959053693322 source"},{"id":25,"pagetitle":"ITensor","title":"Dense Constructors","ref":"/ITensorDocs/ITensors/stable/#Dense-Constructors","content":" Dense Constructors"},{"id":26,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor-Tuple{Type{<:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.ITensor  —  Method ITensor([::Type{ElT} = Float64, ]inds)\nITensor([::Type{ElT} = Float64, ]inds::Index...) Construct an ITensor filled with zeros having indices  inds  and element type  ElT . If the element type is not specified, it defaults to  Float64 . The storage will have  NDTensors.Dense  type. Examples i = Index(2,\"index_i\")\nj = Index(4,\"index_j\")\nk = Index(3,\"index_k\")\n\nA = ITensor(i,j)\nB = ITensor(ComplexF64,k,j) source"},{"id":27,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor-Tuple{Type{<:Number}, UndefInitializer, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.ITensor  —  Method ITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds)\nITensor([::Type{ElT} = Float64, ]::UndefInitializer, inds::Index...) Construct an ITensor filled with undefined elements having indices  inds  and element type  ElT . If the element type is not specified, it defaults to  Float64 . One purpose for using this constructor is that initializing the elements in an   undefined way is faster than initializing them to a set value such as zero. The storage will have  NDTensors.Dense  type. Examples i = Index(2,\"index_i\")\nj = Index(4,\"index_j\")\nk = Index(3,\"index_k\")\n\nA = ITensor(undef,i,j)\nB = ITensor(ComplexF64,undef,k,j) source"},{"id":28,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor-Tuple{Type{<:Number}, Number, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.ITensor  —  Method ITensor([ElT::Type, ]x::Number, inds)\nITensor([ElT::Type, ]x::Number, inds::Index...) Construct an ITensor with all elements set to  x  and indices  inds . If  x isa Int  or  x isa Complex{Int}  then the elements will be set to  float(x)    unless specified otherwise by the first input. The storage will have  NDTensors.Dense  type. Examples ```julia   i = Index(2,\"index i\"); j = Index(4,\"index j\"); k = Index(3,\"index_k\"); A = ITensor(1.0, i, j)   A = ITensor(1, i, j) # same as above   B = ITensor(2.0+3.0im, j, k)   ``` !!! warning       In future versions this may not automatically convert integer inputs with  float , and in that case the particular element type should not be relied on. source"},{"id":29,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor-Tuple{NDTensors.AliasStyle, Type{<:Number}, Array{<:Number}, Union{Tuple{Vararg{Index{Int64}}}, Vector{Index{Int64}}}}","content":" ITensors.ITensor  —  Method ITensor([ElT::Type, ]A::AbstractArray, inds)\nITensor([ElT::Type, ]A::AbstractArray, inds::Index...)\n\nitensor([ElT::Type, ]A::AbstractArray, inds)\nitensor([ElT::Type, ]A::AbstractArray, inds::Index...) Construct an ITensor from an AbstractArray  A  and indices  inds . The ITensor will be a view of the AbstractArray data if possible (if no conversion to a different element type is necessary). If specified, the ITensor will have element type  ElT . If the element type of  A  is  Int  or  Complex{Int}  and the desired element type isn't specified, it will be converted to  Float64  or  Complex{Float64}  automatically. To keep the element type as an integer, specify it explicitly, for example with: i = Index(2, \"i\")\nA = [0 1; 1 0]\nT = ITensor(eltype(A), A, i', dag(i)) Examples i = Index(2,\"index_i\")\nj = Index(2,\"index_j\")\n\nM = [1. 2;\n     3 4]\nT = ITensor(M, i, j)\nT[i => 1, j => 1] = 3.3\nM[1, 1] == 3.3\nT[i => 1, j => 1] == 3.3 Warning In future versions this may not automatically convert  Int / Complex{Int}  inputs to floating point versions with  float  (once tensor operations using  Int / Complex{Int}  are natively as fast as floating point operations), and in that case the particular element type should not be relied on. To avoid extra conversions (and therefore allocations) it is best practice to directly construct with  itensor([0. 1; 1 0], i', dag(i))  if you want a floating point element type. The conversion is done as a performance optimization since often tensors are passed to BLAS/LAPACK and need to be converted to floating point types compatible with those libraries, but future projects in Julia may allow for efficient operations with more general element types (for example see https://github.com/JuliaLinearAlgebra/Octavian.jl). source"},{"id":30,"pagetitle":"ITensor","title":"ITensors.random_itensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.random_itensor-Tuple{Type{<:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.random_itensor  —  Method random_itensor([rng=Random.default_rng()], [ElT=Float64], inds)\nrandom_itensor([rng=Random.default_rng()], [ElT=Float64], inds::Index...) Construct an ITensor with type  ElT  and indices  inds , whose elements are normally distributed random numbers. If the element type is not specified, it defaults to  Float64 . Examples i = Index(2,\"index_i\")\nj = Index(4,\"index_j\")\nk = Index(3,\"index_k\")\n\nA = random_itensor(i,j)\nB = random_itensor(ComplexF64,undef,k,j) source"},{"id":31,"pagetitle":"ITensor","title":"ITensors.onehot","ref":"/ITensorDocs/ITensors/stable/#ITensors.onehot","content":" ITensors.onehot  —  Function onehot(ivs...)\nsetelt(ivs...)\nonehot(::Type, ivs...)\nsetelt(::Type, ivs...) Create an ITensor with all zeros except the specified value, which is set to 1. Examples i = Index(2,\"i\")\nA = onehot(i=>2)\n# A[i=>2] == 1, all other elements zero\n\n# Specify the element type\nA = onehot(Float32, i=>2)\n\nj = Index(3,\"j\")\nB = onehot(i=>1,j=>3)\n# B[i=>1,j=>3] == 1, all other element zero source"},{"id":32,"pagetitle":"ITensor","title":"Dense View Constructors","ref":"/ITensorDocs/ITensors/stable/#Dense-View-Constructors","content":" Dense View Constructors"},{"id":33,"pagetitle":"ITensor","title":"ITensors.itensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.itensor-Tuple{Array{<:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.itensor  —  Method itensor(args...; kwargs...) Like the  ITensor  constructor, but with attempt to make a view of the input data when possible. source"},{"id":34,"pagetitle":"ITensor","title":"QN BlockSparse Constructors","ref":"/ITensorDocs/ITensors/stable/#QN-BlockSparse-Constructors","content":" QN BlockSparse Constructors"},{"id":35,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor-Tuple{Type{<:Number}, QN, Union{Tuple{Vararg{Index{Vector{Pair{QN, Int64}}}}}, Vector{Index{Vector{Pair{QN, Int64}}}}}}","content":" ITensors.ITensor  —  Method ITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds)\nITensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]inds::Index...) Construct an ITensor with BlockSparse storage filled with  zero(ElT)  where the nonzero blocks are determined by  flux . If  ElT  is not specified it defaults to  Float64 . If  flux  is not specified, the ITensor will be empty (it will contain no blocks, and have an undefined flux). The flux will be set by the first element that is set. Examples julia> i\n(dim=3|id=212|\"i\") <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\n\njulia> @show ITensor(QN(0), i', dag(i));\nITensor(QN(0), i', dag(i)) = ITensor ord=2\nDim 1: (dim=3|id=212|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=212|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.BlockSparse{Float64, Vector{Float64}, 2}\n 3×3\nBlock(1, 1)\n [1:1, 1:1]\n 0.0\n\nBlock(2, 2)\n [2:3, 2:3]\n 0.0  0.0\n 0.0  0.0\n\njulia> @show ITensor(QN(1), i', dag(i));\nITensor(QN(1), i', dag(i)) = ITensor ord=2\nDim 1: (dim=3|id=212|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=212|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.BlockSparse{Float64, Vector{Float64}, 2}\n 3×3\nBlock(2, 1)\n [2:3, 1:1]\n 0.0\n 0.0\n\njulia> @show ITensor(ComplexF64, QN(1), i', dag(i));\nITensor(ComplexF64, QN(1), i', dag(i)) = ITensor ord=2\nDim 1: (dim=3|id=212|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=212|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.BlockSparse{ComplexF64, Vector{ComplexF64}, 2}\n 3×3\nBlock(2, 1)\n [2:3, 1:1]\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> @show ITensor(undef, QN(1), i', dag(i));\nITensor(undef, QN(1), i', dag(i)) = ITensor ord=2\nDim 1: (dim=3|id=212|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=212|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.BlockSparse{Float64, Vector{Float64}, 2}\n 3×3\nBlock(2, 1)\n [2:3, 1:1]\n 0.0\n 1.63e-322 Construction with undefined flux: julia> A = ITensor(i', dag(i));\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=3|id=212|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=212|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.EmptyStorage{NDTensors.EmptyNumber, NDTensors.BlockSparse{NDTensors.EmptyNumber, Vector{NDTensors.EmptyNumber}, 2}}\n 3×3\n\n\n\njulia> isnothing(flux(A))\ntrue\n\njulia> A[i' => 1, i => 2] = 2\n2\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=3|id=212|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=212|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.BlockSparse{Int64, Vector{Int64}, 2}\n 3×3\nBlock(1, 2)\n [1:1, 2:3]\n 2  0\n\njulia> flux(A)\nQN(-1) source"},{"id":36,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor-Tuple{NDTensors.AliasStyle, Type{<:Number}, Array{<:Number}, Union{Tuple{Vararg{Index{Vector{Pair{QN, Int64}}}}}, Vector{Index{Vector{Pair{QN, Int64}}}}}}","content":" ITensors.ITensor  —  Method ITensor([ElT::Type, ]A::AbstractArray, inds)\nITensor([ElT::Type, ]A::AbstractArray, inds::Index...)\n\nitensor([ElT::Type, ]A::AbstractArray, inds)\nitensor([ElT::Type, ]A::AbstractArray, inds::Index...) Construct an ITensor from an AbstractArray  A  and indices  inds . The ITensor will be a view of the AbstractArray data if possible (if no conversion to a different element type is necessary). If specified, the ITensor will have element type  ElT . If the element type of  A  is  Int  or  Complex{Int}  and the desired element type isn't specified, it will be converted to  Float64  or  Complex{Float64}  automatically. To keep the element type as an integer, specify it explicitly, for example with: i = Index(2, \"i\")\nA = [0 1; 1 0]\nT = ITensor(eltype(A), A, i', dag(i)) Examples i = Index(2,\"index_i\")\nj = Index(2,\"index_j\")\n\nM = [1. 2;\n     3 4]\nT = ITensor(M, i, j)\nT[i => 1, j => 1] = 3.3\nM[1, 1] == 3.3\nT[i => 1, j => 1] == 3.3 Warning In future versions this may not automatically convert  Int / Complex{Int}  inputs to floating point versions with  float  (once tensor operations using  Int / Complex{Int}  are natively as fast as floating point operations), and in that case the particular element type should not be relied on. To avoid extra conversions (and therefore allocations) it is best practice to directly construct with  itensor([0. 1; 1 0], i', dag(i))  if you want a floating point element type. The conversion is done as a performance optimization since often tensors are passed to BLAS/LAPACK and need to be converted to floating point types compatible with those libraries, but future projects in Julia may allow for efficient operations with more general element types (for example see https://github.com/JuliaLinearAlgebra/Octavian.jl). source ITensor([ElT::Type, ]::AbstractArray, inds; tol=0.0, checkflux=true) Create a block sparse ITensor from the input Array, and collection of QN indices. Zeros are dropped and nonzero blocks are determined from the zero values of the array. Optionally, you can set a tolerance such that elements less than or equal to the tolerance are dropped. By default, this will check that the flux of the nonzero blocks are consistent with each other. You can disable this check by setting  checkflux=false . Examples julia> i = Index([QN(0)=>1, QN(1)=>2], \"i\");\n\njulia> A = [1e-9 0.0 0.0;\n            0.0 2.0 3.0;\n            0.0 1e-10 4.0];\n\njulia> @show ITensor(A, i', dag(i); tol = 1e-8);\nITensor(A, i', dag(i); tol = 1.0e-8) = ITensor ord=2\nDim 1: (dim=3|id=468|\"i\")' <Out>\n 1: QN(0) => 1\n 2: QN(1) => 2\nDim 2: (dim=3|id=468|\"i\") <In>\n 1: QN(0) => 1\n 2: QN(1) => 2\nNDTensors.BlockSparse{Float64,Array{Float64,1},2}\n 3×3\nBlock: (2, 2)\n [2:3, 2:3]\n 2.0  3.0\n 0.0  4.0 source"},{"id":37,"pagetitle":"ITensor","title":"ITensors.ITensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.ITensor-Tuple{Type{<:Number}, UndefInitializer, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.ITensor  —  Method ITensor([::Type{ElT} = Float64,] ::UndefInitializer, flux::QN, inds)\nITensor([::Type{ElT} = Float64,] ::UndefInitializer, flux::QN, inds::Index...) Construct an ITensor with indices  inds  and BlockSparse storage with undefined elements of type  ElT , where the nonzero (allocated) blocks are determined by the provided QN  flux . One purpose for using this constructor is that initializing the elements in an undefined way is faster than initializing them to a set value such as zero. The storage will have  NDTensors.BlockSparse  type. Examples i = Index([QN(0)=>1, QN(1)=>2], \"i\")\nA = ITensor(undef,QN(0),i',dag(i))\nB = ITensor(Float64,undef,QN(0),i',dag(i))\nC = ITensor(ComplexF64,undef,QN(0),i',dag(i)) source"},{"id":38,"pagetitle":"ITensor","title":"Diagonal constructors","ref":"/ITensorDocs/ITensors/stable/#Diagonal-constructors","content":" Diagonal constructors"},{"id":39,"pagetitle":"ITensor","title":"ITensors.diag_itensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.diag_itensor-Tuple{Type{<:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.diag_itensor  —  Method diag_itensor([::Type{ElT} = Float64, ]inds)\ndiag_itensor([::Type{ElT} = Float64, ]inds::Index...) Make a sparse ITensor of element type  ElT  with only elements along the diagonal stored. Defaults to having  zero(T)  along the diagonal. The storage will have  NDTensors.Diag  type. source"},{"id":40,"pagetitle":"ITensor","title":"ITensors.diag_itensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.diag_itensor-Tuple{NDTensors.AliasStyle, Type{<:Number}, Vector{<:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.diag_itensor  —  Method diag_itensor([ElT::Type, ]v::AbstractVector, inds...)\ndiagitensor([ElT::Type, ]v::AbstractVector, inds...) Make a sparse ITensor with non-zero elements only along the diagonal. In general, the diagonal elements will be those stored in  v  and the ITensor will have element type  eltype(v) , unless specified explicitly by  ElT . The storage will have  NDTensors.Diag  type. In the case when  eltype(v) isa Union{Int, Complex{Int}} , by default it will be converted to  float(v) . Note that this behavior is subject to change in the future. The version  diag_itensor  will never output an ITensor whose storage data is an alias of the input vector data. The version  diagitensor  might output an ITensor whose storage data is an alias of the input vector data in order to minimize operations. source"},{"id":41,"pagetitle":"ITensor","title":"ITensors.diag_itensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.diag_itensor-Tuple{NDTensors.AliasStyle, Type{<:Number}, Number, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.diag_itensor  —  Method diag_itensor([ElT::Type, ]x::Number, inds...)\ndiagitensor([ElT::Type, ]x::Number, inds...) Make a sparse ITensor with non-zero elements only along the diagonal. In general, the diagonal elements will be set to the value  x  and the ITensor will have element type  eltype(x) , unless specified explicitly by  ElT . The storage will have  NDTensors.Diag  type. In the case when  x isa Union{Int, Complex{Int}} , by default it will be converted to  float(x) . Note that this behavior is subject to change in the future. source"},{"id":42,"pagetitle":"ITensor","title":"ITensors.delta","ref":"/ITensorDocs/ITensors/stable/#ITensors.delta-Tuple{Type{<:Number}, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.delta  —  Method delta([::Type{ElT} = Float64, ]inds)\ndelta([::Type{ElT} = Float64, ]inds::Index...) Make a uniform diagonal ITensor with all diagonal elements  one(ElT) . Only a single diagonal element is stored. This function has an alias  δ . source"},{"id":43,"pagetitle":"ITensor","title":"QN Diagonal constructors","ref":"/ITensorDocs/ITensors/stable/#QN-Diagonal-constructors","content":" QN Diagonal constructors"},{"id":44,"pagetitle":"ITensor","title":"ITensors.diag_itensor","ref":"/ITensorDocs/ITensors/stable/#ITensors.diag_itensor-Tuple{Type{<:Number}, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.diag_itensor  —  Method diag_itensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndiag_itensor([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...) Make an ITensor with storage type  NDTensors.DiagBlockSparse  with elements  zero(ElT) . The ITensor only has diagonal blocks consistent with the specified  flux . If the element type is not specified, it defaults to  Float64 . If theflux is not specified, it defaults to  QN() . source"},{"id":45,"pagetitle":"ITensor","title":"ITensors.delta","ref":"/ITensorDocs/ITensors/stable/#ITensors.delta-Tuple{Type{<:Number}, QN, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}","content":" ITensors.delta  —  Method delta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is)\ndelta([::Type{ElT} = Float64, ][flux::QN = QN(), ]is::Index...) Make an ITensor with storage type  NDTensors.DiagBlockSparse  with uniform elements  one(ElT) . The ITensor only has diagonal blocks consistent with the specified  flux . If the element type is not specified, it defaults to  Float64 . If theflux is not specified, it defaults to  QN() . source"},{"id":46,"pagetitle":"ITensor","title":"Convert to Array","ref":"/ITensorDocs/ITensors/stable/#Convert-to-Array","content":" Convert to Array"},{"id":47,"pagetitle":"ITensor","title":"Core.Array","ref":"/ITensorDocs/ITensors/stable/#Core.Array-Union{Tuple{N}, Tuple{ElT}, Tuple{ITensor, Union{Tuple{Vararg{IndexT}}, Vector{IndexT}} where IndexT<:Index}} where {ElT, N}","content":" Core.Array  —  Method Array{ElT, N}(T::ITensor, i:Index...)\nArray{ElT}(T::ITensor, i:Index...)\nArray(T::ITensor, i:Index...)\n\nMatrix{ElT}(T::ITensor, row_i:Index, col_i::Index)\nMatrix(T::ITensor, row_i:Index, col_i::Index)\n\nVector{ElT}(T::ITensor)\nVector(T::ITensor) Given an ITensor  T  with indices  i... , returns an Array with a copy of the ITensor's elements. The order in which the indices are provided indicates the order of the data in the resulting Array. source"},{"id":48,"pagetitle":"ITensor","title":"NDTensors.array","ref":"/ITensorDocs/ITensors/stable/#NDTensors.array-Tuple{ITensor, Vararg{Any}}","content":" NDTensors.array  —  Method array(T::ITensor, inds...) Convert an ITensor  T  to an Array. The ordering of the elements in the Array are specified by the input indices  inds . This tries to avoid copying of possible (i.e. may return a view of the original data), for example if the ITensor's storage is Dense and the indices are already in the specified ordering so that no permutation is required. Warning Note that in the future we may return specialized AbstractArray types for certain storage types, for example a  LinearAlgebra.Diagonal  type for an ITensor with  Diag  storage. The specific storage type shouldn't be relied upon. See also  matrix ,  vector . source"},{"id":49,"pagetitle":"ITensor","title":"NDTensors.matrix","ref":"/ITensorDocs/ITensors/stable/#NDTensors.matrix-Tuple{ITensor, Vararg{Any}}","content":" NDTensors.matrix  —  Method matrix(T::ITensor, inds...) Convert an ITensor  T  to a Matrix. The ordering of the elements in the Matrix are specified by the input indices  inds . This tries to avoid copying of possible (i.e. may return a view of the original data), for example if the ITensor's storage is Dense and the indices are already in the specified ordering so that no permutation is required. Warning Note that in the future we may return specialized AbstractArray types for certain storage types, for example a  LinearAlgebra.Diagonal  type for an ITensor with  Diag  storage. The specific storage type shouldn't be relied upon. See also  array ,  vector . source"},{"id":50,"pagetitle":"ITensor","title":"NDTensors.vector","ref":"/ITensorDocs/ITensors/stable/#NDTensors.vector-Tuple{ITensor, Vararg{Any}}","content":" NDTensors.vector  —  Method vector(T::ITensor, inds...) Convert an ITensor  T  to an Vector. The ordering of the elements in the Array are specified by the input indices  inds . This tries to avoid copying of possible (i.e. may return a view of the original data), for example if the ITensor's storage is Dense and the indices are already in the specified ordering so that no permutation is required. Warning Note that in the future we may return specialized AbstractArray types for certain storage types, for example a  LinearAlgebra.Diagonal  type for an ITensor with  Diag  storage. The specific storage type shouldn't be relied upon. See also  array ,  matrix . source"},{"id":51,"pagetitle":"ITensor","title":"NDTensors.array","ref":"/ITensorDocs/ITensors/stable/#NDTensors.array-Tuple{ITensor}","content":" NDTensors.array  —  Method array(T::ITensor) Given an ITensor  T , returns an Array with a copy of the ITensor's elements, or a view in the case the the ITensor's storage is Dense. The ordering of the elements in the Array, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. Warning This method is intended for developer use only and not recommended for use in ITensor applications unless you know what you are doing (for example you are certain of the memory ordering of the ITensor because you permuted the indices into a certain order). See also  matrix ,  vector . source"},{"id":52,"pagetitle":"ITensor","title":"NDTensors.matrix","ref":"/ITensorDocs/ITensors/stable/#NDTensors.matrix-Tuple{ITensor}","content":" NDTensors.matrix  —  Method matrix(T::ITensor) Given an ITensor  T  with two indices, returns a Matrix with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense. The ordering of the elements in the Matrix, in terms of which Index is treated as the row versus column, depends on the internal layout of the ITensor. Warning This method is intended for developer use only and not recommended for use in ITensor applications unless you know what you are doing (for example you are certain of the memory ordering of the ITensor because you permuted the indices into a certain order). See also  array ,  vector . source"},{"id":53,"pagetitle":"ITensor","title":"NDTensors.vector","ref":"/ITensorDocs/ITensors/stable/#NDTensors.vector-Tuple{ITensor}","content":" NDTensors.vector  —  Method vector(T::ITensor) Given an ITensor  T  with one index, returns a Vector with a copy of the ITensor's elements, or a view in the case the ITensor's storage is Dense. See also  array ,  matrix . source"},{"id":54,"pagetitle":"ITensor","title":"Getting and setting elements","ref":"/ITensorDocs/ITensors/stable/#Getting-and-setting-elements","content":" Getting and setting elements"},{"id":55,"pagetitle":"ITensor","title":"Base.getindex","ref":"/ITensorDocs/ITensors/stable/#Base.getindex-Tuple{ITensor, Vararg{Any}}","content":" Base.getindex  —  Method getindex(T::ITensor, ivs...) Get the specified element of the ITensor, using a list of  IndexVal s or  Pair{<:Index, Int} . Example i = Index(2; tags = \"i\")\nA = ITensor(2.0, i, i')\nA[i => 1, i' => 2] # 2.0, same as: A[i' => 2, i => 1] source"},{"id":56,"pagetitle":"ITensor","title":"Base.setindex!","ref":"/ITensorDocs/ITensors/stable/#Base.setindex!-Tuple{ITensor, Number, Vararg{Int64}}","content":" Base.setindex!  —  Method setindex!(T::ITensor, x::Number, ivs...)\n\nsetindex!(T::ITensor, x::Number, I::Integer...)\n\nsetindex!(T::ITensor, x::Number, I::CartesianIndex) Set the specified element of the ITensor, using a list of  Pair{<:Index, Integer}  (or  IndexVal ). If just integers are used, set the specified element of the ITensor using internal Index ordering of the ITensor (only for advanced usage, only use if you know the axact ordering of the indices). Example i = Index(2; tags = \"i\")\nA = ITensor(i, i')\nA[i => 1, i' => 2] = 1.0 # same as: A[i' => 2, i => 1] = 1.0\nA[1, 2] = 1.0 # same as: A[i => 1, i' => 2] = 1.0\n\n# Some simple slicing is also supported\nA[i => 2, i' => :] = [2.0 3.0]\nA[2, :] = [2.0 3.0] source"},{"id":57,"pagetitle":"ITensor","title":"Properties","ref":"/ITensorDocs/ITensors/stable/#Properties","content":" Properties"},{"id":58,"pagetitle":"ITensor","title":"NDTensors.inds","ref":"/ITensorDocs/ITensors/stable/#NDTensors.inds-Tuple{ITensor}","content":" NDTensors.inds  —  Method inds(T::ITensor) Return the indices of the ITensor as a Tuple. source"},{"id":59,"pagetitle":"ITensor","title":"NDTensors.ind","ref":"/ITensorDocs/ITensors/stable/#NDTensors.ind-Tuple{ITensor, Int64}","content":" NDTensors.ind  —  Method ind(T::ITensor, i::Int) Get the Index of the ITensor along dimension i. source"},{"id":60,"pagetitle":"ITensor","title":"ITensors.dir","ref":"/ITensorDocs/ITensors/stable/#ITensors.dir-Tuple{ITensor, Index}","content":" ITensors.dir  —  Method dir(A::ITensor, i::Index) Return the direction of the Index  i  in the ITensor  A . source"},{"id":61,"pagetitle":"ITensor","title":"Priming and tagging","ref":"/ITensorDocs/ITensors/stable/#Priming_and_tagging_ITensor","content":" Priming and tagging"},{"id":62,"pagetitle":"ITensor","title":"ITensors.prime","ref":"/ITensorDocs/ITensors/stable/#ITensors.prime-Tuple{ITensor, Vararg{Any}}","content":" ITensors.prime  —  Method prime[!](A::ITensor, plinc::Int = 1; <keyword arguments>) -> ITensor\n\nprime(inds, plinc::Int = 1; <keyword arguments>) -> IndexSet Increase the prime level of the indices of an ITensor or collection of indices. Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":63,"pagetitle":"ITensor","title":"ITensors.setprime","ref":"/ITensorDocs/ITensors/stable/#ITensors.setprime-Tuple{ITensor, Vararg{Any}}","content":" ITensors.setprime  —  Method setprime[!](A::ITensor, plev::Int; <keyword arguments>) -> ITensor\n\nsetprime(inds, plev::Int; <keyword arguments>) -> IndexSet Set the prime level of the indices of an ITensor or collection of indices. Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":64,"pagetitle":"ITensor","title":"ITensors.noprime","ref":"/ITensorDocs/ITensors/stable/#ITensors.noprime-Tuple{ITensor, Vararg{Any}}","content":" ITensors.noprime  —  Method noprime[!](A::ITensor; <keyword arguments>) -> ITensor\n\nnoprime(inds; <keyword arguments>) -> IndexSet Set the prime level of the indices of an ITensor or collection of indices to zero. Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":65,"pagetitle":"ITensor","title":"ITensors.mapprime","ref":"/ITensorDocs/ITensors/stable/#ITensors.mapprime-Tuple{ITensor, Vararg{Any}}","content":" ITensors.mapprime  —  Method replaceprime[!](A::ITensor, plold::Int, plnew::Int; <keyword arguments>) -> ITensor\nreplaceprime[!](A::ITensor, plold => plnew; <keyword arguments>) -> ITensor\nmapprime[!](A::ITensor, <arguments>; <keyword arguments>) -> ITensor\n\nreplaceprime(inds, plold::Int, plnew::Int; <keyword arguments>)\nreplaceprime(inds::IndexSet, plold => plnew; <keyword arguments>)\nmapprime(inds, <arguments>; <keyword arguments>) Set the prime level of the indices of an ITensor or collection of indices with prime level  plold  to  plnew . Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":66,"pagetitle":"ITensor","title":"ITensors.swapprime","ref":"/ITensorDocs/ITensors/stable/#ITensors.swapprime-Tuple{ITensor, Vararg{Any}}","content":" ITensors.swapprime  —  Method swapprime[!](A::ITensor, pl1::Int, pl2::Int; <keyword arguments>) -> ITensor\nswapprime[!](A::ITensor, pl1 => pl2; <keyword arguments>) -> ITensor\n\nswapprime(inds, pl1::Int, pl2::Int; <keyword arguments>)\nswapprime(inds, pl1 => pl2; <keyword arguments>) Set the prime level of the indices of an ITensor or collection of indices with prime level  pl1  to  pl2 , and those with prime level  pl2  to  pl1 . Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":67,"pagetitle":"ITensor","title":"ITensors.TagSets.addtags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.addtags-Tuple{ITensor, Vararg{Any}}","content":" ITensors.TagSets.addtags  —  Method addtags[!](A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\naddtags(inds, ts::String; <keyword arguments>) Add the tags  ts  to the indices of an ITensor or collection of indices. Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":68,"pagetitle":"ITensor","title":"ITensors.TagSets.removetags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.removetags-Tuple{ITensor, Vararg{Any}}","content":" ITensors.TagSets.removetags  —  Method removetags[!](A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nremovetags(inds, ts::String; <keyword arguments>) Remove the tags  ts  from the indices of an ITensor or collection of indices. Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":69,"pagetitle":"ITensor","title":"ITensors.TagSets.replacetags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.replacetags-Tuple{ITensor, Vararg{Any}}","content":" ITensors.TagSets.replacetags  —  Method replacetags[!](A::ITensor, tsold::String, tsnew::String; <keyword arguments>) -> ITensor\n\nreplacetags(is::IndexSet, tsold::String, tsnew::String; <keyword arguments>) -> IndexSet Replace the tags  tsold  with  tsnew  for the indices of an ITensor. Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":70,"pagetitle":"ITensor","title":"ITensors.settags","ref":"/ITensorDocs/ITensors/stable/#ITensors.settags-Tuple{ITensor, Vararg{Any}}","content":" ITensors.settags  —  Method settags[!](A::ITensor, ts::String; <keyword arguments>) -> ITensor\n\nsettags(is::IndexSet, ts::String; <keyword arguments>) -> IndexSet Set the tags of the indices of an ITensor or IndexSet to  ts . Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":71,"pagetitle":"ITensor","title":"ITensors.swaptags","ref":"/ITensorDocs/ITensors/stable/#ITensors.swaptags-Tuple{ITensor, Vararg{Any}}","content":" ITensors.swaptags  —  Method swaptags[!](A::ITensor, ts1::String, ts2::String; <keyword arguments>) -> ITensor\n\nswaptags(is::IndexSet, ts1::String, ts2::String; <keyword arguments>) -> IndexSet Swap the tags  ts1  with  ts2  for the indices of an ITensor. Optionally, only modify the indices with the specified keyword arguments. Arguments tags = nothing : if specified, only modify Index  i  if  hastags(i, tags) == true . plev = nothing : if specified, only modify Index  i  if  hasplev(i, plev) == true . The ITensor functions come in two versions,  f  and  f! . The latter modifies the ITensor in-place. In both versions, the ITensor storage is not modified or copied (so it returns an ITensor with a view of the original storage). source"},{"id":72,"pagetitle":"ITensor","title":"Index collections set operations","ref":"/ITensorDocs/ITensors/stable/#Index-collections-set-operations","content":" Index collections set operations"},{"id":73,"pagetitle":"ITensor","title":"ITensors.commoninds","ref":"/ITensorDocs/ITensors/stable/#ITensors.commoninds","content":" ITensors.commoninds  —  Function commoninds(A, B; kwargs...) Return a Vector with indices that are common between the indices of  A  and  B  (the set intersection, similar to  Base.intersect ). Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":74,"pagetitle":"ITensor","title":"ITensors.commonind","ref":"/ITensorDocs/ITensors/stable/#ITensors.commonind","content":" ITensors.commonind  —  Function commonind(A, B; kwargs...) Return the first  Index  common between the indices of  A  and  B . See also  commoninds . Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":75,"pagetitle":"ITensor","title":"ITensors.uniqueinds","ref":"/ITensorDocs/ITensors/stable/#ITensors.uniqueinds","content":" ITensors.uniqueinds  —  Function uniqueinds(A, B; kwargs...) Return Vector with indices that are unique to the set of indices of  A  and not in  B  (the set difference, similar to  Base.setdiff ). Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":76,"pagetitle":"ITensor","title":"ITensors.uniqueind","ref":"/ITensorDocs/ITensors/stable/#ITensors.uniqueind","content":" ITensors.uniqueind  —  Function uniqueind(A, B; kwargs...) Return the first  Index  unique to the set of indices of  A  and not in  B . See also  uniqueinds . Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":77,"pagetitle":"ITensor","title":"ITensors.noncommoninds","ref":"/ITensorDocs/ITensors/stable/#ITensors.noncommoninds","content":" ITensors.noncommoninds  —  Function noncommoninds(A, B; kwargs...) Return a Vector with indices that are not common between the indices of  A  and  B  (the symmetric set difference, similar to  Base.symdiff ). Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":78,"pagetitle":"ITensor","title":"ITensors.noncommonind","ref":"/ITensorDocs/ITensors/stable/#ITensors.noncommonind","content":" ITensors.noncommonind  —  Function noncommonind(A, B; kwargs...) Return the first  Index  not common between the indices of  A  and  B . See also  noncommoninds . Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":79,"pagetitle":"ITensor","title":"ITensors.unioninds","ref":"/ITensorDocs/ITensors/stable/#ITensors.unioninds","content":" ITensors.unioninds  —  Function unioninds(A, B; kwargs...) Return a Vector with indices that are the union of the indices of  A  and  B  (the set union, similar to  Base.union ). Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":80,"pagetitle":"ITensor","title":"ITensors.unionind","ref":"/ITensorDocs/ITensors/stable/#ITensors.unionind","content":" ITensors.unionind  —  Function unionind(A, B; kwargs...) Return the first  Index  in the union of the indices of  A  and  B . See also  unioninds . Optional keyword arguments: tags::String - a tag name or comma separated list of tag names that the returned indices must all have plev::Int - common prime level that the returned indices must all have inds - Index or collection of indices. Returned indices must come from this set of indices. source"},{"id":81,"pagetitle":"ITensor","title":"ITensors.hascommoninds","ref":"/ITensorDocs/ITensors/stable/#ITensors.hascommoninds","content":" ITensors.hascommoninds  —  Function hascommoninds(A, B; kwargs...)\n\nhascommoninds(B; kwargs...) -> f::Function Check if the ITensors or sets of indices  A  and  B  have common indices. If only one ITensor or set of indices  B  is passed, return a function  f  such that  f(A) = hascommoninds(A, B; kwargs...) source"},{"id":82,"pagetitle":"ITensor","title":"Index Manipulations","ref":"/ITensorDocs/ITensors/stable/#Index-Manipulations","content":" Index Manipulations"},{"id":83,"pagetitle":"ITensor","title":"ITensors.replaceind","ref":"/ITensorDocs/ITensors/stable/#ITensors.replaceind-Tuple{ITensor, Vararg{Any}}","content":" ITensors.replaceind  —  Method replaceind[!](A::ITensor, i1::Index, i2::Index) -> ITensor Replace the Index  i1  with the Index  i2  in the ITensor. The indices must have the same space (i.e. the same dimension and QNs, if applicable). source"},{"id":84,"pagetitle":"ITensor","title":"ITensors.replaceinds","ref":"/ITensorDocs/ITensors/stable/#ITensors.replaceinds-Tuple{ITensor, Vararg{Any}}","content":" ITensors.replaceinds  —  Method replaceinds(A::ITensor, inds1, inds2) -> ITensor\n\nreplaceinds!(A::ITensor, inds1, inds2) Replace the Index  inds1[n]  with the Index  inds2[n]  in the ITensor, where  n  runs from  1  to  length(inds1) == length(inds2) . The indices must have the same space (i.e. the same dimension and QNs, if applicable). The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor). source"},{"id":85,"pagetitle":"ITensor","title":"ITensors.swapind","ref":"/ITensorDocs/ITensors/stable/#ITensors.swapind-Tuple{ITensor, Vararg{Any}}","content":" ITensors.swapind  —  Method swapind(A::ITensor, i1::Index, i2::Index) -> ITensor\n\nswapind!(A::ITensor, i1::Index, i2::Index) Swap the Index  i1  with the Index  i2  in the ITensor. The indices must have the same space (i.e. the same dimension and QNs, if applicable). source"},{"id":86,"pagetitle":"ITensor","title":"ITensors.swapinds","ref":"/ITensorDocs/ITensors/stable/#ITensors.swapinds-Tuple{ITensor, Vararg{Any}}","content":" ITensors.swapinds  —  Method swapinds(A::ITensor, inds1, inds2) -> ITensor\n\nswapinds!(A::ITensor, inds1, inds2) Swap the Index  inds1[n]  with the Index  inds2[n]  in the ITensor, where  n  runs from  1  to  length(inds1) == length(inds2) . The indices must have the same space (i.e. the same dimension and QNs, if applicable). The storage of the ITensor is not modified or copied (the output ITensor is a view of the input ITensor). source"},{"id":87,"pagetitle":"ITensor","title":"Math operations","ref":"/ITensorDocs/ITensors/stable/#Math-operations","content":" Math operations"},{"id":88,"pagetitle":"ITensor","title":"Base.:*","ref":"/ITensorDocs/ITensors/stable/#Base.:*-Tuple{ITensor, ITensor}","content":" Base.:*  —  Method A::ITensor * B::ITensor\ncontract(A::ITensor, B::ITensor) Contract ITensors A and B to obtain a new ITensor. This contraction  *  operator finds all matching indices common to A and B and sums over them, such that the result will have only the unique indices of A and B. To prevent indices from matching, their prime level or tags can be modified such that they no longer compare equal - for more information see the documentation on Index objects. Examples i = Index(2,\"index_i\"); j = Index(4,\"index_j\"); k = Index(3,\"index_k\")\n\nA = random_itensor(i,j)\nB = random_itensor(j,k)\nC = A * B # contract over Index j\n\nA = random_itensor(i,i')\nB = random_itensor(i,i'')\nC = A * B # contract over Index i\n\nA = random_itensor(i)\nB = random_itensor(j)\nC = A * B # outer product of A and B, no contraction\n\nA = random_itensor(i,j,k)\nB = random_itensor(k,i,j)\nC = A * B # inner product of A and B, all indices contracted source"},{"id":89,"pagetitle":"ITensor","title":"ITensors.dag","ref":"/ITensorDocs/ITensors/stable/#ITensors.dag-Tuple{ITensor}","content":" ITensors.dag  —  Method dag(T::ITensor; allow_alias = true) Complex conjugate the elements of the ITensor  T  and dagger the indices. By default, an alias of the ITensor is returned (i.e. the output ITensor may share data with the input ITensor). If  allow_alias = false , an alias is never returned. source"},{"id":90,"pagetitle":"ITensor","title":"ITensors.directsum","ref":"/ITensorDocs/ITensors/stable/#ITensors.directsum-Tuple{Pair{ITensor}, Pair{ITensor}, Pair{ITensor}, Vararg{Any}}","content":" ITensors.directsum  —  Method directsum(A::Pair{ITensor}, B::Pair{ITensor}, ...; tags)\n\ndirectsum(output_inds, A::Pair{ITensor}, B::Pair{ITensor}, ...; tags) Given a list of pairs of ITensors and indices, perform a partial direct sum of the tensors over the specified indices. Indices that are not specified to be summed must match between the tensors. (Note:  Pair{ITensor}  in Julia is short for  Pair{ITensor,<:Any}  which means any pair  T => x  where  T  is an ITensor.) If all indices are specified then the operation is equivalent to creating a block diagonal tensor. Returns the ITensor representing the partial direct sum as well as the new direct summed indices. The tags of the direct summed indices are specified by the keyword arguments. Optionally, pass the new direct summed indices of the output tensor as the first argument (either a single Index or a collection), which must be proper direct sums of the input indices that are specified to be direct summed. See Section 2.3 of https://arxiv.org/abs/1405.7786 for a definition of a partial direct sum of tensors. Examples x = Index(2, \"x\")\ni1 = Index(3, \"i1\")\nj1 = Index(4, \"j1\")\ni2 = Index(5, \"i2\")\nj2 = Index(6, \"j2\")\n\nA1 = random_itensor(x, i1)\nA2 = random_itensor(x, i2)\nS, s = directsum(A1 => i1, A2 => i2)\ndim(s) == dim(i1) + dim(i2)\n\ni1i2 = directsum(i1, i2)\nS = directsum(i1i2, A1 => i1, A2 => i2)\nhasind(S, i1i2)\n\nA3 = random_itensor(x, j1)\nS, s = directsum(A1 => i1, A2 => i2, A3 => j1)\ndim(s) == dim(i1) + dim(i2) + dim(j1)\n\nA1 = random_itensor(i1, x, j1)\nA2 = random_itensor(x, j2, i2)\nS, s = directsum(A1 => (i1, j1), A2 => (i2, j2); tags = [\"sum_i\", \"sum_j\"])\nlength(s) == 2\ndim(s[1]) == dim(i1) + dim(i2)\ndim(s[2]) == dim(j1) + dim(j2) source"},{"id":91,"pagetitle":"ITensor","title":"Base.exp","ref":"/ITensorDocs/ITensors/stable/#Base.exp-Tuple{ITensor, Any, Any}","content":" Base.exp  —  Method exp(A::ITensor, Linds=Rinds', Rinds=inds(A,plev=0); ishermitian = false) Compute the exponential of the tensor  A  by treating it as a matrix  $A_{lr}$  with the left index  l  running over all indices in  Linds  and  r  running over all indices in  Rinds . Only accepts index lists  Linds , Rinds  such that: (1)  length(Linds) + length(Rinds) == length(inds(A))  (2)  length(Linds) == length(Rinds)  (3) For each pair of indices  (Linds[n],Rinds[n]) ,  Linds[n]  and  Rinds[n]  represent the same Hilbert space (the same QN structure in the QN case, or just the same length in the dense case), and appear in  A  with opposite directions. When  ishermitian=true  the exponential of  Hermitian(A_{lr})  is computed internally. source"},{"id":92,"pagetitle":"ITensor","title":"LinearAlgebra.nullspace","ref":"/ITensorDocs/ITensors/stable/#LinearAlgebra.nullspace-Tuple{ITensor, Vararg{Any}}","content":" LinearAlgebra.nullspace  —  Method nullspace(T::ITensor, left_inds...; tags=\"n\", atol=1E-12, kwargs...) Viewing the ITensor  T  as a matrix with the provided  left_inds  viewed as the row space and remaining indices viewed as the right indices or column space, the  nullspace  function computes the right null space. That is, it will return a tensor  N  acting on the right indices of  T  such that  T*N  is zero. The returned tensor  N  will also have a new index with the label \"n\" which indexes through the 'vectors' in the null space. For example, if  T  has the indices  i,j,k , calling  N = nullspace(T,i,k)  returns  N  with index  j  such that        ___       ___\n  i --|   |     |   |\n      | T |--j--| N |--n  ≈ 0\n  k --|   |     |   |\n       ---       --- The index  n  can be obtained by calling  n = uniqueindex(N,T) Note that the implementation of this function is subject to change in the future, in which case the precise  atol  value that gives a certain null space size may change in future versions of ITensor. Keyword arguments: atol::Float64=1E-12  - singular values of T†*T below this value define the null space tags::String=\"n\"  - choose the tags of the index selecting elements of the null space source"},{"id":93,"pagetitle":"ITensor","title":"Decompositions","ref":"/ITensorDocs/ITensors/stable/#Decompositions","content":" Decompositions"},{"id":94,"pagetitle":"ITensor","title":"LinearAlgebra.svd","ref":"/ITensorDocs/ITensors/stable/#LinearAlgebra.svd-Tuple{ITensor, Vararg{Any}}","content":" LinearAlgebra.svd  —  Method svd(A::ITensor, inds::Index...; <keyword arguments>) Singular value decomposition (SVD) of an ITensor  A , computed by treating the \"left indices\" provided collectively as a row index, and the remaining \"right indices\" as a column index (matricization of a tensor). The first three return arguments are  U ,  S , and  V , such that  A ≈ U * S * V . Whether or not the SVD performs a trunction depends on the keyword arguments provided. If the left or right set of indices are empty, all input indices are put on  V  or  U  respectively. To specify an empty set of left indices, you must explicitly use  svd(A, ())  ( svd(A)  is currently undefined). Examples Computing the SVD of an order-three ITensor, such that the indices i and k end up on U and j ends up on V i = Index(2)\nj = Index(5)\nk = Index(2)\nA = random_itensor(i, j, k)\nU, S, V = svd(A, i, k);\n@show norm(A - U * S * V) <= 10 * eps() * norm(A) The following code will truncate the last 2 singular values, since the total number of singular values is 4. The norm of the difference with the original tensor will be the sqrt root of the sum of the squares of the singular values that get truncated. trunc, Strunc, Vtrunc = svd(A, i, k; maxdim=2);\n@show norm(A - Utrunc * Strunc * Vtrunc) ≈ sqrt(S[3, 3]^2 + S[4, 4]^2) Alternatively we can specify that we want to truncate the weights of the singular values up to a certain cutoff, so the total error will be no larger than the cutoff. Utrunc2, Strunc2, Vtrunc2 = svd(A, i, k; cutoff=1e-10);\n@show norm(A - Utrunc2 * Strunc2 * Vtrunc2) <= 1e-10 Keywords maxdim::Int : the maximum number of singular values to keep. mindim::Int : the minimum number of singular values to keep. cutoff::Float64 : set the desired truncation error of the SVD,  by default defined as the sum of the squares of the smallest singular values. lefttags::String = \"Link,u\" : set the tags of the Index shared by  U  and  S . righttags::String = \"Link,v\" : set the tags of the Index shared by  S  and  V . alg::String = \"divide_and_conquer\" . Options: \"divide_and_conquer\"  - A divide-and-conquer algorithm.    LAPACK's gesdd. Fast, but may lead to some innacurate singular values    for very ill-conditioned matrices. Also may sometimes fail to converge,    leading to errors (in which case \"qr_iteration\" or \"recursive\" can be tried). \"qr_iteration\"  - Typically slower but more accurate for very  ill-conditioned matrices compared to  \"divide_and_conquer\" .  LAPACK's gesvd. \"recursive\"  - ITensor's custom svd. Very reliable, but may be slow if  high precision is needed. To get an  svd  of a matrix  A , an  eigendecomposition of  $A^{\\dagger} A$  is used to compute  U  and then  a  qr  of  $A^{\\dagger} U$  is used to compute  V . This is performed  recursively to compute small singular values. use_absolute_cutoff::Bool = false : set if all probability weights below  the  cutoff  value should be discarded, rather than the sum of discarded  weights. use_relative_cutoff::Bool = true : set if the singular values should be  normalized for the sake of truncation. min_blockdim::Int = 0 : for SVD of block-sparse or QN ITensors, require  that the number of singular values kept be greater than or equal to  this value when possible See also:  factorize ,  eigen source"},{"id":95,"pagetitle":"ITensor","title":"LinearAlgebra.eigen","ref":"/ITensorDocs/ITensors/stable/#LinearAlgebra.eigen-Tuple{ITensor, Any, Any}","content":" LinearAlgebra.eigen  —  Method eigen(A::ITensor[, Linds, Rinds]; <keyword arguments>) Eigendecomposition of an ITensor  A , computed by treating the \"left indices\"  Linds  provided collectively as a row index, and remaining \"right indices\"  Rinds  as a column index (matricization of a tensor). If no indices are provided, pairs of primed and unprimed indices are searched for, with  Linds  taken to be the primed indices and  Rinds  taken to be the unprimed indices. The return arguments are the eigenvalues  D  and eigenvectors  U  as tensors, such that  A * U ∼ U * D  (more precisely they are approximately equal up to proper replacements of indices, see the example for details). Whether or not  eigen  performs a trunction depends on the keyword arguments provided. Note that truncation is only well defined for positive semidefinite matrices. Arguments - `maxdim::Int`: the maximum number of singular values to keep.\n- `mindim::Int`: the minimum number of singular values to keep.\n- `cutoff::Float64`: set the desired truncation error of the eigenvalues,\n   by default defined as the sum of the squares of the smallest eigenvalues.\n   For now truncation is only well defined for positive semi-definite\n   eigenspectra.\n- `ishermitian::Bool = false`: specify if the matrix is Hermitian, in which\n   case a specialized diagonalization routine will be used and it is\n   guaranteed that real eigenvalues will be returned.\n- `plev::Int = 0`: set the prime level of the Indices of `D`. Default prime\n   levels are subject to change.\n- `leftplev::Int = plev`: set the prime level of the Index unique to `D`.\n   Default prime levels are subject to change.\n- `rightplev::Int = leftplev+1`: set the prime level of the Index shared\n   by `D` and `U`. Default tags are subject to change.\n- `tags::String = \"Link,eigen\"`: set the tags of the Indices of `D`.\n   Default tags are subject to change.\n- `lefttags::String = tags`: set the tags of the Index unique to `D`.\n   Default tags are subject to change.\n- `righttags::String = tags`: set the tags of the Index shared by `D` and `U`.\n   Default tags are subject to change.\n- `use_absolute_cutoff::Bool = false`: set if all probability weights below\n   the `cutoff` value should be discarded, rather than the sum of discarded\n   weights.\n- `use_relative_cutoff::Bool = true`: set if the singular values should\n   be normalized for the sake of truncation. Examples i, j, k, l = Index(2, \"i\"), Index(2, \"j\"), Index(2, \"k\"), Index(2, \"l\")\nA = random_itensor(i, j, k, l)\nLinds = (i, k)\nRinds = (j, l)\nD, U = eigen(A, Linds, Rinds)\ndl, dr = uniqueind(D, U), commonind(D, U)\nUl = replaceinds(U, (Rinds..., dr) => (Linds..., dl))\nA * U ≈ Ul * D # true See also:  svd ,  factorize source"},{"id":96,"pagetitle":"ITensor","title":"LinearAlgebra.factorize","ref":"/ITensorDocs/ITensors/stable/#LinearAlgebra.factorize-Tuple{ITensor, Vararg{Any}}","content":" LinearAlgebra.factorize  —  Method factorize(A::ITensor, Linds::Index...; <keyword arguments>) Perform a factorization of  A  into ITensors  L  and  R  such that  A ≈ L * R . Arguments ortho::String = \"left\" : Choose orthogonality  properties of the factorization. \"left\" : the left factor  L  is an orthogonal basis  such that  L * dag(prime(L, commonind(L,R))) ≈ I . \"right\" : the right factor  R  forms an orthogonal basis. \"none\" , neither of the factors form an orthogonal basis,   and in general are made as symmetrically as possible   (depending on the decomposition used). which_decomp::Union{String, Nothing} = nothing : choose what kind  of decomposition is used. nothing : choose the decomposition automatically based on  the other arguments. For example, when  nothing  is chosen and   ortho = \"left\"  or  \"right\" , and a cutoff is provided,  svd  or   eigen  is used depending on the provided cutoff ( eigen  is only  used when the cutoff is greater than  1e-12 , since it has a lower  precision). When no truncation is requested  qr  is used for dense  ITensors and  svd  for block-sparse ITensors (in the future  qr   will be used also for block-sparse ITensors in this case). \"svd\" :  L = U  and  R = S * V  for  ortho = \"left\" ,  L = U * S   and  R = V  for  ortho = \"right\" , and  L = U * sqrt.(S)  and   R = sqrt.(S) * V  for  ortho = \"none\" . To control which  svd   algorithm is choose, use the  svd_alg  keyword argument. See the  documentation for  svd  for the supported algorithms, which are the  same as those accepted by the  alg  keyword argument. \"eigen\" :  L = U  and  $R = U^{\\dagger} A$  where  U  is determined  from the eigendecompositon  $A A^{\\dagger} = U D U^{\\dagger}$  for   ortho = \"left\"  (and vice versa for  ortho = \"right\" ).  \"eigen\"  is  not supported for  ortho = \"none\" . \"qr\" :  L=Q  and  R  an upper-triangular matrix when   ortho = \"left\" , and  R = Q  and  L  a lower-triangular matrix  when  ortho = \"right\"  (currently supported for dense ITensors only). In the future, other decompositions like QR (for block-sparse ITensors), polar, cholesky, LU, etc. are expected to be supported. For truncation arguments, see:  svd source"},{"id":97,"pagetitle":"ITensor","title":"Memory operations","ref":"/ITensorDocs/ITensors/stable/#Memory-operations","content":" Memory operations"},{"id":98,"pagetitle":"ITensor","title":"ITensors.permute","ref":"/ITensorDocs/ITensors/stable/#ITensors.permute-Tuple{ITensor, Any}","content":" ITensors.permute  —  Method permute(T::ITensor, inds...; allow_alias = false) Return a new ITensor  T  with indices permuted according to the input indices  inds . The storage of the ITensor is permuted accordingly. If called with  allow_alias = true , it avoids copying data if possible. Therefore, it may return an alias of the input ITensor (an ITensor that shares the same data), such as if the permutation turns out to be trivial. By default,  allow_alias = false , and it never returns an alias of the input ITensor. Examples i = Index(2, \"index_i\"); j = Index(4, \"index_j\"); k = Index(3, \"index_k\");\nT = random_itensor(i, j, k)\n\npT_1 = permute(T, k, i, j)\npT_2 = permute(T, j, i, k)\n\npT_noalias_1 = permute(T, i, j, k)\npT_noalias_1[1, 1, 1] = 12\nT[1, 1, 1] != pT_noalias_1[1, 1, 1]\n\npT_noalias_2 = permute(T, i, j, k; allow_alias = false)\npT_noalias_2[1, 1, 1] = 12\nT[1, 1, 1] != pT_noalias_1[1, 1, 1]\n\npT_alias = permute(T, i, j, k; allow_alias = true)\npT_alias[1, 1, 1] = 12\nT[1, 1, 1] == pT_alias[1, 1, 1] source"},{"id":99,"pagetitle":"ITensor","title":"NDTensors.dense","ref":"/ITensorDocs/ITensors/stable/#NDTensors.dense-Tuple{ITensor}","content":" NDTensors.dense  —  Method dense(T::ITensor) Make a new ITensor where the storage is the closest Dense storage, avoiding allocating new data if possible. For example, an ITensor with Diag storage will become Dense storage, filled with zeros except for the diagonal values. source"},{"id":100,"pagetitle":"ITensor","title":"NDTensors.denseblocks","ref":"/ITensorDocs/ITensors/stable/#NDTensors.denseblocks-Tuple{ITensor}","content":" NDTensors.denseblocks  —  Method denseblocks(T::ITensor) Make a new ITensor where any blocks which have a sparse format, such as diagonal sparsity, are made dense while still preserving the outer block-sparse structure. This method avoids allocating new data if possible. For example, an ITensor with DiagBlockSparse storage will have BlockSparse storage afterwards. source"},{"id":103,"pagetitle":"Index","title":"Index","ref":"/ITensorDocs/ITensors/stable/#Index","content":" Index"},{"id":104,"pagetitle":"Index","title":"Description","ref":"/ITensorDocs/ITensors/stable/#Description","content":" Description"},{"id":105,"pagetitle":"Index","title":"ITensors.Index","ref":"/ITensorDocs/ITensors/stable/#ITensors.Index","content":" ITensors.Index  —  Type An  Index  represents a single tensor index with fixed dimension  dim . Copies of an Index compare equal unless their  tags  are different. An Index carries a  TagSet , a set of tags which are small strings that specify properties of the  Index  to help distinguish it from other Indices. There is a special tag which is referred to as the integer tag or prime level which can be incremented or decremented with special priming functions. Internally, an  Index  has a fixed  id  number, which is how the ITensor library knows two indices are copies of a single original  Index .  Index  objects must have the same  id , as well as the  tags  to compare equal. source"},{"id":106,"pagetitle":"Index","title":"ITensors.QNIndex","ref":"/ITensorDocs/ITensors/stable/#ITensors.QNIndex","content":" ITensors.QNIndex  —  Type A QN Index is an Index with QN block storage instead of just an integer dimension. The QN block storage is a vector of pairs of QNs and block dimensions. The total dimension of a QN Index is the sum of the dimensions of the blocks of the Index. source"},{"id":107,"pagetitle":"Index","title":"Constructors","ref":"/ITensorDocs/ITensors/stable/#Constructors","content":" Constructors"},{"id":108,"pagetitle":"Index","title":"ITensors.Index","ref":"/ITensorDocs/ITensors/stable/#ITensors.Index-Tuple{Int64}","content":" ITensors.Index  —  Method Index(dim::Int; tags::Union{AbstractString, TagSet} = \"\",\n                plev::Int = 0) Create an  Index  with a unique  id , a TagSet given by  tags , and a prime level  plev . Examples julia> i = Index(2; tags=\"l\", plev=1)\n(dim=2|id=818|\"l\")'\n\njulia> dim(i)\n2\n\njulia> plev(i)\n1\n\njulia> tags(i)\n\"l\" source"},{"id":109,"pagetitle":"Index","title":"ITensors.Index","ref":"/ITensorDocs/ITensors/stable/#ITensors.Index-Tuple{Int64, Union{ITensors.TagSets.GenericTagSet{BitIntegers.UInt256, 4}, AbstractString}}","content":" ITensors.Index  —  Method Index(dim::Integer, tags::Union{AbstractString, TagSet}; plev::Int = 0) Create an  Index  with a unique  id  and a tagset given by  tags . Examples julia> i = Index(2, \"l,tag\")\n(dim=2|id=58|\"l,tag\")\n\njulia> dim(i)\n2\n\njulia> plev(i)\n0\n\njulia> tags(i)\n\"l,tag\" source"},{"id":110,"pagetitle":"Index","title":"ITensors.Index","ref":"/ITensorDocs/ITensors/stable/#ITensors.Index-Tuple{Vararg{Pair{QN, Int64}}}","content":" ITensors.Index  —  Method Index(qnblocks::Pair{QN, Int64}...; tags = \"\",\n                                    plev::Integer = 0) Construct a QN Index from a list of pairs of QN and block dimensions. Example Index(QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1; tags = \"i\") source"},{"id":111,"pagetitle":"Index","title":"ITensors.Index","ref":"/ITensorDocs/ITensors/stable/#ITensors.Index-Tuple{Vector{Pair{QN, Int64}}}","content":" ITensors.Index  —  Method Index(qnblocks::Vector{Pair{QN, Int64}}; tags = \"\", plev::Integer = 0) Construct a QN Index from a Vector of pairs of QN and block dimensions. Example Index([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1]; tags = \"i\") source"},{"id":112,"pagetitle":"Index","title":"ITensors.Index","ref":"/ITensorDocs/ITensors/stable/#ITensors.Index-Tuple{Vector{Pair{QN, Int64}}, Union{ITensors.TagSets.GenericTagSet{BitIntegers.UInt256, 4}, AbstractString}}","content":" ITensors.Index  —  Method Index(qnblocks::Vector{Pair{QN, Int64}}, tags; plev::Integer = 0) Construct a QN Index from a Vector of pairs of QN and block dimensions. Example i = Index([QN(\"Sz\", -1) => 1, QN(\"Sz\", 1) => 1], \"i\")\nidag = dag(i) # Same Index with arrow direction flipped source"},{"id":113,"pagetitle":"Index","title":"Properties","ref":"/ITensorDocs/ITensors/stable/#Properties","content":" Properties"},{"id":114,"pagetitle":"Index","title":"ITensors.id","ref":"/ITensorDocs/ITensors/stable/#ITensors.id-Tuple{Index}","content":" ITensors.id  —  Method id(i::Index) Obtain the id of an Index, which is a unique 64 digit integer. source"},{"id":115,"pagetitle":"Index","title":"ITensors.hasid","ref":"/ITensorDocs/ITensors/stable/#ITensors.hasid-Tuple{Index, UInt64}","content":" ITensors.hasid  —  Method hasid(i::Index, id::ITensors.IDType) Check if an  Index i  has the provided id. Examples julia> i = Index(2)\n(dim=2|id=321)\n\njulia> hasid(i, id(i))\ntrue\n\njulia> j = Index(2)\n(dim=2|id=17)\n\njulia> hasid(i, id(j))\nfalse source"},{"id":116,"pagetitle":"Index","title":"ITensors.tags","ref":"/ITensorDocs/ITensors/stable/#ITensors.tags-Tuple{Index}","content":" ITensors.tags  —  Method tags(i::Index) Obtain the TagSet of an Index. source"},{"id":117,"pagetitle":"Index","title":"ITensors.TagSets.set_strict_tags!","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.set_strict_tags!-Tuple{Bool}","content":" ITensors.TagSets.set_strict_tags!  —  Method set_strict_tags!(enable::Bool) -> Bool\n Enable or disable checking for overflow of the number of tags of a TagSet or the number of characters of a tag. If enabled (set to  true ), an error will be thrown if overflow occurs, otherwise the overflow will be ignored and the extra tags or tag characters will be dropped. This could cause unexpected bugs if tags are being used to distinguish Index objects that have the same ids and prime levels, but that is generally discouraged and should only be used if you know what you are doing. See also  ITensors.using_strict_tags . source"},{"id":118,"pagetitle":"Index","title":"ITensors.TagSets.using_strict_tags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.using_strict_tags-Tuple{}","content":" ITensors.TagSets.using_strict_tags  —  Method using_strict_tags() -> Bool\n See if checking for overflow of the number of tags of a TagSet or the number of characters of a tag is enabled or disabled. See also  ITensors.set_strict_tags! . source"},{"id":119,"pagetitle":"Index","title":"ITensors.TagSets.hastags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.hastags-Tuple{Index, Union{ITensors.TagSets.GenericTagSet{BitIntegers.UInt256, 4}, AbstractString}}","content":" ITensors.TagSets.hastags  —  Method hastags(i::Index, ts::Union{AbstractString,TagSet}) Check if an  Index i  has the provided tags, which can be a string of comma-separated tags or a TagSet object. Examples julia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=861|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"SpinHalf,Site\")\ntrue\n\njulia> hastags(i, \"Link\")\nfalse source"},{"id":120,"pagetitle":"Index","title":"ITensors.plev","ref":"/ITensorDocs/ITensors/stable/#ITensors.plev-Tuple{Index}","content":" ITensors.plev  —  Method plev(i::Index) Obtain the prime level of an Index. source"},{"id":121,"pagetitle":"Index","title":"ITensors.hasplev","ref":"/ITensorDocs/ITensors/stable/#ITensors.hasplev-Tuple{Index, Int64}","content":" ITensors.hasplev  —  Method hasplev(i::Index, plev::Int) Check if an  Index i  has the provided prime level. Examples julia> i = Index(2; plev=2)\n(dim=2|id=543)''\n\njulia> hasplev(i, 2)\ntrue\n\njulia> hasplev(i, 1)\nfalse source"},{"id":122,"pagetitle":"Index","title":"NDTensors.dim","ref":"/ITensorDocs/ITensors/stable/#NDTensors.dim-Tuple{Index}","content":" NDTensors.dim  —  Method dim(i::Index) Obtain the dimension of an Index. For a QN Index, this is the sum of the block dimensions. source"},{"id":123,"pagetitle":"Index","title":"Base.:==","ref":"/ITensorDocs/ITensors/stable/#Base.:==-Tuple{Index, Index}","content":" Base.:==  —  Method ==(i1::Index, i1::Index) Compare indices for equality. First the id's are compared, then the prime levels are compared, and finally the tags are compared. source"},{"id":124,"pagetitle":"Index","title":"ITensors.dir","ref":"/ITensorDocs/ITensors/stable/#ITensors.dir-Tuple{Index}","content":" ITensors.dir  —  Method dir(i::Index) Return the direction of an  Index  ( ITensors.In ,  ITensors.Out , or  ITensors.Neither ). source"},{"id":125,"pagetitle":"Index","title":"ITensors.hasqns","ref":"/ITensorDocs/ITensors/stable/#ITensors.hasqns-Tuple{Index}","content":" ITensors.hasqns  —  Method hasqns(::Index) Checks of the Index has QNs or not. source"},{"id":126,"pagetitle":"Index","title":"Priming and tagging methods","ref":"/ITensorDocs/ITensors/stable/#Priming-and-tagging-methods","content":" Priming and tagging methods"},{"id":127,"pagetitle":"Index","title":"ITensors.prime","ref":"/ITensorDocs/ITensors/stable/#ITensors.prime-Tuple{Index, Int64}","content":" ITensors.prime  —  Method prime(i::Index, plinc::Int = 1) Return a copy of Index  i  with its prime level incremented by the amount  plinc source"},{"id":128,"pagetitle":"Index","title":"Base.adjoint","ref":"/ITensorDocs/ITensors/stable/#Base.adjoint-Tuple{Index}","content":" Base.adjoint  —  Method adjoint(i::Index) Prime an Index using the notation  i' . source"},{"id":129,"pagetitle":"Index","title":"Base.:^","ref":"/ITensorDocs/ITensors/stable/#Base.:^-Tuple{Index, Int64}","content":" Base.:^  —  Method ^(i::Index, pl::Int) Prime an Index using the notation  i^3 . source"},{"id":130,"pagetitle":"Index","title":"ITensors.setprime","ref":"/ITensorDocs/ITensors/stable/#ITensors.setprime-Tuple{Index, Int64}","content":" ITensors.setprime  —  Method setprime(i::Index, plev::Int) Return a copy of Index  i  with its prime level set to  plev source"},{"id":131,"pagetitle":"Index","title":"ITensors.noprime","ref":"/ITensorDocs/ITensors/stable/#ITensors.noprime-Tuple{Index}","content":" ITensors.noprime  —  Method noprime(i::Index) Return a copy of Index  i  with its prime level set to zero. source"},{"id":132,"pagetitle":"Index","title":"ITensors.settags","ref":"/ITensorDocs/ITensors/stable/#ITensors.settags-Tuple{Index, Any}","content":" ITensors.settags  —  Method settags(i::Index, ts) Return a copy of Index  i  with tags replaced by the ones given The  ts  argument can be a comma-separated string of tags or a TagSet. Examples julia> i = Index(2, \"SpinHalf,Site,n=3\")\n(dim=2|id=543|\"Site,SpinHalf,n=3\")\n\njulia> hastags(i, \"Link\")\nfalse\n\njulia> j = settags(i, \"Link,n=4\")\n(dim=2|id=543|\"Link,n=4\")\n\njulia> hastags(j, \"Link\")\ntrue\n\njulia> hastags(j, \"n=4,Link\")\ntrue source"},{"id":133,"pagetitle":"Index","title":"ITensors.TagSets.addtags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.addtags-Tuple{Index, Any}","content":" ITensors.TagSets.addtags  —  Method addtags(i::Index,ts) Return a copy of Index  i  with the specified tags added to the existing ones. The  ts  argument can be a comma-separated string of tags or a TagSet. source"},{"id":134,"pagetitle":"Index","title":"ITensors.TagSets.removetags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.removetags-Tuple{Index, Any}","content":" ITensors.TagSets.removetags  —  Method removetags(i::Index, ts) Return a copy of Index  i  with the specified tags removed. The  ts  argument can be a comma-separated string of tags or a TagSet. source"},{"id":135,"pagetitle":"Index","title":"ITensors.TagSets.replacetags","ref":"/ITensorDocs/ITensors/stable/#ITensors.TagSets.replacetags-Tuple{Index, Any, Any}","content":" ITensors.TagSets.replacetags  —  Method replacetags(i::Index, tsold, tsnew)\n\nreplacetags(i::Index, tsold => tsnew) If the tag set of  i  contains the tags specified by  tsold , replaces these with the tags specified by  tsnew , preserving any other tags. The arguments  tsold  and  tsnew  can be comma-separated strings of tags, or TagSet objects. Examples julia> i = Index(2; tags=\"l,x\", plev=1)\n(dim=2|id=83|\"l,x\")'\n\njulia> replacetags(i, \"l\", \"m\")\n(dim=2|id=83|\"m,x\")'\n\njulia> replacetags(i, \"l\" => \"m\")\n(dim=2|id=83|\"m,x\")' source"},{"id":136,"pagetitle":"Index","title":"Methods","ref":"/ITensorDocs/ITensors/stable/#Methods","content":" Methods"},{"id":137,"pagetitle":"Index","title":"NDTensors.sim","ref":"/ITensorDocs/ITensors/stable/#NDTensors.sim-Tuple{Index}","content":" NDTensors.sim  —  Method sim(i::Index; tags = tags(i), plev = plev(i)) Produces an  Index  with the same properties (dimension or QN structure) but with a new  id . source"},{"id":138,"pagetitle":"Index","title":"ITensors.dag","ref":"/ITensorDocs/ITensors/stable/#ITensors.dag-Tuple{Index}","content":" ITensors.dag  —  Method dag(i::Index) Copy an index  i  and reverse its direction. source"},{"id":139,"pagetitle":"Index","title":"ITensors.removeqns","ref":"/ITensorDocs/ITensors/stable/#ITensors.removeqns-Tuple{Index}","content":" ITensors.removeqns  —  Method removeqns(::Index) Removes the QNs from the Index, if it has any. source"},{"id":140,"pagetitle":"Index","title":"Iterating","ref":"/ITensorDocs/ITensors/stable/#Iterating","content":" Iterating"},{"id":141,"pagetitle":"Index","title":"ITensors.eachval","ref":"/ITensorDocs/ITensors/stable/#ITensors.eachval-Tuple{Index}","content":" ITensors.eachval  —  Method eachval(i::Index) Create an iterator whose values range over the dimension of the provided  Index . source"},{"id":142,"pagetitle":"Index","title":"ITensors.eachindval","ref":"/ITensorDocs/ITensors/stable/#ITensors.eachindval-Tuple{Index}","content":" ITensors.eachindval  —  Method eachindval(i::Index) Create an iterator whose values are Pairs of the form  i=>n  with  n  from  1:dim(i) . This iterator is useful for accessing elements of an ITensor in a loop without needing to know the ordering of the indices. See also  eachindval(is::Index...) . source"},{"id":145,"pagetitle":"Multithreading","title":"Multithreading","ref":"/ITensorDocs/ITensors/stable/#Multithreading","content":" Multithreading Most modern computers, including laptops, have multiple cores (processing units) which can be used to perform multiple tasks at the same time and therefore speed up computations. Multithreading is a form of shared memory parallelism that makes use of these multiple cores that you may have available. There are three primary sources of parallelization available to ITensors.jl. These are: BLAS/LAPACK multithreading (through whatever flavor you are using, i.e. OpenBLAS or MKL). The Strided.jl package, which implements efficient multithreaded dense array permutations. Block sparse multithreading (currently only for block sparse contractions) implemented in the NDTensors.jl package. First, you can obtain the number of threads that are available to you with: julia> Sys.CPU_THREADS\n6 If your computations are dominated by large dense tensors, you likely want to make use of BLAS multithreading in order to multithread dense matrix multiplications and other linear algebra methods like SVD and QR decompositions. This will be on by default. The BLAS/LAPACK multithreading can be controlled in the usual way with environment variables such as by starting Julia with: $ MKL_NUM_THREADS=4 julia # Set the number of MKL threads to 4\n\n$ OPENBLAS_NUM_THREADS=4 julia # Set the number of OpenBLAS threads to 4\n\n$ OMP_NUM_THREADS=4 julia # Set the number of OpenMP threads to 4, which will be used by MKL or OpenBLAS if they are not specifically set or at runtime from within Julia: julia> using LinearAlgebra\n\njulia> BLAS.vendor()  # Check which BLAS you are using\n:mkl\n\njulia> BLAS.get_num_threads()\n6\n\njulia> BLAS.set_num_threads(4)\n\njulia> BLAS.get_num_threads()\n4 Note that in Julia v1.6, you will be able to use the command  using LinearAlgebra; BLAS.get_num_threads() . We would highly recommend using MKL (see the installation instructions for how to do that), especially if you are using an Intel chip. How well BLAS multithreading will work depends on how much your calculations are dominated by large dense matrix operations (which is not always the case, especially if you are using QN conservation). Currently, ITensors.jl makes use of the package  Strided.jl  for performant dense array permutations. It also provides multithreaded array permutations. If you start Julia with multiple threads, Strided multithreading is on by default: $ julia -t 4\n\njulia> Threads.nthreads()\n4\n\njulia> using Strided\n\njulia> Strided.get_num_threads()\n4 We find that this threading competes with BLAS threading as well as ITensors.jl's own block sparse multithreading, so if you are using Julia with multiple threads you may want to disable Strided.jl's threading with: julia> Strided.disable_threads()\n1\n\njulia> Strided.get_num_threads()\n1 in favor of either BLAS threading or ITensors.jl's block sparse threading. Additionally, ITensors.jl, through the  NDTensors.jl  library, provides multithreaded block sparse operations. By default, this kind of threading is disabled. If your computations involve QN conserving tensors, you may want to consider enabling block sparse multithreading as described below."},{"id":146,"pagetitle":"Multithreading","title":"ITensors.enable_threaded_blocksparse","ref":"/ITensorDocs/ITensors/stable/#ITensors.enable_threaded_blocksparse","content":" ITensors.enable_threaded_blocksparse  —  Function ITensors.enable_threaded_blocksparse()\nITensors.disable_threaded_blocksparse() Enable or disable block sparse multithreading. Returns the current state of  ITensors.using_threaded_blocksparse() , i.e.  true  if threaded block sparse was previously enabled, and  false  if threaded block sparse was previously disabled. This is helpful for turning block sparse threading on or off temporarily. For example: using_threaded_blocksparse = ITensors.enable_threaded_blocksparse()\n# Run code that you want to be threaded\nif !using_threaded_blocksparse\n  ITensors.disable_threaded_blocksparse()\nend Note that you need to start Julia with multiple threads. For example, to start Julia with 4 threads, you can use any of the following: $ julia --threads=4\n\n$ julia -t 4\n\n$ JULIA_NUM_THREADS=4 julia In addition, we have found that it is best to disable  BLAS  and  Strided  multithreading when using block sparse multithreading. You can do that with the commands  using LinearAlgebra; BLAS.set_num_threads(1)  and  ITensors.Strided.disable_threads() . See also:  ITensors.enable_threaded_blocksparse ,  ITensors.disable_threaded_blocksparse ,  ITensors.using_threaded_blocksparse . source enable_threaded_blocksparse(enable::Bool) enable_threaded_blocksparse(true)  enables threaded block sparse operations (equivalent to  enable_threaded_blocksparse() ). enable_threaded_blocksparse(false)  disables threaded block sparse operations (equivalent to  enable_threaded_blocksparse() ). source Here is a simple example of using block sparse multithreading to speed up a sparse tensor contraction: using BenchmarkTools\nusing ITensors\nusing LinearAlgebra\nusing Strided\n\nfunction main(; d = 20, order = 4)\n  BLAS.set_num_threads(1)\n  Strided.set_num_threads(1)\n\n  println(\"#################################################\")\n  println(\"# order = \", order)\n  println(\"# d = \", d)\n  println(\"#################################################\")\n  println()\n\n  i(n) = Index(QN(0) => d, QN(1) => d; tags = \"i$n\")\n  is = ntuple(i, order ÷ 2)\n  A = random_itensor(is'..., dag(is)...)\n  B = random_itensor(is'..., dag(is)...)\n\n  ITensors.enable_threaded_blocksparse(false)\n\n  println(\"Serial contract:\")\n  @disable_warn_order begin\n    C_contract = @btime $A' * $B samples = 5\n  end\n  println()\n\n  println(\"Threaded contract:\")\n  @disable_warn_order begin\n    ITensors.enable_threaded_blocksparse(true)\n    C_threaded_contract = @btime $A' * $B samples = 5\n    ITensors.enable_threaded_blocksparse(false)\n  end\n  println()\n  @show C_contract ≈ C_threaded_contract\n  return nothing\nend\n\nmain(d = 20, order = 4) which outputs the following on a laptop with 6 threads, starting Julia with 5 threads: julia> main(d = 20, order = 4)\n#################################################\n# order = 4\n# d = 20\n#################################################\n\nThreads.nthreads() = 5\nSys.CPU_THREADS = 6\nBLAS.get_num_threads() = 1\nStrided.get_num_threads() = 1\n\nSerial contract:\n  21.558 ms (131 allocations: 7.34 MiB)\n\nThreaded contract:\n  5.934 ms (446 allocations: 7.37 MiB)\n\nC_contract ≈ C_threaded_contract = true In addition, we plan to add more threading to other parts of the code beyond contraction (such as SVD) and improve composibility with other forms of threading like BLAS and Strided, so stay tuned!"},{"id":149,"pagetitle":"QN","title":"QN","ref":"/ITensorDocs/ITensors/stable/#QN","content":" QN"},{"id":150,"pagetitle":"QN","title":"Description","ref":"/ITensorDocs/ITensors/stable/#Description","content":" Description"},{"id":151,"pagetitle":"QN","title":"ITensors.QuantumNumbers.QN","ref":"/ITensorDocs/ITensors/stable/#ITensors.QuantumNumbers.QN","content":" ITensors.QuantumNumbers.QN  —  Type A QN object stores a collection of up to four named values such as (\"Sz\",1) or (\"N\",0). These values can include a third integer \"m\" which makes them obey addition modulo m, for example (\"P\",1,2) for a value obeying addition mod 2. (The default is regular integer addition). Adding or subtracting pairs of QN objects performs addition and subtraction element-wise on each of the named values. If a name is missing from the collection, its value is treated as zero. source"},{"id":152,"pagetitle":"QN","title":"Constructors","ref":"/ITensorDocs/ITensors/stable/#Constructors","content":" Constructors"},{"id":153,"pagetitle":"QN","title":"ITensors.QuantumNumbers.QN","ref":"/ITensorDocs/ITensors/stable/#ITensors.QuantumNumbers.QN-Tuple","content":" ITensors.QuantumNumbers.QN  —  Method QN(qvs...) Construct a QN from a set of up to four named value tuples. Examples q = QN((\"Sz\",1))\nq = QN((\"N\",1),(\"Sz\",-1))\nq = QN((\"P\",0,2),(\"Sz\",0)). source"},{"id":154,"pagetitle":"QN","title":"ITensors.QuantumNumbers.QN","ref":"/ITensorDocs/ITensors/stable/#ITensors.QuantumNumbers.QN","content":" ITensors.QuantumNumbers.QN  —  Type QN(name,val::Int,modulus::Int=1) Construct a QN with a single named value by providing the name, value, and optional modulus. source"},{"id":155,"pagetitle":"QN","title":"ITensors.QuantumNumbers.QN","ref":"/ITensorDocs/ITensors/stable/#ITensors.QuantumNumbers.QN","content":" ITensors.QuantumNumbers.QN  —  Type QN(val::Int,modulus::Int=1) Construct a QN with a single unnamed value (equivalent to the name being the empty string) with optional modulus. source"},{"id":156,"pagetitle":"QN","title":"Properties","ref":"/ITensorDocs/ITensors/stable/#Properties","content":" Properties"},{"id":157,"pagetitle":"QN","title":"ITensors.val","ref":"/ITensorDocs/ITensors/stable/#ITensors.val-Tuple{QN, Any}","content":" ITensors.val  —  Method val(q::QN,name) Get the value within the QN q corresponding to the string  name source"},{"id":158,"pagetitle":"QN","title":"ITensors.QuantumNumbers.modulus","ref":"/ITensorDocs/ITensors/stable/#ITensors.QuantumNumbers.modulus-Tuple{QN, Any}","content":" ITensors.QuantumNumbers.modulus  —  Method modulus(q::QN,name) Get the modulus within the QN q corresponding to the string  name source"},{"id":159,"pagetitle":"QN","title":"Related Functions","ref":"/ITensorDocs/ITensors/stable/#Related-Functions","content":" Related Functions"},{"id":160,"pagetitle":"QN","title":"Base.zero","ref":"/ITensorDocs/ITensors/stable/#Base.zero-Tuple{QN}","content":" Base.zero  —  Method zero(q::QN) Returns a QN object containing the same names as q, but with all values set to zero. source"},{"id":163,"pagetitle":"Running on GPUs","title":"Running on GPUs","ref":"/ITensorDocs/ITensors/stable/#Running-on-GPUs","content":" Running on GPUs ITensor provides package extensions for running tensor operations on a variety of GPU backends. You can activate a backend by loading the appropriate Julia GPU package alongside ITensors.jl and moving your tensors and/or tensor networks to an available GPU using that package's provided conversion functions. For example, you can load CUDA.jl to perform tensor operations on NVIDIA GPUs or Metal.jl to perform tensor operations on Apple GPUs: using ITensors\n\ni, j, k = Index.((2, 2, 2))\nA = random_itensor(i, j)\nB = random_itensor(j, k)\n\n# Perform tensor operations on CPU\nA * B\n\n###########################################\nusing CUDA # This will trigger the loading of `NDTensorsCUDAExt` in the background\n\n# Move tensors to NVIDIA GPU\nAcu = cu(A)\nBcu = cu(B)\n\n# Perform tensor operations on NVIDIA GPU\nAcu * Bcu\n\n###########################################\nusing Metal # This will trigger the loading of `NDTensorsMetalExt` in the background\n\n# Move tensors to Apple GPU\nAmtl = mtl(A)\nBmtl = mtl(B)\n\n# Perform tensor operations on Apple GPU\nAmtl * Bmtl Note that we highly recommend using these new package extensions as opposed to  ITensorGPU.jl , which is ITensor's previous CUDA backend. The package extensions are better integrated into the main library so are more reliable and better supported right now. We plan to deprecate  ITensorGPU.jl  in the future."},{"id":164,"pagetitle":"Running on GPUs","title":"GPU backends","ref":"/ITensorDocs/ITensors/stable/#GPU-backends","content":" GPU backends ITensor currently provides package extensions for the following GPU backends: CUDA.jl  (NVIDIA GPUs) cuTENSOR.jl  ( CUDA.jl  extension providing accelerated binary tensor contractions) Metal.jl  (Apple GPUs) AMDGPU.jl  (AMD GPUs) Our goal is to support all GPU backends which are supported by the  JuliaGPU organization . Notice that  cuTENSOR.jl  is an extension of  CUDA.jl  that provides new functionality for accelerated binary tensor contractions. If the  cuTENSOR.jl  library is loaded then ITensors with  CuArray  data are contracted using  cuTENSOR  and if the  cuTENSOR.jl  library is not loaded but  CUDA.jl  is loaded then binary tensor contractions are mapped to a matrix multiplication and performed using  cuBLAS . Some important caveats to keep in mind related to the ITensor GPU backends are: only dense tensor operations are well supported right now. Block sparse operations (which arise when QN conservation is enabled) are under active development and either may not work or may be slower than their CPU counterparts, certain GPU backends do not have native support for certain matrix decompositions like  svd ,  eigen , and  qr  in which case we will perform those operations on CPU. If your calculation is dominated by those operations, there likely is no advantage to running it on GPU right now. CUDA generally has good support for native matrix decompositions, while Metal and AMD have more limited support right now, and single precision ( Float32 ) calculations are generally fastest on GPU. The table below summarizes each backend's current capabilities. CUDA cuTENSOR ROCm Metal oneAPI Contractions (dense) ✓ (cuBLAS) ✓ ✓ ✓ N/A [oneapi] QR (dense) ✓ (cuSOLVER) ✓ (cuSOLVER) On CPU [linalg] On CPU [linalg] N/A [oneapi] SVD (dense) ✓ (cuSOLVER) ✓ (cuSOLVER) On CPU [linalg] On CPU [linalg] N/A [oneapi] Eigendecomposition (dense) ✓ (cuSOLVER) ✓ (cuSOLVER) On CPU [linalg] On CPU [linalg] N/A [oneapi] Double precision ( Float64 ) ✓ ✓ ✓ N/A [metal] N/A [oneapi] Block sparse ✓ [blocksparse] ✓ [blocksparse] ✓ [blocksparse] ✓ [blocksparse] N/A [oneapi] linalg Some GPU vendors have not implemented certain matrix factorizations, or the ones they have implemented are not efficient compared to running on CPU, so as a workaround we perform those operations on CPU by transferring the data back and forth from GPU to CPU. We will add support for running those operations on GPU as they become available. If your algorithm's cost is dominated by those operations you won't see any speedup by trying to run it on those kinds of GPUs. blocksparse Support is experimental. Operations may not be fully optimized and could have bugs. oneapi We plan to add Intel GPU support through Julia's oneAPI.jl interface but don't have any Intel GPUs to test on right now. metal Apple doesn't support double precision floating point operations on their GPUs, see Section 2.1 of the  Metal Shading Language Specification . Until it does, we can't support double precision operations on Apple GPUs."},{"id":167,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Upgrade guide","ref":"/ITensorDocs/ITensors/stable/#Upgrade-guide","content":" Upgrade guide"},{"id":168,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Upgrading from ITensors.jl 0.1 to 0.2","ref":"/ITensorDocs/ITensors/stable/#Upgrading-from-ITensors.jl-0.1-to-0.2","content":" Upgrading from ITensors.jl 0.1 to 0.2 The main breaking changes in ITensor.jl v0.2 involve changes to the  ITensor ,  IndexSet , and  IndexVal  types. Most user code should be fine, but see below for more details. In addition, we have moved development of NDTensors.jl into ITensors.jl to simplify the development process until NDTensors is more stable and can be a standalone package. Again, see below for more details. For a more comprehensive list of changes, see the  commit history on Github . If you have issues upgrading, please reach out by  raising an issue on Github  or asking a question on the  ITensor support forum . Also make sure to run your code with  julia --depwarn=yes  to see warnings about function names and interfaces that have been deprecated and will be removed in v0.3 of ITensors.jl (these are not listed here)."},{"id":169,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Major design changes: changes to the ITensor, IndexSet, and IndexVal types","ref":"/ITensorDocs/ITensors/stable/#Major-design-changes:-changes-to-the-ITensor,-IndexSet,-and-IndexVal-types","content":" Major design changes: changes to the  ITensor ,  IndexSet , and  IndexVal  types"},{"id":170,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Changes to the ITensor type","ref":"/ITensorDocs/ITensors/stable/#Changes-to-the-ITensor-type","content":" Changes to the ITensor type"},{"id":171,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Removal of tensor order type parameter","ref":"/ITensorDocs/ITensors/stable/#Removal-of-tensor-order-type-parameter","content":" Removal of tensor order type parameter The tensor order type paramater has been removed from the  ITensor  type, so you can no longer write  ITensor{3}  to specify an order 3 ITensor ( PR #591 ). Code that uses the ITensor order type parameter will now lead to the following error: julia> i = Index(2)\n(dim=2|id=588)\n\njulia> ITensor{2}(i', i)\nERROR: TypeError: in Type{...} expression, expected UnionAll, got Type{ITensor}\nStacktrace:\n [1] top-level scope\n   @ REPL[27]:1 Simply remove the type parameter: julia> ITensor(i', i)\nITensor ord=2 (dim=2|id=913)' (dim=2|id=913)\nITensors.NDTensors.EmptyStorage{ITensors.NDTensors.EmptyNumber, ITensors.NDTensors.Dense{ITensors.NDTensors.EmptyNumber, Vector{ITensors.NDTensors.EmptyNumber}}} Pro tip: from the command line, you can replace all examples like that with: find . -type f -iname \"*.jl\" -exec sed -i 's/ITensor{.*}/ITensor/g' \"{}\" + Of course, make sure to back up your code before running this! Additionally, a common code pattern may be using the type parameter for dispatch: using ITensors\n\nfunction mynorm(A::ITensor{N}) where {N}\n  return norm(A)^N\nend\n\nfunction mynorm(A::ITensor{1})\n  return norm(A)\nend\n\nfunction mynorm(A::ITensor{2})\n  return norm(A)^2\nend Instead, you can use an if-statement: function mynormN(A::ITensor)\n  return norm(A)^order(A)\nend\n\nfunction mynorm1(A::ITensor)\n  return norm(A)\nend\n\nfunction mynorm2(A::ITensor)\n  return norm(A)^2\nend\n\nfunction mynorm(A::ITensor)\n  return if order(A) == 1\n    mynorm1(A)\n  elseif order(A) == 2\n    mynorm2(A)\n  else\n    return mynormN(A)\n  end\nend Alternatively, you can use the  Order  type to dispatch on the ITensor order as follows: function mynorm(::Order{N}, A::ITensor) where {N}\n  return norm(A)^N\nend\n\nfunction mynorm(::Order{1}, A::ITensor)\n  return norm(A)\nend\n\nfunction mynorm(::Order{2}, A::ITensor)\n  return norm(A)^2\nend\n\nfunction mynorm(A::ITensor)\n  return mynorm(Order(A), A)\nend Order(A::ITensor)  returns the order of the ITensor (like  order(A::ITensor) ), however as a type that can be dispatched on. Note that it is not type stable, so there will be a small runtime overhead for doing this."},{"id":172,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Change to storage type of Index collection in ITensor","ref":"/ITensorDocs/ITensors/stable/#Change-to-storage-type-of-Index-collection-in-ITensor","content":" Change to storage type of Index collection in ITensor ITensors now store a  Tuple  of  Index  instead of an  IndexSet  ( PR #626 ). Therefore, calling  inds  on an ITensor will now just return a  Tuple : julia> i = Index(2)\n(dim=2|id=770)\n\njulia> j = Index(3)\n(dim=3|id=272)\n\njulia> A = random_itensor(i, j)\nITensor ord=2 (dim=2|id=770) (dim=3|id=272)\nITensors.NDTensors.Dense{Float64, Vector{Float64}}\n\njulia> inds(A)\n((dim=2|id=770), (dim=3|id=272)) while before it returned an  IndexSet  (in fact, the  IndexSet  type has been removed, see below for details). In general, this should not affect user code, since a  Tuple  of  Index  should have all of the same functions defined for it that  IndexSet  did. If you find this is not the case, please  raise an issue on Github  or on the  ITensor support forum ."},{"id":173,"pagetitle":"Upgrading from 0.1 to 0.2","title":"ITensor type now directly wraps a Tensor","ref":"/ITensorDocs/ITensors/stable/#ITensor-type-now-directly-wraps-a-Tensor","content":" ITensor type now directly wraps a Tensor The ITensor type no longer has separate field  inds  and  store , just a single field  tensor  (PR #626). In general you should not be accessing the fields directly, instead you should be using the functions  inds(A::ITensor)  and  storage(A::ITensor) , so this should not affect most code. However, in case you have code like: i = Index(2)\nA = random_itensor(i)\nA.inds this will error in v0.2 with: julia> A.inds\nERROR: type ITensor has no field inds\nStacktrace:\n [1] getproperty(x::ITensor, f::Symbol)\n   @ Base ./Base.jl:33\n [2] top-level scope\n   @ REPL[43]:1 and you should change it to: inds(A)"},{"id":174,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Changes to the ITensor constructors","ref":"/ITensorDocs/ITensors/stable/#Changes-to-the-ITensor-constructors","content":" Changes to the ITensor constructors"},{"id":175,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Plain ITensor constructors now return ITensors with EmptyStorage storage","ref":"/ITensorDocs/ITensors/stable/#Plain-ITensor-constructors-now-return-ITensors-with-EmptyStorage-storage","content":" Plain ITensor constructors now return ITensors with  EmptyStorage  storage ITensor  constructors from collections of  Index , such as  ITensor(i, j, k) , now return an  ITensor  with  EmptyStorage  (previously called  Empty ) storage instead of  Dense  or  BlockSparse  storage filled with 0 values. Most operations should still work that worked previously, but please contact us if there are issues ( PR #641 ). For example: julia> i = Index(2)\n(dim=2|id=346)\n\njulia> A = ITensor(i', dag(i))\nITensor ord=2 (dim=2|id=346)' (dim=2|id=346)\nITensors.NDTensors.EmptyStorage{ITensors.NDTensors.EmptyNumber, ITensors.NDTensors.Dense{ITensors.NDTensors.EmptyNumber, Vector{ITensors.NDTensors.EmptyNumber}}}\n\njulia> A' * A\nITensor ord=2 (dim=2|id=346)'' (dim=2|id=346)\nITensors.NDTensors.EmptyStorage{ITensors.NDTensors.EmptyNumber, ITensors.NDTensors.Dense{ITensors.NDTensors.EmptyNumber, Vector{ITensors.NDTensors.EmptyNumber}}} so now contracting two  EmptyStorage  ITensors returns another  EmptyStorage  ITensor. You can allocate the storage by setting elements of the ITensor: julia> A[i' => 1, i => 1] = 0.0\n0.0\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=346)'\nDim 2: (dim=2|id=346)\nITensors.NDTensors.Dense{Float64, Vector{Float64}}\n 2×2\n 0.0  0.0\n 0.0  0.0 Additionally, it will take on the element type of the first value set: julia> A = ITensor(i', dag(i))\nITensor ord=2 (dim=2|id=346)' (dim=2|id=346)\nITensors.NDTensors.EmptyStorage{ITensors.NDTensors.EmptyNumber, ITensors.NDTensors.Dense{ITensors.NDTensors.EmptyNumber, Vector{ITensors.NDTensors.EmptyNumber}}}\n\njulia> A[i' => 1, i => 1] = 1.0 + 0.0im\n1.0 + 0.0im\n\njulia> @show A;\nA = ITensor ord=2\nDim 1: (dim=2|id=346)'\nDim 2: (dim=2|id=346)\nITensors.NDTensors.Dense{ComplexF64, Vector{ComplexF64}}\n 2×2\n 1.0 + 0.0im  0.0 + 0.0im\n 0.0 + 0.0im  0.0 + 0.0im If you have issues upgrading, please let us know."},{"id":176,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Slight change to automatic conversion of element type when constructing ITensor from Array","ref":"/ITensorDocs/ITensors/stable/#Slight-change-to-automatic-conversion-of-element-type-when-constructing-ITensor-from-Array","content":" Slight change to automatic conversion of element type when constructing ITensor from Array ITensor  constructors from  Array  now only convert to floating point for  Array{Int}  and  Array{Complex{Int}} . That same conversion is added for QN ITensor constructors to be consistent with non-QN versions ( PR #620 ). Previously it tried to convert arrays of any element type to the closest floating point type with Julia's  float  function. This should not affect most user code."},{"id":177,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Changes to the IndexSet type","ref":"/ITensorDocs/ITensors/stable/#Changes-to-the-IndexSet-type","content":" Changes to the IndexSet type The  IndexSet  type has been removed in favor of Julia's  Tuple  and  Vector  types ( PR #626 ).  ITensor s now contain a  Tuple  of  Index , while set operations like  commoninds  that used to return  IndexSet  now return a  Vector  of  Index : julia> i = Index(2)\n(dim=2|id=320)\n\njulia> A = random_itensor(i', i)\nITensor ord=2 (dim=2|id=320)' (dim=2|id=320)\nITensors.NDTensors.Dense{Float64, Vector{Float64}}\n\njulia> inds(A) # Previously returned IndexSet, now returns Tuple\n((dim=2|id=320)', (dim=2|id=320))\n\njulia> commoninds(A', A) # Previously returned IndexSet, now returns Vector\n1-element Vector{Index{Int64}}:\n (dim=2|id=320)' To help with upgrading code,  IndexSet{IndexT}  has been redefined as a type alias for  Vector{IndexT<:Index}  (which is subject to change to some other collection of indices, and likely will be removed in ITensors v0.3). Therefore it no longer has a type parameter for the number of indices, similar to the change to the  ITensor  type. If you were using the plain  IndexSet  type, code should generally still work properly. However, if you were using the type parameters of  IndexSet , such as: function myorder2(is::IndexSet{N}) where {N}\n  return N^2\nend then you will need to remove the type parameter and rewrite your code generically to accept  Tuple  or  Vector , such as: function myorder2(is)\n  return length(is)^2\nend In general you should be able to just remove usages of  IndexSet  in your code, and can just use  Tuple  or  Vector  of  Index  instead, such as change  is = IndexSet(i, j, k)  to  is = (i, j, k)  or  is = [i, j, k] . Priming, tagging, and set operations now work generically on those types. If you see issues with upgrading your code, please let us know."},{"id":178,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Changes to the IndexVal type","ref":"/ITensorDocs/ITensors/stable/#Changes-to-the-IndexVal-type","content":" Changes to the IndexVal type Similar to the removal of  IndexSet , we have also removed the  IndexVal  type ( PR #665 ). Now, all use cases of  IndexVal  can be replaced by using Julia's  Pair  type, for example instead of: i = Index(2)\nIndexVal(i, 2) use: i = Index(2)\ni => 2\n# Or:\nPair(i, 2) Note that we have made  IndexVal{IndexT}  an alias for  Pair{IndexT,Int} , so code using  IndexVal  such as  IndexVal(i, 2)  should generally still work. However, we encourage users to change from  IndexVal(i, 2)  to  i => 2 ."},{"id":179,"pagetitle":"Upgrading from 0.1 to 0.2","title":"NDTensors.jl package now being developed internally within ITensors.jl","ref":"/ITensorDocs/ITensors/stable/#NDTensors.jl-package-now-being-developed-internally-within-ITensors.jl","content":" NDTensors.jl package now being developed internally within ITensors.jl The  NDTensors  module has been moved into the  ITensors  package, so  ITensors  no longer depends on the standalone  NDTensors  package. This should only effect users who were using both  NDTensors  and  ITensors  seperately. If you want to use the latest  NDTensors  library, you should do  using ITensors.NDTensors  instead of  using NDTensors , and will need to install  ITensors  with  using Pkg; Pkg.add(\"ITensors\")  in order to use the latest versions of  NDTensors . Note the current  NDTensors.jl  package will still exist, but for now developmentof  NDTensors  will occur within  ITensors.jl  ( PR #650 )."},{"id":180,"pagetitle":"Upgrading from 0.1 to 0.2","title":"Miscellaneous breaking changes","ref":"/ITensorDocs/ITensors/stable/#Miscellaneous-breaking-changes","content":" Miscellaneous breaking changes"},{"id":181,"pagetitle":"Upgrading from 0.1 to 0.2","title":"state function renamed val, state given a new more general definition","ref":"/ITensorDocs/ITensors/stable/#state-function-renamed-val,-state-given-a-new-more-general-definition","content":" state  function renamed  val ,  state  given a new more general definition Rename the  state  functions currently defined for various site types to  val  for mapping a string name for an index to an index value (used in ITensor indexing and MPS construction).  state  functions now return single-index ITensors representing various single-site states ( PR #664 ). So now to get an Index value from a string, you use: N = 10\ns = siteinds(\"S=1/2\", N)\nval(s[1], \"Up\") == 1\nval(s[1], \"Dn\") == 2 state  now returns an ITensor corresponding to the state with that value as the only nonzero element: julia> @show state(s[1], \"Up\");\nstate(s[1], \"Up\") = ITensor ord=1\nDim 1: (dim=2|id=597|\"S=1/2,Site,n=1\")\nITensors.NDTensors.Dense{Float64, Vector{Float64}}\n 2-element\n 1.0\n 0.0\n\njulia> @show state(s[1], \"Dn\");\nstate(s[1], \"Dn\") = ITensor ord=1\nDim 1: (dim=2|id=597|\"S=1/2,Site,n=1\")\nITensors.NDTensors.Dense{Float64, Vector{Float64}}\n 2-element\n 0.0\n 1.0 which allows for more general states to be defined, such as: julia> @show state(s[1], \"X+\");\nstate(s[1], \"X+\") = ITensor ord=1\nDim 1: (dim=2|id=597|\"S=1/2,Site,n=1\")\nITensors.NDTensors.Dense{Float64, Vector{Float64}}\n 2-element\n 0.7071067811865475\n 0.7071067811865475\n\njulia> @show state(s[1], \"X-\");\nstate(s[1], \"X-\") = ITensor ord=1\nDim 1: (dim=2|id=597|\"S=1/2,Site,n=1\")\nITensors.NDTensors.Dense{Float64, Vector{Float64}}\n 2-element\n  0.7071067811865475\n -0.7071067811865475 which will be used for making more general MPS product states. This should not affect end users in general, besides ones who had customized the previous  state  function, such as with overloads like: ITensors.state(::SiteType\"My_S=1/2\", ::StateName\"Up\") = 1\nITensors.state(::SiteType\"My_S=1/2\", ::StateName\"Dn\") = 2 which should be changed now to: ITensors.val(::SiteType\"My_S=1/2\", ::StateName\"Up\") = 1\nITensors.val(::SiteType\"My_S=1/2\", ::StateName\"Dn\") = 2"},{"id":182,"pagetitle":"Upgrading from 0.1 to 0.2","title":"\"Qubit\" site type QN convention change","ref":"/ITensorDocs/ITensors/stable/#\"Qubit\"-site-type-QN-convention-change","content":" \"Qubit\"  site type QN convention change The QN convention of the  \"Qubit\"  site type is changed to track the total number of 1 bits instead of the net number of 1 bits vs 0 bits (i.e. change the QN from +1/-1 to 0/1) ( PR #676 ). julia> s = siteinds(\"Qubit\", 4; conserve_number=true)\n4-element Vector{Index{Vector{Pair{QN, Int64}}}}:\n (dim=2|id=925|\"Qubit,Site,n=1\") <Out>\n 1: QN(\"Number\",0) => 1\n 2: QN(\"Number\",1) => 1\n (dim=2|id=799|\"Qubit,Site,n=2\") <Out>\n 1: QN(\"Number\",0) => 1\n 2: QN(\"Number\",1) => 1\n (dim=2|id=8|\"Qubit,Site,n=3\") <Out>\n 1: QN(\"Number\",0) => 1\n 2: QN(\"Number\",1) => 1\n (dim=2|id=385|\"Qubit,Site,n=4\") <Out>\n 1: QN(\"Number\",0) => 1\n 2: QN(\"Number\",1) => 1 Before it was +1/-1 like  \"S=1/2\" : julia> s = siteinds(\"S=1/2\", 4; conserve_sz=true)\n4-element Vector{Index{Vector{Pair{QN, Int64}}}}:\n (dim=2|id=364|\"S=1/2,Site,n=1\") <Out>\n 1: QN(\"Sz\",1) => 1\n 2: QN(\"Sz\",-1) => 1\n (dim=2|id=823|\"S=1/2,Site,n=2\") <Out>\n 1: QN(\"Sz\",1) => 1\n 2: QN(\"Sz\",-1) => 1\n (dim=2|id=295|\"S=1/2,Site,n=3\") <Out>\n 1: QN(\"Sz\",1) => 1\n 2: QN(\"Sz\",-1) => 1\n (dim=2|id=810|\"S=1/2,Site,n=4\") <Out>\n 1: QN(\"Sz\",1) => 1\n 2: QN(\"Sz\",-1) => 1 This shouldn't affect end users in general. The new convention is a bit more intuitive since the quantum number can be thought of as counting the total number of 1 bits in the state, though the conventions can be mapped to each other with a constant."},{"id":183,"pagetitle":"Upgrading from 0.1 to 0.2","title":"maxlinkdim for MPS/MPO with no indices","ref":"/ITensorDocs/ITensors/stable/#maxlinkdim-for-MPS/MPO-with-no-indices","content":" maxlinkdim  for MPS/MPO with no indices maxlinkdim(::MPS/MPO)  returns a minimum of  1  (previously it returned 0 for MPS/MPO without and link indices) ( PR #663 )."},{"id":186,"pagetitle":"Introduction","title":"ITensors.jl","ref":"/ITensorDocs/ITensors/stable/#ITensors.jl","content":" ITensors.jl ITensor is a library for rapidly creating correct and efficient tensor network algorithms. Documentation Citation Version Download Statistics Style Guide License The source code for ITensors.jl can be found  on Github . Additional documentation can be found on the ITensor website  itensor.org . An ITensor is a tensor whose interface is independent of its memory layout. ITensor indices are objects which carry extra information and which 'recognize' each other (compare equal to each other). The  ITensorMPS.jl library  includes composable and extensible algorithms for optimizing and transforming tensor networks, such as matrix product state and matrix product operators, such as the DMRG algorithm. If you are looking for information on running finite MPS/MPO calculations such as DMRG, take a look at the  ITensorMPS.jl documentation ."},{"id":187,"pagetitle":"Introduction","title":"Support","ref":"/ITensorDocs/ITensors/stable/#Support","content":" Support ITensors.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":188,"pagetitle":"Introduction","title":"News","ref":"/ITensorDocs/ITensors/stable/#News","content":" News March 26, 2025: ITensors.jl v0.9 has been released. This is a minor breaking change since the  optimal_contraction_sequence  function now passes to the  optimaltree  function from  TensorOperations.jl . The  TensorOperations  package therefore needs to be loaded in order for  optimal_contraction_sequence  to be used or if the flag  ITensors.enable_contraction_sequence_optimization()  is switched on. March 22, 2025: As part of the latest release of ITensors.jl (v0.8.3), all documentation related to MPS/MPO functionality has been moved to the  ITensorMPS.jl documentation . February 22, 2025: Please note that there were issues installing the latest version of ITensors.jl (ITensors.jl v0.8) in older versions of Julia v1.10 and v1.11 ( https://github.com/ITensor/ITensors.jl/issues/1618 ,  https://itensor.discourse.group/t/typeparameteraccessors-not-found-error-on-julia-v-1-10-0/2260 ). This issue has been fixed in  NDTensors.jl v0.4.4 , so please try updating your packages if you are using older versions of Julia v1.10 or v1.11 and running into issues installing ITensors.jl. February 3, 2025: ITensors.jl v0.8 has been released. This release should not be breaking to the average user using documented features of the library. This removes internal submodules that held experimental code for rewriting the internals of NDTensors.jl/ITensors.jl, which have now been turned into separate packages for future development. It is marked as breaking since ITensorMPS.jl was making use of some of that experimental code, and will be updated accordingly. Also note that it fixes an issue that existed in some more recent versions of NDTensors.jl v0.3/ITensors.jl v0.7 where loading ITensors.jl in combination with some packages like LinearMaps.jl caused very long load/compile times ( https://itensor.discourse.group/t/linearmaps-and-itensors-incompatibility/2216 ), so if you are seeing that issue when using ITensors.jl v0.7 you should upgrade to this version. October 25, 2024: ITensors.jl v0.7 has been released. This is a major breaking change, since all of the MPS/MPO functionality from this package has been moved to  ITensorMPS.jl , along with all of the functionality of  ITensorTDVP.jl . If you want to use MPS/MPO types and related functionality, such as  MPS ,  MPO ,  dmrg ,  siteinds ,  OpSum ,  op , etc. you now must install and load the ITensorMPS.jl package. Additionally, if you are using ITensorTDVP.jl in your code, please change  using ITensorTDVP  to  using ITensorMPS . ITensorMPS.jl has all of the same functionality as ITensorTDVP.jl, and ITensorTDVP.jl will be deprecated in favor of ITensorMPS.jl.  Note:  If you are using  ITensors.compile , you must now install and load the ITensorMPS.jl package in order to trigger it to load properly, since it relies on running MPS/MPO functionality as example code for Julia to compile. May 9, 2024: A new package  ITensorMPS.jl  has been released. We plan to move all of the MPS/MPO functionality in  ITensors.jl  to  ITensorMPS.jl . For now, ITensorMPS.jl just re-exports the MPS/MPO functionality of ITensors.jl (as well as of  ITensorTDVP.jl ), such as  dmrg ,  siteinds ,  MPS ,  MPO , etc. To prepare for the change over to ITensorMPS.jl, please change  using ITensors  to  using ITensors, ITensorMPS  in any code that makes use of MPS/MPO functionality, and if you are using ITensorTDVP.jl change  using ITensorTDVP  to  using ITensorMPS  in your code. May 8, 2024: ITensors.jl v0.6 has been released. This version deletes the experimental \"combine-contract\" contraction backend, which was enabled by  ITensors.enable_combine_contract() . This feature enabled performing ITensor contractions by first combining indices and then performing contractions as matrix multiplications, which potentially could lead to speedups for certain contractions involving higher-order QN-conserving tensors. However, the speedups weren't consistent with the current implementation, and this feature will be incorporated into the library in a more systematic way when we release our new non-abelian symmetric tensor backend. May 2, 2024: ITensors.jl v0.5 has been released. This version removes PackageCompiler.jl as a dependency and moves the package compilation functionality into a package extension. In order to use the  ITensors.compile()  function going forward, you need to install the PackageCompiler.jl package with  using Pkg: Pkg; Pkg.add(\"PackageCompiler\")  and put  using PackageCompiler  together with  using ITensors  in your code. April 16, 2024: ITensors.jl v0.4 has been released. This version removes HDF5.jl as a dependency and moves the HDF5 read and write functions for ITensor, MPS, MPO, and other associated types into a package extension. To enable ITensor HDF5 features, install the HDF5.jl package with  using Pkg: Pkg; Pkg.add(\"HDF5\")  and put  using HDF5  together with  using ITensors  in your code. Other recent changes include support for multiple GPU backends using package extensions. March 25, 2022: ITensors.jl v0.3 has been released. The main breaking change is that we no longer support versions of Julia below 1.6. Julia 1.6 is the long term support version of Julia (LTS), which means that going forward versions below Julia 1.6 won't be as well supported with bug fixes and improvements. Additionally, Julia 1.6 introduced many improvements including syntax improvements that we would like to start using with ITensors.jl, which becomes challenging if we try to support Julia versions below 1.6. See  here  and  here  for some nice summaries of the Julia 1.6 release. Jun 09, 2021: ITensors.jl v0.2 has been released, with a few breaking changes as well as a variety of bug fixes and new features. Take a look at the  upgrade guide  for help upgrading your code."},{"id":189,"pagetitle":"Introduction","title":"Installation","ref":"/ITensorDocs/ITensors/stable/#Installation","content":" Installation The ITensors package can be installed with the Julia package manager. From the Julia REPL, type  ]  to enter the Pkg REPL mode and run: ~ julia julia> ]\n\npkg> add ITensors Or, equivalently, via the  Pkg  API: julia> import Pkg; Pkg.add(\"ITensors\") Please note that right now, ITensors.jl requires that you use Julia v1.3 or later (since ITensors.jl relies on a feature that was introduced in Julia v1.3). We recommend using ITensors.jl with Intel MKL in order to get the best possible performance. If you have not done so already, you can replace your current BLAS and LAPACK implementation with MKL by using the MKL.jl package. Please follow the instructions  here ."},{"id":190,"pagetitle":"Introduction","title":"Documentation","ref":"/ITensorDocs/ITensors/stable/#Documentation","content":" Documentation LATEST  –  documentation of the latest version."},{"id":191,"pagetitle":"Introduction","title":"Citation","ref":"/ITensorDocs/ITensors/stable/#Citation","content":" Citation If you use ITensor in your work, please cite the  ITensor Paper : @article{ITensor,\n\ttitle={{The ITensor Software Library for Tensor Network Calculations}},\n\tauthor={Matthew Fishman and Steven R. White and E. Miles Stoudenmire},\n\tjournal={SciPost Phys. Codebases},\n\tpages={4},\n\tyear={2022},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCodeb.4},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.4},\n} and associated \"Codebase Release\" for the version you have used. The current one is @article{ITensor-r0.3,\n\ttitle={{Codebase release 0.3 for ITensor}},\n\tauthor={Matthew Fishman and Steven R. White and E. Miles Stoudenmire},\n\tjournal={SciPost Phys. Codebases},\n\tpages={4-r0.3},\n\tyear={2022},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCodeb.4-r0.3},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.4-r0.3},\n}"},{"id":192,"pagetitle":"Introduction","title":"ITensor Code Samples","ref":"/ITensorDocs/ITensors/stable/#ITensor-Code-Samples","content":" ITensor Code Samples"},{"id":193,"pagetitle":"Introduction","title":"Basic Overview","ref":"/ITensorDocs/ITensors/stable/#Basic-Overview","content":" Basic Overview ITensor construction, setting of elements, contraction, and addition. Before constructing an ITensor, one constructs Index objects representing tensor indices. using ITensors\nlet\n  i = Index(3)\n  j = Index(5)\n  k = Index(2)\n  l = Index(7)\n\n  A = ITensor(i,j,k)\n  B = ITensor(j,l)\n\n  # Set elements of A\n  A[i=>1,j=>1,k=>1] = 11.1\n  A[i=>2,j=>1,k=>2] = -21.2\n  A[k=>1,i=>3,j=>1] = 31.1  # can provide Index values in any order\n  # ...\n\n  # Contract over shared index j\n  C = A * B\n\n  @show hasinds(C,i,k,l) # = true\n\n  D = random_itensor(k,j,i) # ITensor with random elements\n\n  # Add two ITensors\n  # must have same set of indices\n  # but can be in any order\n  R = A + D\n\n  nothing\nend\n\n# output\n\nhasinds(C, i, k, l) = true"},{"id":194,"pagetitle":"Introduction","title":"Singular Value Decomposition (SVD) of a Matrix","ref":"/ITensorDocs/ITensors/stable/#Singular-Value-Decomposition-(SVD)-of-a-Matrix","content":" Singular Value Decomposition (SVD) of a Matrix In this example, we create a random 10x20 matrix and compute its SVD. The resulting factors can be simply multiplied back together using the ITensor  *  operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them. using ITensors\nlet\n  i = Index(10)           # index of dimension 10\n  j = Index(20)           # index of dimension 20\n  M = random_itensor(i,j)  # random matrix, indices i,j\n  U,S,V = svd(M,i)        # compute SVD with i as row index\n  @show M ≈ U*S*V         # = true\n\n  nothing\nend\n\n# output\n\nM ≈ U * S * V = true"},{"id":195,"pagetitle":"Introduction","title":"Singular Value Decomposition (SVD) of a Tensor","ref":"/ITensorDocs/ITensors/stable/#Singular-Value-Decomposition-(SVD)-of-a-Tensor","content":" Singular Value Decomposition (SVD) of a Tensor In this example, we create a random 4x4x4x4 tensor and compute its SVD, temporarily treating the indices i and k together as the \"row\" index and j and l as the \"column\" index for the purposes of the SVD. The resulting factors can be simply multiplied back together using the ITensor  *  operation, which automatically recognizes the matching indices between U and S, and between S and V and contracts (sums over) them. using ITensors\nlet\n  i = Index(4,\"i\")\n  j = Index(4,\"j\")\n  k = Index(4,\"k\")\n  l = Index(4,\"l\")\n  T = random_itensor(i,j,k,l)\n  U,S,V = svd(T,i,k)   # compute SVD with (i,k) as row indices (indices of U)\n  @show hasinds(U,i,k) # = true\n  @show hasinds(V,j,l) # = true\n  @show T ≈ U*S*V      # = true\n\n  nothing\nend\n\n# output\n\nhasinds(U, i, k) = true\nhasinds(V, j, l) = true\nT ≈ U * S * V = true"},{"id":196,"pagetitle":"Introduction","title":"Tensor Indices: Tags and Prime Levels","ref":"/ITensorDocs/ITensors/stable/#Tensor-Indices:-Tags-and-Prime-Levels","content":" Tensor Indices: Tags and Prime Levels Before making an ITensor, you have to define its indices. Tensor Index objects carry extra information beyond just their dimension. All Index objects carry a permanent, immutable id number which is determined when it is constructed, and allow it to be matched (compare equal) with copies of itself. Additionally, an Index can have up to four tag strings, and an integer primelevel. If two Index objects have different tags or different prime levels, they do not compare equal even if they have the same id. Tags are also useful for identifying Index objects when printing tensors, and for performing certain Index manipulations (e.g. priming indices having certain sets of tags). using ITensors\nlet\n  i = Index(3)     # Index of dimension 3\n  @show dim(i)     # = 3\n  @show id(i)      # = 0x5d28aa559dd13001 or similar\n\n  ci = copy(i)\n  @show ci == i    # = true\n\n  j = Index(5,\"j\") # Index with a tag \"j\"\n\n  @show j == i     # = false\n\n  s = Index(2,\"n=1,Site\") # Index with two tags,\n                          # \"Site\" and \"n=1\"\n  @show hastags(s,\"Site\") # = true\n  @show hastags(s,\"n=1\")  # = true\n\n  i1 = prime(i) # i1 has a \"prime level\" of 1\n                # but otherwise same properties as i\n  @show i1 == i # = false, prime levels do not match\n\n  nothing\nend\n\n# output\n\ndim(i) = 3\nid(i) = 0x5d28aa559dd13001\nci == i = true\nj == i = false\nhastags(s, \"Site\") = true\nhastags(s, \"n=1\") = true\ni1 == i = false"},{"id":199,"pagetitle":"ITensor Examples","title":"ITensor Code Examples","ref":"/ITensorDocs/ITensors/stable/examples/#itensor_examples","content":" ITensor Code Examples"},{"id":200,"pagetitle":"ITensor Examples","title":"Print Indices of an ITensor","ref":"/ITensorDocs/ITensors/stable/examples/#Print-Indices-of-an-ITensor","content":" Print Indices of an ITensor Sometimes the printout of an ITensor can be rather large, whereas you might only want to see its indices. For these cases, just wrap the ITensor in the function  inds  like this: @show inds(T) or this println(\"T inds = \",inds(T))"},{"id":201,"pagetitle":"ITensor Examples","title":"Getting and Setting Elements of an ITensor","ref":"/ITensorDocs/ITensors/stable/examples/#Getting-and-Setting-Elements-of-an-ITensor","content":" Getting and Setting Elements of an ITensor Say we have an ITensor constructed as: i = Index(3,\"index_i\")\nj = Index(2,\"index_j\")\nk = Index(4,\"index_k\")\n\nT = ITensor(i,j,k) An ITensor constructed this way starts with all of its elements equal to zero. (Technically it allocates no storage at all but this is an implementation detail.) Setting Elements To set an element of this ITensor, such as the element where  (i,j,k) = (2,1,3) , you can do the following: T[i=>2,j=>1,k=>3] = -3.2 In the Julia language, the notation  a=>b  is a built-in notation for making a  Pair(a,b)  object. Because the Index objects are passed to  T  along with their values, passing them in a different order has exactly the same effect: # Both of these lines of code do the same thing:\nT[j=>1,i=>2,k=>3] = -3.2\nT[j=>1,k=>3,i=>2] = -3.2 Getting Elements You can retrieve individual elements of an ITensor by accessing them through the same notation used to set elements: el = T[j=>1,i=>2,k=>3]\nprintln(\"The (i,j,k) = (2,1,3) element of T is \",el)"},{"id":202,"pagetitle":"ITensor Examples","title":"Making ITensors from Arrays","ref":"/ITensorDocs/ITensors/stable/examples/#Making-ITensors-from-Arrays","content":" Making ITensors from Arrays To initialize all of the elements of an ITensor at once, you can pass a Julia array into the ITensor constructor. For example, if we want to construct an ITensor  A  with indices  i,j  we can initialize it from a matrix as follows: M = [1.0 2.0;\n     3.0 4.0]\n\ni = Index(2,\"i\")\nj = Index(2,\"j\")\n\nA = ITensor(M,i,j) More generally we can use an nth-order (n-dimensional) Julia array to initialize an ITensor: T = randn(4,7,2)\n\nk = Index(4,\"index_k\")\nl = Index(7,\"index_l\")\nm = Index(2,\"index_m\")\n\nB = ITensor(T,k,l,m)"},{"id":203,"pagetitle":"ITensor Examples","title":"Making Arrays from ITensors","ref":"/ITensorDocs/ITensors/stable/examples/#Making-Arrays-from-ITensors","content":" Making Arrays from ITensors Not only can we make an ITensor from a Julia array, but we can also convert an ITensor back into a Julia array. Say we have made an ITensor with two indices: k = Index(4,\"index_k\")\nm = Index(2,\"index_m\")\n\nT = random_itensor(k,m)\n@show T T = ITensor ord=2\nDim 1: (dim=4|id=141|\"index_k\")\nDim 2: (dim=2|id=11|\"index_m\")\nNDTensors.Dense{Float64, Vector{Float64}}\n 4×2\n  0.8155514094111388     0.5016471999175879\n  0.4511623980592344     0.7072433050944762\n  0.5288475200510232    -0.48567309543343656\n -0.062227236473178585   2.397660238398694 Here we used the  random_itensor  constructor to fill T with random elements but we could make an ITensor some other way too. Now to convert  T  into a regular Julia array  A , use the  Array  constructor and pass the indices of  T  in the order that you want: A = Array(T,k,m)\n@show A 4×2 Matrix{Float64}:\n  0.815551    0.501647\n  0.451162    0.707243\n  0.528848   -0.485673\n -0.0622272   2.39766 The reason you have to pass the indices is that the ordering of ITensor indices is an implementation detail and not part of the user interface. So when leaving the ITensor system and converting to a regular array, you must say what ordering of the indices you want. Making the array as  A = Array(T,m,k)  would give the transpose of the array in the code above. Note that for efficiency reasons, the array returned by the  array  function will sometimes be a  view  of the ITensor, such that changing an element of  A  would also change the corresponding element of  T . This is not always the case though: for example if the indices are passed in a different order from how the internal ITensor storage is arranged, or if   T  is a block-sparse ITensor, since the (not stored) zero blocks will need to be filled in."},{"id":204,"pagetitle":"ITensor Examples","title":"Arithmetic With ITensors","ref":"/ITensorDocs/ITensors/stable/examples/#Arithmetic-With-ITensors","content":" Arithmetic With ITensors ITensors can be added and subtracted and multiplied by scalars just like plain tensors can. But ITensors have the additional feature that you can add and subtract them even if their indices are in a different order from each other, as long as they have the same collection of indices. For example, say we have ITensors  A ,  B , and  C : i = Index(3,\"i\")\nj = Index(2,\"j\")\nk = Index(4,\"k\")\n\nA = random_itensor(i,j,k)\nB = random_itensor(i,j,k)\nC = random_itensor(k,i,j) Above we have initialized these ITensors to have random elements, just for the sake of this example. We can then add or subtract these ITensors R1 = A + B\nR2 = A - B\nR3 = A + B - C or do more complicated operations involving real and complex scalars too: R4 = 2.0*A - B + C/(1+1im)"},{"id":205,"pagetitle":"ITensor Examples","title":"Elementwise Operations on ITensors","ref":"/ITensorDocs/ITensors/stable/examples/#Elementwise-Operations-on-ITensors","content":" Elementwise Operations on ITensors [ Note: currently elementwise operations are only defined for dense ITensors, not for block-sparse QN ITensors. ] ITensors support Julia broadcasting operations, making it quite easy to carry out element-wise operations on them in a very similar way as for regular Julia arrays. As a concrete example, consider the following ITensor initialized with random elements i = Index(2,\"i\")\nj = Index(3,\"j\")\n\nA = random_itensor(i,j) Here are some examples of basic element-wise operations we can do using Julia's dotted operator broadcasting syntax. # Multiply every element of `A` by 2.0:\nA .*= 2.0 # Add 1.5 to every element of A\nA .+= 1.5 The dotted notation works for functions too: # Replace every element in A by its absolute value:\nA .= abs.(A) # Replace every element in A by the number 1.0\nA .= one.(A) If have another ITensor  B = ITensor(j,i) , which has the same set of indices though possibly in a different order, then we can also do element-wise operations involving both ITensors: # Add elements of A and B element-wise\nA .= A .+ B\n# Add elements of A and B element-wise with coefficients included\nA .= (2.0 .* A) .+ (-3.0 .* B) Last but not least, it is possible to make custom functions yourself and broadcast them across elements of ITensors: myf(x) = 1.0/(1.0+exp(-x))\nT .= myf.(T)"},{"id":206,"pagetitle":"ITensor Examples","title":"Making an ITensor with a Single Non-Zero Element","ref":"/ITensorDocs/ITensors/stable/examples/#Making-an-ITensor-with-a-Single-Non-Zero-Element","content":" Making an ITensor with a Single Non-Zero Element It is often useful to make ITensors with all elements zero except for a specific element that is equal to 1.0. Use cases can include making product-state quantum wavefunctions or contracting single-element ITensors with other ITensors to set their indices to a fixed value. To make such an ITensor, use the  onehot  function. Borrowing terminology from engineering, a \"one hot\" vector or tensor has a single element equal to 1.0 and the rest zero. (In previous versions of ITensor this function was called  setelt .) The ITensor function  onehot  takes one or more Index-value Pairs such as  i=>2  and  j=>1  and returns an ITensor with a 1.0 in the location specified by the Index values: i = Index(2)\nO1 = onehot(i=>1)\nprintln(O1) ITensor ord=1\nDim 1: (dim=2|id=436)\nNDTensors.Dense{Float64, Vector{Float64}}\n 2-element\n 1.0\n 0.0 O2 = onehot(i=>2)\nprintln(O2) ITensor ord=1\nDim 1: (dim=2|id=890)\nNDTensors.Dense{Float64, Vector{Float64}}\n 2-element\n 0.0\n 1.0 j = Index(3)\nT = onehot(i=>2,j=>3)\nprintln(T) ITensor ord=2\nDim 1: (dim=2|id=329)\nDim 2: (dim=3|id=395)\nNDTensors.Dense{Float64, Vector{Float64}}\n 2×3\n 0.0  0.0  0.0\n 0.0  0.0  1.0"},{"id":207,"pagetitle":"ITensor Examples","title":"Tracing an ITensor","ref":"/ITensorDocs/ITensors/stable/examples/#Tracing-an-ITensor","content":" Tracing an ITensor An important operation involving a single tensor is tracing out certain pairs of indices. Say we have an ITensor  A  with indices  i,j,l : i = Index(4,\"i\")\nj = Index(3,\"j\")\nl = Index(4,\"l\")\n\nA = random_itensor(i,j,l) and we want to trace  A  by summing over the indices  i  and  l  locked together, in other words:  $\\sum_{i} A^{iji}$ . To do this in ITensor, we can use a  delta  tensor, which you can think of as an identity operator or more generally a Kronecker delta or \"hyper-edge\": Viewed as an array, a delta tensor has all diagonal elements equal to 1.0 and zero otherwise. Now we can compute the trace by contracting  A  with the delta tensor: trA = A * delta(i,l)"},{"id":208,"pagetitle":"ITensor Examples","title":"Factoring ITensors (SVD, QR, etc.)","ref":"/ITensorDocs/ITensors/stable/examples/#Factoring-ITensors-(SVD,-QR,-etc.)","content":" Factoring ITensors (SVD, QR, etc.) The ITensor approach to tensor factorizations emphasizes the structure of the factorization, and does not require knowing the index ordering. ITensor offers various tensor factorizations, such as the singular value decomposition (SVD) and the QR factorization. These are extended to the case of tensors by treating some of the indices as the \"row\" indices and the rest of the indices as the \"column\" indices, reshaping the tensor into a matrix to carry out the factorization, then restoring the tensor structure at the end. All of these steps are done for you by the ITensor system as we will see below."},{"id":209,"pagetitle":"ITensor Examples","title":"Singular Value Decomposition","ref":"/ITensorDocs/ITensors/stable/examples/#Singular-Value-Decomposition","content":" Singular Value Decomposition The singular value decomposition (SVD) is a matrix factorization that is also extremely useful for general tensors. As a brief review, the SVD is a factorization of a matrix M into the product \\[M = U S V^\\dagger\\] with U and V having the property  $U^\\dagger U = 1$  and  $V^\\dagger V = 1$ . The matrix S is diagonal and has real, non-negative entries known as the singular values, which are typically ordered from largest to smallest. The SVD is well-defined for any matrix, including rectangular matrices. It also leads to a controlled approximation, where the error due to discarding columns of U and V is small if the corresponding singular values discarded are small. To compute the SVD of an ITensor, you only need to specify which indices are (collectively) the \"row\" indices (thinking of the ITensor as a matrix), with the rest assumed to be the \"column\" indices. Say we have an ITensor with indices i,j, and k T = ITensor(i,j,k) and we want to treat i and k as the \"row\" indices for the purpose of the SVD. To perform this SVD, we can call the function  svd  as follows: U,S,V = svd(T,(i,k)) Diagrammatically the SVD operation above looks like: The guarantee of the  svd  function is that the ITensor product  U*S*V  gives us back an ITensor identical to T: @show norm(U*S*V - T) # typical output: norm(U*S*V-T) = 1E-14 Full working example: i = Index(3,\"i\")\nj = Index(4,\"j\")\nk = Index(5,\"k\")\n\nT = random_itensor(i,j,k)\n\nU,S,V = svd(T,(i,k))\n\n@show norm(U*S*V-T) Truncated SVD An important use of the SVD is approximating a higher-rank tensor by a product of lower-rank tensors whose indices range over only a modest set of values. To obtain an approximate SVD in ITensor, pass one or more of the following accuracy parameters as named arguments: cutoff  –- real number  $\\epsilon$ . Discard the smallest singular values  $\\lambda\\_n$  such that the <i>truncation error</i> is less than  $\\epsilon$ : $ \\frac{\\sum_{n\\in\\text{discarded}} \\lambda^2_n}{\\sum_{n} \\lambda^2_n} < \\epsilon \\:. $ Using a cutoff allows the SVD algorithm to truncate as many states as possible while still ensuring a certain accuracy. maxdim  –- integer M. If the number of singular values exceeds M, only the largest M will be retained. mindim  –- integer m. At least m singular values will be retained, even if some fall below the cutoff Let us revisit the example above, but also provide some of these accuracy parameters i = Index(10,\"i\")\nj = Index(40,\"j\")\nk = Index(20,\"k\")\nT = random_itensor(i,j,k)\n\nU,S,V = svd(T,(i,k),cutoff=1E-2) Note that we have also made the indices larger so that the truncation performed will be non-trivial. In the code above, we specified that a cutoff of  $\\epsilon=10^{-2}$  be used. We can check that the resulting factorization is now approximate by computing the squared relative error: truncerr = (norm(U*S*V - T)/norm(T))^2\n@show truncerr\n# typical output: truncerr = 8.24E-03 Note how the computed error is below the cutoff  $\\epsilon$  we requested. Full working example including truncation: i = Index(10,\"i\");\nj = Index(40,\"j\");\nk = Index(20,\"k\");\n\nT = random_itensor(i,j,k)\n\nU,S,V = svd(T,(i,k),cutoff=1E-2)\n\n@show norm(U*S*V-T)\n@show (norm(U*S*V - T)/norm(T))^2"},{"id":210,"pagetitle":"ITensor Examples","title":"QR Factorization","ref":"/ITensorDocs/ITensors/stable/examples/#QR-Factorization","content":" QR Factorization Computing the QR factorization of an ITensor works in a similar way as for the SVD. In addition to passing the ITensor you want to factorize, you must also pass the indices you want to end up on the tensor  Q , in other words to be treated as the \"row\" indices for the purpose of defining the QR factorization. Say we want to compute the QR factorization of an ITensor  T  with indices  i,j,k , putting the indices  i  and  k  onto  Q  and the remaining indices onto  R . We can do this as follows: T = random_itensor(i,j,k)\nQ,R = qr(T,(i,k);positive=true) Note the use of the optional  positive=true  keyword argument, which ensures that the diagonal elements of  R  are non-negative. With this option, the QR factorization is  unique , which can be useful in certain cases."},{"id":211,"pagetitle":"ITensor Examples","title":"Combining Multiple Indices into One Index","ref":"/ITensorDocs/ITensors/stable/examples/#Combining-Multiple-Indices-into-One-Index","content":" Combining Multiple Indices into One Index It can be very useful to combine or merge multiple indices of an ITensor into a single Index. Say we have an ITensor with indices  i,j,k  and we want to combine Index  i  and Index  k  into a new Index. This new Index (call it  c ) will have a dimension whose size is the dimension of  i  times the dimension of  k . To carry out this procedure we can make a special kind of ITensor: a combiner. To make a combiner, call the function  combiner , passing the indices you want to combine: C = combiner(i,k; tags=\"c\") Then if we have an ITensor T = random_itensor(i,j,k)\n@show inds(T) ((dim=4|id=684|\"i\"), (dim=3|id=681|\"j\"), (dim=2|id=653|\"k\")) we can combine indices  i  and  k  by contracting with the combiner: CT = C * T Printing out the indices of the new ITensor  CT  we can see that it has only two indices: @show inds(CT) ((dim=8|id=526|\"c\"), (dim=3|id=681|\"j\")) The first is the newly made combined Index, which was made for us by the  combiner  function and the second is the  j  Index of  T  which was not part of the combining process. To access the combined Index you can call the  combinedind  function on the combiner: ci = combinedind(C) (dim=8|id=526|\"c\") We can visualize all of the steps above as follows:  Combining is not limited to two indices and you can combine any number of indices, in any order, using a combiner. To undo the combining process and uncombine the Index  c  back into  i,k , just contract with the conjugate of the combiner ITensor  dag(C) . UT = dag(C) * CT\n@show inds(UT) ((dim=4|id=684|\"i\"), (dim=2|id=653|\"k\"), (dim=3|id=681|\"j\"))"},{"id":212,"pagetitle":"ITensor Examples","title":"Write and Read an ITensor to Disk with HDF5","ref":"/ITensorDocs/ITensors/stable/examples/#Write-and-Read-an-ITensor-to-Disk-with-HDF5","content":" Write and Read an ITensor to Disk with HDF5 Info Make sure to install the HDF5 package to use this feature. (Run  julia> ] add HDF5  in the Julia REPL console.) Saving ITensors to disk can be very useful. For example, you might encounter a bug in your own code, and by reading the ITensors involved from disk you can shortcut the process of running a lengthy algorithm over many times to reproduce the bug. Or you can save the output of an expensive calculation, such as a DMRG calculation, and use it as a starting point for multiple follow-up calculations such as computing time-dependent properties. ITensors can be written to files using the HDF5 format. HDF5 offers many benefits such as being portable across different machine types, and offers a standard interface across various libraries and languages. Writing an ITensor to an HDF5 File Let's say you have an ITensor  T  which you have made or obtained from a calculation. To write it to an HDF5 file named \"myfile.h5\" you can use the following pattern: using HDF5\nf = h5open(\"myfile.h5\",\"w\")\nwrite(f,\"T\",T)\nclose(f) Above, the string \"T\" can actually be any string you want such as \"ITensor T\" or \"Result Tensor\" and doesn't have to have the same name as the reference  T . Closing the file  f  is optional and you can also write other objects to the same file before closing it. Reading an ITensor from an HDF5 File Say you have an HDF5 file \"myfile.h5\" which contains an ITensor stored as a dataset with the name \"T\". (Which would be the situation if you wrote it as in the example above.) To read this ITensor back from the HDF5 file, use the following pattern: using HDF5\nf = h5open(\"myfile.h5\",\"r\")\nT = read(f,\"T\",ITensor)\nclose(f) Note the  ITensor  argument to the read function, which tells Julia which read function to call and how to interpret the data stored in the HDF5 dataset named \"T\". In the future we might lift the requirement of providing the type and have it be detected automatically from the data stored in the file."},{"id":215,"pagetitle":"ITensor Development FAQs","title":"ITensor Development Frequently Asked Questions","ref":"/ITensorDocs/ITensors/stable/faq/#ITensor-Development-Frequently-Asked-Questions","content":" ITensor Development Frequently Asked Questions"},{"id":216,"pagetitle":"ITensor Development FAQs","title":"What are the steps to contribute code to ITensor?","ref":"/ITensorDocs/ITensors/stable/faq/#What-are-the-steps-to-contribute-code-to-ITensor?","content":" What are the steps to contribute code to ITensor? Please contact us (support at itensor.org) if you are planning to submit a major contribution (more than a few lines of code, say). If so, we would like to discuss your plan and design before you spend significant time on it, to increase the chances we will merge your pull request. Fork the  ITensors.jl  Github repo, create a new branch and make changes (commits) on that branch. ITensor imposes code formatting for contributions. Please run  using JuliaFormatter; format(\".\")  in the project directory to ensure formatting. As an alternative you may also use  pre-commit . Install  pre-commit  with e.g.  pip install pre-commit , then run  pre-commit install  in the project directory in order for pre-commit to run automatically before any commit. Run the ITensor unit tests by going into the test/ folder and running  julia runtests.jl . To run individual test scripts, start a Julia REPL (interactive terminal) session and include each script, such as  include(\"itensor.jl\") . Push your new branch and changes to your forked repo. Github will give you the option to make a pull request (PR) out of your branch that will be submitted to us, and which you can view under the list of ITensors.jl pull requests. If your PR's tests pass and we approve your changes, we will merge it or ask you to merge it. If you merge your PR,  please use the Squash and Merge  option. We may also ask you to make more changes to bring your PR in line with our design goals or technical requirements."},{"id":219,"pagetitle":"Julia Package Manager FAQs","title":"Julia Package Manager Frequently Asked Questions","ref":"/ITensorDocs/ITensors/stable/faq/#Julia-Package-Manager-Frequently-Asked-Questions","content":" Julia Package Manager Frequently Asked Questions"},{"id":220,"pagetitle":"Julia Package Manager FAQs","title":"What if I can't upgrade ITensors.jl to the latest version?","ref":"/ITensorDocs/ITensors/stable/faq/#What-if-I-can't-upgrade-ITensors.jl-to-the-latest-version?","content":" What if I can't upgrade ITensors.jl to the latest version? Sometimes you may find that doing  ] update ITensors  or equivalently doing  ] up ITensors  within Julia package manager mode doesn't result in the ITensors package actually being upgraded. You may see that the current version you have remains stuck to a version that is lower than the latest one which you can  check here . What is most likely going on is that you have other packages installed which are blocking ITensors from being updated. To get more information into which packages may be doing this, and what versions they are requiring, you can do the following. First  look up the latest version of ITensors.jl . Let's say for this example that it is  v0.3.0 . Next, input the following command while in package manager mode: julia> ]\npkg> add ITensors@v0.3.0 If the package manager cannot update to this version, it will list all of the other packages that are blocking this from happening and give information about why. To go into a little more depth, each package has a compatibility or \"compat\" entry in its Project.toml file which says which versions of the ITensors package it is compatible with. If these versions do not include the latest one, perhaps because the package has not been updated, then it can block the ITensors package from being updated on your system. Generally the solution is to just update each of these packages, then try again to update ITensors. If that does not work, then check the following Are any of the blocking packages in \"dev mode\" meaning you called  dev PackageName  on them in the past? Try doing  free PackageName  if so to bring them out of dev mode. Are any of the blocking packages unregistered packages that were installed through a GitHub repo link? If so, you may need to do something like  add https://github.com/Org/PackageName#main  to force update that package to the latest code available on its main branch. If you still can't get the ITensors package update, feel free to  post a question  or  contact us  for help."},{"id":223,"pagetitle":"Enabling Debug Checks","title":"Enabling Debug Checks","ref":"/ITensorDocs/ITensors/stable/getting_started/#Enabling-Debug-Checks","content":" Enabling Debug Checks ITensor provides some optional checks for common errors, which we call \"debug checks\". These can be enabled with the command: ITensors.enable_debug_checks() and disabled with the command: ITensors.disable_debug_checks() We recommend enabling debug checks when you are developing and testing your code, and then disabling them when running in production to get the best performance. For example, when debug checks are turned on, ITensor checks that all indices of an ITensor are unique (if they are not unique, it leads to undefined behavior in tensor operations like contraction, addition, and decomposition): julia> using ITensors\n\njulia> i = Index(2)\n(dim=2|id=913)\n\njulia> A = random_itensor(i', i)\nITensor ord=2 (dim=2|id=913)' (dim=2|id=913)\nNDTensors.Dense{Float64, Vector{Float64}}\n\njulia> noprime(A)\nITensor ord=2 (dim=2|id=913) (dim=2|id=913)\nNDTensors.Dense{Float64, Vector{Float64}}\n\njulia> ITensors.enable_debug_checks()\nusing_debug_checks (generic function with 1 method)\n\njulia> noprime(A)\nERROR: Trying to create ITensors with collection of indices ((dim=2|id=913), (dim=2|id=913)). Indices must be unique.\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:33\n [2] macro expansion\n   @ ~/.julia/packages/ITensors/cu9Bo/src/itensor.jl:85 [inlined]\n [3] macro expansion\n   @ ~/.julia/packages/ITensors/cu9Bo/src/global_variables.jl:177 [inlined]\n [4] ITensor\n   @ ~/.julia/packages/ITensors/cu9Bo/src/itensor.jl:82 [inlined]\n [5] #itensor#123\n   @ ~/.julia/packages/ITensors/cu9Bo/src/itensor.jl:123 [inlined]\n [6] itensor(args::NDTensors.DenseTensor{Float64, 2, Tuple{Index{Int64}, Index{Int64}}, NDTensors.Dense{Float64, Vector{Float64}}})\n   @ ITensors ~/.julia/packages/ITensors/cu9Bo/src/itensor.jl:123\n [7] noprime(::ITensor; kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})\n   @ ITensors ~/.julia/packages/ITensors/cu9Bo/src/itensor.jl:1211\n [8] noprime(::ITensor)\n   @ ITensors ~/.julia/packages/ITensors/cu9Bo/src/itensor.jl:1211\n [9] top-level scope\n   @ REPL[7]:1 You can track where debug checks are located in the code  here , and add your own debug checks to your own code by wrapping your code with the macro  ITensors.@debug_check ."},{"id":226,"pagetitle":"Installing Julia and ITensor","title":"Installing Julia and ITensor","ref":"/ITensorDocs/ITensors/stable/getting_started/#Installing-Julia-and-ITensor","content":" Installing Julia and ITensor"},{"id":227,"pagetitle":"Installing Julia and ITensor","title":"Installing Julia Locally and On a Cluster","ref":"/ITensorDocs/ITensors/stable/getting_started/#Installing-Julia-Locally-and-On-a-Cluster","content":" Installing Julia Locally and On a Cluster Because Julia is a new language, it is usually not pre-installed on machines such as supercomputing clusters. But it is easy to install yourself both on your own machine and in your supercomputing environment. Here we will briefly cover installing Julia on your own machine, then discuss setting it up yourself on a supercomputer. Installing Julia on Your Own Machine To install the Julia language, visit  https://julialang.org/downloads/  for downloads and installation instructions. Or consider using your system's package manager. Cluster Install of Julia and ITensor If you would like to use Julia on a remote cluster, such as at many labs or universities, but Julia is not available system-wide, you can still easily install your own local version of Julia. A local install will offer the same performance and features (package manager, etc.) as a system-wide install, and you can upgrade it at your own pace. Once you set up Julia in your cluster account, you can install ITensor in the same way as on your personal computer (see next section on installing ITensor). To install Julia locally within your cluster account, follow these basic steps (details will vary depending on your setup): Download a binary version of Julia  here . On a remote Unix or Linux cluster, you can use the program  wget  to download remote files. (Right click on the link on the Julia downloads page to the Generic Linux on x86, 64-bit Julia download to copy the link to pass to the  wget  program.) Use the tar program to uncompress the .tar.gz file you have downloaded. Create a soft link somewhere in your PATH (such as in the bin/ subfolder of your home folder, which you might need to create) pointing to the file \"bin/julia\" inside of the uncompressed Julia folder you just created. For example, the set of commands might look like this (where these commands are assumed to be executed in your home directory): $ cd\n$ mkdir -p bin\n$ wget https://julialang-s3.julialang.org/bin/linux/x64/1.7/julia-1.7.2-linux-x86_64.tar.gz\n$ tar xvzf julia-1.7.2-linux-x86_64.tar.gz\n$ ln -s julia-1.7.2/bin/julia  bin/julia If you want to install Julia 1.6.6, you would change  1.7  to  1.6  and  1.7.2  to  1.6.6 . In general we recommend using the current stable release of Julia, which you can find out by going to  the Julia Downloads page . We also don't recommend using versions of Julia below 1.6, which are no longer compatible with ITensors.jl as of ITensors 0.3. After these steps, you should be able to type  julia  from your terminal to run Julia in interactive mode. If that works, then you have the Julia language and can run it in all the usual ways. If it does not work, you may need to log out and back in, and check that the  bin  directory is in your program execution path (PATH environment variable). Explanation of the sample commands above: The first command  cd  goes to your home directory. The second command makes a new folder  bin/  under your home directory if it does not already exist. The third command downloads the Julia language as a compressed tar.gz file. (You may want to do this step and the follwing steps in a different folder of your choosing.) The fourth command uncompresses the tar.gz file into a folder called (in this example)  julia-1.7.2 . The last command makes a soft link called  julia  in your  bin  directory which links to the Julia language binary within the folder you just unpacked containing the Julia language."},{"id":228,"pagetitle":"Installing Julia and ITensor","title":"Installing ITensor (ITensors.jl Package)","ref":"/ITensorDocs/ITensors/stable/getting_started/#Installing-ITensor-(ITensors.jl-Package)","content":" Installing ITensor (ITensors.jl Package) Installing the Julia version of ITensor is easy once you have the Julia language installed. For more information about installing Julia, please see  the Julia language downloads page . Once you have installed Julia on your machine, Enter the command  julia  to launch an interactive Julia session (a.k.a. the Julia \" REPL \") Type  ]  to enter the package manager ( pkg>  prompt should now show) Enter the command  add ITensors After installation completes, press backspace to return to the normal  julia>  prompt Optional but Recommended : Enter the command  julia> using ITensors; ITensors.compile()  to compile a large fraction of the ITensor library code and following the instructions afterward to make an alias for loading a pre-built ITensor system image with Julia. This step can take up to 10 minutes to complete but only has to be done once for each version of ITensor. See the section on compiling ITensor for more information. Sample screenshot:"},{"id":231,"pagetitle":"Next Steps","title":"Next Steps","ref":"/ITensorDocs/ITensors/stable/getting_started/#Next-Steps","content":" Next Steps Browse the  Code Examples . Read the  ITensor Paper  for a long-form introduction to the design and main features of the ITensor library Refer to the  ITensorMPS.jl documentation  for information on running finite MPS/MPO calculations such as DMRG. More Julia language tutorials and resources From zero to Julia! Think Julia Official Julia Language Manual List of Resources at julialang.org"},{"id":234,"pagetitle":"Running ITensor and Julia Codes","title":"Running ITensor and Julia Codes","ref":"/ITensorDocs/ITensors/stable/getting_started/#Running-ITensor-and-Julia-Codes","content":" Running ITensor and Julia Codes"},{"id":235,"pagetitle":"Running ITensor and Julia Codes","title":"Basic Example Code Template","ref":"/ITensorDocs/ITensors/stable/getting_started/#Basic-Example-Code-Template","content":" Basic Example Code Template The basic outline of a code which uses the ITensor library is as follows using ITensors\n\nlet\n  # ... your own code goes here ...\n  # For example:\n  i = Index(2,\"i\")\n  j = Index(3,\"j\")\n  T = random_itensor(i,j)\n  @show T\nend The reason we recommend the  let...end  block is that code written in the Julia global scope can have some surprising behaviors. Putting your code into a  let  block avoids these issues. Alternatively, you can wrap your code in a function: using ITensors\n\nfunction main(; d1 = 2, d2 = 3)\n  # ... your own code goes here ...\n  # For example:\n  i = Index(d1,\"i\")\n  j = Index(d2,\"j\")\n  T = random_itensor(i,j)\n  @show T\nend\n\nmain(; d1 = 4, d2 = 5) which can be useful in interactive mode, particularly if you might want to run your code with a variety of different arguments."},{"id":236,"pagetitle":"Running ITensor and Julia Codes","title":"Running a Script","ref":"/ITensorDocs/ITensors/stable/getting_started/#Running-a-Script","content":" Running a Script Now say you put the above code into a file named  code.jl . Then you can run this code on the command line as follows $ julia code.jl This script-like mode of running Julia is convenient for running longer jobs, such as on a cluster."},{"id":237,"pagetitle":"Running ITensor and Julia Codes","title":"Running Interactively","ref":"/ITensorDocs/ITensors/stable/getting_started/#Running-Interactively","content":" Running Interactively However, sometimes you want to do rapid development when first writing and testing a code. For this kind of work, the long startup and compilation times currently incurred by the Julia compiler can be a nuisance. Fortunately a nice solution is to alternate between modifying your code then running it by loading it into an already running Julia session. To set up this kind of session, take the following steps: Enter the interactive mode of Julia, by inputting the command  julia  on the command line. You will now be in the Julia \"REPL\" (read-eval-print loop) with the prompt  julia>  on the left of your screen. To run a code such as the  code.jl  file discussed above, input the command julia> include(\"code.jl\") Note that you must be in the same folder as  code.jl  for this to work; otherwise input the entire path to the  code.jl  file. The code will run and you will see its output in the REPL. Now say you want to modify and re-run the code. To do this, just edit the file in an editor in another window, without closing your Julia session. Now run the command julia> include(\"code.jl\") again and your updated code will run, but this time skipping any of the precompilation overhead incurred on previous steps. The above steps to running a code interactively has a big advantage that you only have to pay the startup time of compiling ITensor and other libraries you are using once. Further changes to your code only incur very small extra compilation times, facilitating rapid development."},{"id":238,"pagetitle":"Running ITensor and Julia Codes","title":"Compiling an ITensor System Image","ref":"/ITensorDocs/ITensors/stable/getting_started/#Compiling-an-ITensor-System-Image","content":" Compiling an ITensor System Image The above strategy of running code in the Julia REPL (interactive mode) works well, but still incurs a large start-up penalty for the first run of your code. Fortunately there is a nice way around this issue too: compiling ITensors.jl and making a system image built by the  PackageCompiler.jl  library. To use this approach, we have provided a convenient one-line command: julia> using ITensors, ITensorMPS, PackageCompiler\n\njulia> ITensors.compile() Note that you need to have ITensors.jl, ITensorMPS.jl, and PackageCompiler.jl installed. It can take a few minutes to run, but you only have to run it once for a given version of ITensors.jl. When it is done, it will create a file  sys_itensors.so  in the directory  ~/.julia/sysimages/ . To use the compiled system image together with Julia, run the  julia  command (for interactive mode or scripts) in the following way: $ julia --sysimage ~/.julia/sysimages/sys_itensors.so A convenient thing to do is to make an alias in your shell for this command. To do this, edit your  .bashrc  or  .zshrc  or similar file for the shell you use by adding the following line: alias julia_itensors=\"julia --sysimage ~/.julia/sysimages/sys_itensors.so -e \\\"using ITensors\\\" -i \" where of course you can use the command name you like when defining the alias. Now running commands like  julia_itensors code.jl  or  julia_itensors  to start an interactive session will have the ITensor system image pre-loaded and you will notice significantly faster startup times. The arguments  -e \\\"using ITensors\\\" -i  make it so that running  julia_itensors  also loads the ITensor library as soon as Julia starts up, so that you don't have to type  using ITensors  every time."},{"id":239,"pagetitle":"Running ITensor and Julia Codes","title":"Using a Compiled Sysimage in Jupyter or VS Code","ref":"/ITensorDocs/ITensors/stable/getting_started/#Using-a-Compiled-Sysimage-in-Jupyter-or-VS-Code","content":" Using a Compiled Sysimage in Jupyter or VS Code If you have compiled a sysimage for ITensor as shown above, you can use it in Jupyter by running the following code: using IJulia\ninstallkernel(\"julia_ITensors\",\"--sysimage=~/.julia/sysimages/sys_itensors.so\") in the Julia REPL (Julia console). To load the ITensor sysimage in VS Code, you can add \"--sysimage ~/.julia/sysimages/sys_itensors.so\" as an argument under the  julia.additionalArgs  setting in your Settings.json file. For more information on the above, see the following  Julia Discourse post ."},{"id":242,"pagetitle":"DMRG","title":"DMRG","ref":"/ITensorDocs/ITensorMPS/stable/#DMRG","content":" DMRG"},{"id":243,"pagetitle":"DMRG","title":"ITensorMPS.dmrg","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.dmrg","content":" ITensorMPS.dmrg  —  Function dmrg(H::MPO, psi0::MPS; kwargs...)\ndmrg(H::MPO, psi0::MPS, sweeps::Sweeps; kwargs...) Use the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix  H , represented as a matrix product operator (MPO). dmrg(Hs::Vector{MPO}, psi0::MPS; kwargs...)\ndmrg(Hs::Vector{MPO}, psi0::MPS, sweeps::Sweeps; kwargs...) Use the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix  H . This version of  dmrg  accepts a representation of H as a Vector of MPOs,  Hs = [H1, H2, H3, ...]  such that  H  is defined  as H = H1 + H2 + H3 + ...  Note that this sum of MPOs is not actually computed; rather the set of MPOs  [H1,H2,H3,..]  is efficiently looped over at each step of the DMRG algorithm when optimizing the MPS. dmrg(H::MPO, Ms::Vector{MPS}, psi0::MPS; weight=1.0, kwargs...)\ndmrg(H::MPO, Ms::Vector{MPS}, psi0::MPS, sweeps::Sweeps; weight=1.0, kwargs...) Use the density matrix renormalization group (DMRG) algorithm to optimize a matrix product state (MPS) such that it is the eigenvector of lowest eigenvalue of a Hermitian matrix  H , subject to the constraint that the MPS is orthogonal to each of the MPS provided in the Vector  Ms . The orthogonality constraint is approximately enforced by adding to  H  terms of the form  w|M1><M1| + w|M2><M2| + ...  where  Ms=[M1, M2, ...]  and  w  is the \"weight\" parameter, which can be adjusted through the optional  weight  keyword argument. Note dmrg  will report the energy of the operator  H + w|M1><M1| + w|M2><M2| + ... , not the operator  H . If you want the expectation value of the MPS eigenstate with respect to just  H , you can compute it yourself with an observer or after DMRG is run with  inner(psi', H, psi) . The MPS  psi0  is used to initialize the MPS to be optimized. The number of sweeps of thd DMRG algorithm is controlled by passing the  nsweeps  keyword argument. The keyword arguments  maxdim ,  cutoff ,  noise , and  mindim  can also be passed to control the cost versus accuracy of the algorithm - see below for details. Alternatively the number of sweeps and accuracy parameters can be passed through a  Sweeps  object, though this interface is no longer preferred. Returns: energy::Number  - eigenvalue of the optimized MPS psi::MPS  - optimized MPS Keyword arguments: nsweeps::Int  - number of \"sweeps\" of DMRG to perform Optional keyword arguments: maxdim  - integer or array of integers specifying the maximum size  allowed for the bond dimension or rank of the MPS being optimized. cutoff  - float or array of floats specifying the truncation error cutoff  or threshold to use for truncating the bond dimension or rank of the MPS. eigsolve_krylovdim::Int = 3  - maximum dimension of Krylov space used to  locally solve the eigenvalue problem. Try setting to a higher value if  convergence is slow or the Hamiltonian is close to a critical point.  [krylovkit] eigsolve_tol::Number = 1e-14  - Krylov eigensolver tolerance.  [krylovkit] eigsolve_maxiter::Int = 1  - number of times the Krylov subspace can be  rebuilt.  [krylovkit] eigsolve_verbosity::Int = 0  - verbosity level of the Krylov solver.  Warning: enabling this will lead to a lot of outputs to the terminal.  [krylovkit] ishermitian=true  - boolean specifying if dmrg should assume the MPO (or more  general linear operator) represents a Hermitian matrix.  [krylovkit] noise  - float or array of floats specifying strength of the \"noise term\"  to use to aid convergence. mindim  - integer or array of integers specifying the minimum size of the  bond dimension or rank, if possible. outputlevel::Int = 1  - larger outputlevel values make DMRG print more  information and 0 means no output. observer  - object implementing the  Observer  interface  which can perform measurements and stop DMRG early. write_when_maxdim_exceeds::Int  - when the allowed maxdim exceeds this  value, begin saving tensors to disk to free RAM memory in large calculations write_path::String = tempdir()  - path to use to save files to disk  (to save RAM) when maxdim exceeds the  write_when_maxdim_exceeds  option, if set source krylovkit The  dmrg  function in  ITensorMPS.jl  currently uses the  eigsolve  function in  KrylovKit.jl  as the internal the eigensolver. See the  KrylovKit.jl  documention on the  eigsolve  function for more details:  KrylovKit.eigsolve ."},{"id":246,"pagetitle":"DMRGObserver","title":"DMRGObserver","ref":"/ITensorDocs/ITensorMPS/stable/#DMRGObserver","content":" DMRGObserver A DMRGObserver is a type of  observer  which offers certain useful, general purpose capabilities for DMRG calculations such as measuring custom local observables at each step and stopping DMRG early if certain energy convergence conditions are met."},{"id":247,"pagetitle":"DMRGObserver","title":"Sample Usage","ref":"/ITensorDocs/ITensorMPS/stable/#Sample-Usage","content":" Sample Usage In the following example, we have already made a Hamiltonian MPO  H  and initial MPS  psi0  for a system of spins whose sites have an associated \"Sz\" operator defined. We construct a  DMRGObserver  which measures \"Sz\" on each site at each step of DMRG, and also stops the calculation early if the energy no longer changes to a relative precision of 1E-7. Sz_observer = DMRGObserver([\"Sz\"],sites,energy_tol=1E-7)\n\nenergy, psi = dmrg(H,psi0,sweeps,observer=Sz_observer)\n\nfor (sw,Szs) in enumerate(measurements(Sz_observer)[\"Sz\"])\n  println(\"Total Sz after sweep $sw = \", sum(Szs)/N)\nend"},{"id":248,"pagetitle":"DMRGObserver","title":"Constructors","ref":"/ITensorDocs/ITensorMPS/stable/#Constructors","content":" Constructors"},{"id":249,"pagetitle":"DMRGObserver","title":"ITensorMPS.DMRGObserver","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.DMRGObserver-Tuple{}","content":" ITensorMPS.DMRGObserver  —  Method DMRGObserver(;energy_tol=0.0,\n              minsweeps=2,\n              energy_type=Float64) Construct a DMRGObserver by providing the energy tolerance used for early stopping, and minimum number of sweeps that must be done. Optional keyword arguments: energy_tol: if the energy from one sweep to the next no longer changes by more than this amount, stop after the current sweep minsweeps: do at least this many sweeps energy_type: type to use when storing energies at each step source"},{"id":250,"pagetitle":"DMRGObserver","title":"ITensorMPS.DMRGObserver","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.DMRGObserver-Tuple{Vector{String}, Vector{<:Index}}","content":" ITensorMPS.DMRGObserver  —  Method DMRGObserver(ops::Vector{String},\n             sites::Vector{<:Index};\n             energy_tol=0.0,\n             minsweeps=2,\n             energy_type=Float64) Construct a DMRGObserver, provide an array of  ops  of operator names which are strings recognized by the  op  function. Each of these operators will be measured on every site during every step of DMRG and the results recorded inside the DMRGOberver for later analysis. The array  sites  is the basis of sites used to define the MPS and MPO for the DMRG calculation. Optionally, one can provide an energy tolerance used for early stopping, and minimum number of sweeps that must be done. Optional keyword arguments: energy_tol: if the energy from one sweep to the next no longer changes by more than this amount, stop after the current sweep minsweeps: do at least this many sweeps energy_type: type to use when storing energies at each step source"},{"id":251,"pagetitle":"DMRGObserver","title":"Methods","ref":"/ITensorDocs/ITensorMPS/stable/#Methods","content":" Methods"},{"id":252,"pagetitle":"DMRGObserver","title":"ITensorMPS.measurements","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.measurements-Tuple{DMRGObserver}","content":" ITensorMPS.measurements  —  Method measurements(o::DMRGObserver) After using a DMRGObserver object  o  within a DMRG calculation, retrieve a dictionary of measurement results, with the keys being operator names and values being DMRGMeasurement objects. source"},{"id":253,"pagetitle":"DMRGObserver","title":"ITensorMPS.DMRGMeasurement","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.DMRGMeasurement","content":" ITensorMPS.DMRGMeasurement  —  Type A DMRGMeasurement object is an alias for  Vector{Vector{Float64}} , in other words an array of arrays of real numbers. Given a DMRGMeasurement  M ,the result for the measurement on sweep  n  and site  i  as  M[n][i] . source"},{"id":254,"pagetitle":"DMRGObserver","title":"ITensorMPS.energies","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.energies-Tuple{DMRGObserver}","content":" ITensorMPS.energies  —  Method energies(o::DMRGObserver) After using a DMRGObserver object  o  within a DMRG calculation, retrieve an array of the energy after each sweep. source"},{"id":257,"pagetitle":"HDF5 File Formats","title":"MPS","ref":"/ITensorDocs/ITensorMPS/stable/#mps_hdf5","content":" MPS HDF5 file format for  ITensorMPS.MPS Attributes: \"version\" = 1 \"type\" = \"MPS\" Datasets and Subgroups: \"length\" [integer] = number of tensors of the MPS \"rlim\" [integer] = right orthogonality limit \"llim\" [integer] = left orthogonality limit \"MPS[n]\" [group,ITensor] = each of these groups, where n=1,...,length, stores the nth ITensor of the MPS"},{"id":258,"pagetitle":"HDF5 File Formats","title":"MPO","ref":"/ITensorDocs/ITensorMPS/stable/#mpo_hdf5","content":" MPO HDF5 file format for  ITensorMPS.MPO Attributes: \"version\" = 1 \"type\" = \"MPO\" Datasets and Subgroups: \"length\" [integer] = number of tensors of the MPO \"rlim\" [integer] = right orthogonality limit \"llim\" [integer] = left orthogonality limit \"MPO[n]\" [group,ITensor] = each of these groups, where n=1,...,length, stores the nth ITensor of the MPO"},{"id":261,"pagetitle":"SiteTypes Included with ITensor","title":"SiteTypes Included with ITensor","ref":"/ITensorDocs/ITensorMPS/stable/#SiteTypes-Included-with-ITensor","content":" SiteTypes Included with ITensor"},{"id":262,"pagetitle":"SiteTypes Included with ITensor","title":"\"S=1/2\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"S1/2\"-SiteType","content":" \"S=1/2\" SiteType Site indices with the \"S=1/2\" site type represent  $S=1/2$  spins with the states  $|\\!\\uparrow\\rangle$ ,  $|\\!\\downarrow\\rangle$ . Making a single \"S=1/2\" site or collection of N \"S=1/2\" sites s = siteind(\"S=1/2\")\nsites = siteinds(\"S=1/2\",N) Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces: conserve_qns  (default: false): conserve total  $S^z$ conserve_sz  (default: conserve_qns): conserve total  $S^z$ conserve_szparity  (default: false): conserve total  $S^z$  modulo two qnname_sz  (default: \"Sz\"): name of total  $S^z$  QN qnname_szparity  (default: \"SzParity\"): name of total  $S^z$  modulo two QN For example: sites = siteinds(\"S=1/2\",N; conserve_szparity=true, qnname_szparity=\"SzP\") Operators associated with \"S=1/2\" sites can be made using the  op  function, for example Sz = op(\"Sz\",s)\nSz4 = op(\"Sz\",sites[4]) Available operators are exactly the same as those for the \"Qubit\" site type. Please see the list of \"Qubit\" operators below."},{"id":263,"pagetitle":"SiteTypes Included with ITensor","title":"\"Qubit\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"Qubit\"-SiteType","content":" \"Qubit\" SiteType Site indices with the \"Qubit\" site type represent qubits with the states  $|0\\rangle$ ,  $|1\\rangle$ . Making a single \"Qubit\" site or collection of N \"Qubit\" sites s = siteind(\"Qubit\")\nsites = siteinds(\"Qubit\",N) Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces: conserve_qns  (default: false): conserve total qubit parity conserve_parity  (default: conserve_qns): conserve total qubit parity conserve_number  (default: false): conserve total qubit number qnname_parity  (default: \"Parity\"): name of total qubit parity QN qnname_number  (default: \"Number\"): name of total qubit number QN For example: sites = siteinds(\"Qubit\",N; conserve_parity=true)"},{"id":264,"pagetitle":"SiteTypes Included with ITensor","title":"\"Qubit\" and \"S=1/2\" States","ref":"/ITensorDocs/ITensorMPS/stable/#\"Qubit\"-and-\"S1/2\"-States","content":" \"Qubit\" and \"S=1/2\" States The available state names for \"Qubit\" sites are: \"0\"  (aliases:  \"Z+\" ,  \"Zp\" ,  \"Up\" ,  \"↑\" ) Qubit in the 0 state \"1\"  (aliases:  \"Z-\" ,  \"Zm\" ,  \"Dn\" ,  \"↓\" ) Qubit in the 1 state \"+\"  (aliases:  \"X+\" ,  \"Xp\" ) Qubit in the  $|+\\rangle$  state (+1 eigenvector of  $\\sigma_x$ ) \"+\"  (aliases:  \"X-\" ,  \"Xm\" ) Qubit in the  $|-\\rangle$  state (-1 eigenvector of  $\\sigma_x$ ) \"i\"  (aliases:  \"Y+\" ,  \"Yp\" ) Qubit in the  $|i\\rangle$  state (+1 eigenvector of  $\\sigma_y$ ) \"-i\"  (aliases:  \"Y-\" ,  \"Ym\" ) Qubit in the  $|-i\\rangle$  state (+1 eigenvector of  $\\sigma_y$ )"},{"id":265,"pagetitle":"SiteTypes Included with ITensor","title":"\"Qubit\" and \"S=1/2\" Operators","ref":"/ITensorDocs/ITensorMPS/stable/#\"Qubit\"-and-\"S1/2\"-Operators","content":" \"Qubit\" and \"S=1/2\" Operators Operators or gates associated with \"Qubit\" sites can be made using the  op  function, for example H = op(\"H\",s)\nH3 = op(\"H\",sites[3]) Single-qubit operators: \"X\"  (aliases:  \"σx\" ,  \"σ1\" ) Pauli X operator \"Y\"  (aliases:  \"σy\" ,  \"σ2\" ) Pauli Y operator \"iY\"  (aliases:  \"iσy\" ,  \"iσ2\" ) Pauli Y operator times i \"Z\"  (aliases:  \"σz\" ,  \"σ3\" ) Pauli Z operator \"√NOT\"  (aliases:  \"X\" ) \"H\"  Hadamard gate \"Phase\"  (takes optional argument: ϕ=π/2) (aliases:  \"P\" ,  \"S\" ) \"π/8\"  (aliases:  \"T\" ) \"Rx\"  (takes argument: θ) Rotation around x axis \"Ry\"  (takes argument: θ) Rotation around y axis \"Rz\"  (takes argument: θ) Rotation around z axis \"Rn\"  (takes arguments: θ, ϕ, λ) (aliases:  \"Rn̂\" ) Rotation about axis n=(θ, ϕ, λ) \"Proj0\"  (aliases:  \"ProjUp\" ,  \"projUp\" ) Operator  $|0\\rangle\\langle 0|$ \"Proj1\"  (aliases:  \"ProjDn\" ,  \"projDn\" ) Operator  $|1\\rangle\\langle 1|$ Spin operators: \"Sz\"  (aliases:  \"Sᶻ\" ) Spin z operator  $S^z = \\frac{1}{2} \\sigma_z$ \"S+\"  (alises:  \"S⁺\" ,  \"Splus\" ) Raising operator  $S^+ = S^x + iS^y$ \"S-\"  (aliases:  \"S⁻\" ,  \"Sminus\" ) Lowering operator  $S^- = S^x - iS^y$ \"Sx\"  (alises:  \"Sˣ\" ) Spin x operator  $S^x = \\frac{1}{2} \\sigma_x$ \"iSy\"  (aliases:  \"iSʸ\" ) i times spin y operator  $iS^y = \\frac{i}{2} \\sigma_y$ \"Sy\"  (aliases:  \"Sʸ\" ) Spin y operator  $S^y = \\frac{1}{2} \\sigma_y$ \"S2\"  (aliases: \"S²\"`) Square of spin vector operator  $S^2=\\vec{S}\\cdot\\vec{S}=\\frac{3}{4} I$ \"ProjUp\"  (aliases:  \"projUp\" ,  \"Proj0\" ) Operator  $|\\!↑\\rangle\\langle ↑\\!|$ \"ProjDn\"  (aliases:  \"projDn\" ,  \"Proj1\" ) Operator  $|\\!↓\\rangle\\langle ↓\\!|$ Two-qubit gates: \"CNOT\"  (aliases:  \"CX\" ) Controlled NOT gate \"CY\"  Controlled Y gate \"CZ\"  Controlled Z gate \"CPHASE\"  (aliases:  \"Cphase\" ) Controlled Phase gate \"CRx\"  (aliases:  \"CRX\" ) (takes arguments: θ) \"CRy\"  (aliases:  \"CRY\" ) (takes arguments: θ) \"CRz\"  (aliases:  \"CRZ\" ) (takes arguments: θ) \"CRn\"  (aliases:  \"CRn̂\" ) (takes arguments: θ, ϕ, λ) \"SWAP\"  (aliases:  \"Swap\" ) \"√SWAP\"  (aliases:  \"√Swap\" ) \"iSWAP\"  (aliases:  \"iSwap\" ) \"√iSWAP\"  (aliases:  \"√iSwap\" ) \"Rxx\"  (aliases:  \"RXX\" ) (takes arguments: ϕ) Ising (XX) coupling gate \"Ryy\"  (aliases:  \"RYY\" ) (takes arguments: ϕ) Ising (YY) coupling gate \"Rzz\"  (aliases:  \"RZZ\" ) (takes arguments: ϕ) Ising (ZZ) coupling gate Three-qubit gates: \"Toffoli\"  (aliases  \"CCNOT\" ,  \"CCX\" ,  \"TOFF\" ) \"Fredkin\"  (aliases  \"CSWAP\" ,  \"CSwap\" ,  \"CS\" ) Four-qubit gates: \"CCCNOT\""},{"id":266,"pagetitle":"SiteTypes Included with ITensor","title":"\"S=1\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"S1\"-SiteType","content":" \"S=1\" SiteType Site indices with the \"S=1\" site type represent  $S=1$  spins with the states  $|\\!\\uparrow\\rangle$ ,  $|0\\rangle$ ,  $|\\!\\downarrow\\rangle$ . Making a single \"S=1\" site or collection of N \"S=1\" sites s = siteind(\"S=1\")\nsites = siteinds(\"S=1\",N) Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces: conserve_qns  (default: false): conserve total  $S^z$ conserve_sz  (default: conserve_qns): conserve total  $S^z$ qnname_sz  (default: \"Sz\"): name of total  $S^z$  QN For example: sites = siteinds(\"S=1\",N; conserve_sz=true, qnname_sz=\"TotalSz\")"},{"id":267,"pagetitle":"SiteTypes Included with ITensor","title":"\"S=1\" States","ref":"/ITensorDocs/ITensorMPS/stable/#\"S1\"-States","content":" \"S=1\" States The available state names for \"S=1\" sites are: \"Up\"  (aliases:  \"Z+\" ,  \"↑\" ) spin in the up state \"Z0\"  (aliases:  \"0\" ) spin in the Sz=0 state \"Dn\"  (aliases:  \"Z-\" ,  \"↓\" ) spin in the down state"},{"id":268,"pagetitle":"SiteTypes Included with ITensor","title":"\"S=1\" Operators","ref":"/ITensorDocs/ITensorMPS/stable/#\"S1\"-Operators","content":" \"S=1\" Operators Operators associated with \"S=1\" sites can be made using the  op  function, for example Sz = op(\"Sz\",s)\nSz4 = op(\"Sz\",sites[4]) Spin operators: \"Sz\"  (aliases:  \"Sᶻ\" ) \"Sz2\"  Square of  S^z  operator \"S+\"  (alises:  \"S⁺\" ,  \"Splus\" ) \"S-\"  (aliases:  \"S⁻\" ,  \"Sminus\" ) \"Sx\"  (alises:  \"Sˣ\" ) \"Sx2\"  Square of  S^x  operator \"iSy\"  (aliases:  \"iSʸ\" ) \"Sy\"  (aliases:  \"Sʸ\" ) \"Sy2\"  Square of  S^y  operator \"S2\"  (aliases: \"S²\"`)"},{"id":269,"pagetitle":"SiteTypes Included with ITensor","title":"\"Boson\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"Boson\"-SiteType","content":" \"Boson\" SiteType The \"Boson\" site type is an alias for the \"Qudit\" site type. Please see more information about \"Qudit\" below:"},{"id":270,"pagetitle":"SiteTypes Included with ITensor","title":"\"Qudit\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"Qudit\"-SiteType","content":" \"Qudit\" SiteType Making a single \"Qudit\" site or collection of N \"Qudit\" sites s = siteind(\"Qudit\")\nsites = siteinds(\"Qudit\",N) Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces: dim  (default: 2): dimension of the index (number of qudit or boson values) conserve_qns  (default: false): conserve total qudit or boson number conserve_number  (default: conserve_qns): conserve total qudit or boson number qnname_number  (default: \"Number\"): name of total qudit or boson number QN For example: sites = siteinds(\"Qudit\",N; conserve_number=true)"},{"id":271,"pagetitle":"SiteTypes Included with ITensor","title":"\"Qudit\" and \"Boson\" Operators","ref":"/ITensorDocs/ITensorMPS/stable/#\"Qudit\"-and-\"Boson\"-Operators","content":" \"Qudit\" and \"Boson\" Operators Operators associated with \"Qudit\" sites can be made using the  op  function, for example A = op(\"A\",s)\nA4 = op(\"A\",sites[4]) Single-qudit operators: \"A\"  (aliases:  \"a\" ) \"Adag\"  (aliases:  \"adag\" ,  \"a†\" ) \"N\"  (aliases:  \"n\" ) Two-qudit operators: \"ab\" \"a†b\" \"ab†\" \"a†b†\""},{"id":272,"pagetitle":"SiteTypes Included with ITensor","title":"\"Fermion\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"Fermion\"-SiteType","content":" \"Fermion\" SiteType Site indices with the \"Fermion\" SiteType represent spinless fermion sites with the states  $|0\\rangle$ ,  $|1\\rangle$ , corresponding to zero fermions or one fermion. Making a single \"Fermion\" site or collection of N \"Fermion\" sites s = siteind(\"Fermion\")\nsites = siteinds(\"Fermion\",N) Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces: conserve_qns  (default: false): conserve total number of fermions conserve_nf  (default: conserve_qns): conserve total number of fermions conserve_nfparity  (default: conserve_qns): conserve total fermion number parity qnname_nf  (default: \"Nf\"): name of total fermion number QN qnname_nfparity  (default: \"NfParity\"): name of total fermion number parity QN For example: sites = siteinds(\"Fermion\",N; conserve_nfparity=true)"},{"id":273,"pagetitle":"SiteTypes Included with ITensor","title":"\"Fermion\" States","ref":"/ITensorDocs/ITensorMPS/stable/#\"Fermion\"-States","content":" \"Fermion\" States The available state names for \"Fermion\" sites are: \"0\"  (aliases:  \"Emp\" ) unoccupied fermion site \"1\"  (aliases:  \"Occ\" ) occupied fermion site"},{"id":274,"pagetitle":"SiteTypes Included with ITensor","title":"\"Fermion\" Operators","ref":"/ITensorDocs/ITensorMPS/stable/#\"Fermion\"-Operators","content":" \"Fermion\" Operators Operators associated with \"Fermion\" sites can be made using the  op  function, for example C = op(\"C\",s)\nC4 = op(\"C\",sites[4]) Single-fermion operators: \"N\"  (aliases:  \"n\" ) Density operator \"C\"  (aliases:  \"c\" ) Fermion annihilation operator \"Cdag\"  (aliases:  \"cdag\" ,  \"c†\" ) Fermion creation operator \"F\"  Jordan-Wigner string operator"},{"id":275,"pagetitle":"SiteTypes Included with ITensor","title":"\"Electron\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"Electron\"-SiteType","content":" \"Electron\" SiteType The states of site indices with the \"Electron\" SiteType correspond to  $|0\\rangle$ ,  $|\\!\\uparrow\\rangle$ ,  $|\\!\\downarrow\\rangle$ ,  $|\\!\\uparrow\\downarrow\\rangle$ . Making a single \"Electron\" site or collection of N \"Electron\" sites s = siteind(\"Electron\")\nsites = siteinds(\"Electron\",N) Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces: conserve_qns  (default: false): conserve total number of electrons conserve_sz  (default: conserve_qns): conserve total  $S^z$ conserve_nf  (default: conserve_qns): conserve total number of electrons conserve_nfparity  (default: conserve_qns): conserve total electron number parity qnname_sz  (default: \"Sz\"): name of total  $S^z$  QN qnname_nf  (default: \"Nf\"): name of total electron number QN qnname_nfparity  (default: \"NfParity\"): name of total electron number parity QN For example: sites = siteinds(\"Electron\",N; conserve_nfparity=true)"},{"id":276,"pagetitle":"SiteTypes Included with ITensor","title":"\"Electron\" States","ref":"/ITensorDocs/ITensorMPS/stable/#\"Electron\"-States","content":" \"Electron\" States The available state names for \"Electron\" sites are: \"Emp\"  (aliases:  \"0\" ) unoccupied electron site \"Up\"  (aliases:  \"↑\" ) electron site occupied with one up electron \"Dn\"  (aliases:  \"↓\" ) electron site occupied with one down electron \"UpDn\"  (aliases:  \"↑↓\" ) electron site occupied with two electrons (one up, one down)"},{"id":277,"pagetitle":"SiteTypes Included with ITensor","title":"\"Electron\" Operators","ref":"/ITensorDocs/ITensorMPS/stable/#\"Electron\"-Operators","content":" \"Electron\" Operators Operators associated with \"Electron\" sites can be made using the  op  function, for example Cup = op(\"Cup\",s)\nCup4 = op(\"Cup\",sites[4]) Single-fermion operators: \"Ntot\"  (aliases:  \"ntot\" ) Total density operator \"Nup\"  (aliases:  \"n↑\" ) Up density operator \"Ndn\"  (aliases:  \"n↓\" ) Down density operator \"Cup\"  (aliases:  \"c↑\" ) Up-spin annihilation operator \"Cdn\"  (aliases:  \"c↓\" ) Down-spin annihilation operator \"Cdagup\"  (aliases:  \"c†↑\" ) Up-spin creation operator \"Cdagdn\"  (aliases:  \"c†↓\" ) Down-spin creation operator \"Sz\"  (aliases:  \"Sᶻ\" ) \"Sx\"  (aliases:  \"Sˣ\" ) \"S+\"  (aliases:  \"Sp\" ,  \"S⁺\" , \"Splus\" ) \"S-\"  (aliases:  \"Sm\" ,  \"S⁻\" ,  \"Sminus\" ) \"F\"  Jordan-Wigner string operator \"Fup\"  (aliases:  \"F↑\" ) Up-spin Jordan-Wigner string operator \"Fdn\"  (aliases:  \"F↓\" ) Down-spin Jordan-Wigner string operator Non-fermionic single particle operators (these do not have Jordan-Wigner string attached, so will commute within systems such as OpSum or the  apply  function): \"Aup\"  (aliases:  \"a↑\" ) Up-spin annihilation operator \"Adn\"  (aliases:  \"a↓\" ) Down-spin annihilation operator \"Adagup\"  (aliases:  \"a†↑\" ) Up-spin creation operator \"Adagdn\"  (aliases:  \"a†↓\" ) Down-spin creation operator"},{"id":278,"pagetitle":"SiteTypes Included with ITensor","title":"\"tJ\" SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#\"tJ\"-SiteType","content":" \"tJ\" SiteType \"tJ\" sites are similar to electron sites, but cannot be doubly occupied The states of site indices with the \"tJ\" SiteType correspond to  $|0\\rangle$ ,  $|\\!\\uparrow\\rangle$ ,  $|\\!\\downarrow\\rangle$ . Making a single \"tJ\" site or collection of N \"tJ\" sites s = siteind(\"tJ\")\nsites = siteinds(\"tJ\",N) Available keyword arguments for enabling and customizing quantum numbers (QN) subspaces: conserve_qns  (default: false): conserve total number of fermions conserve_nf  (default: conserve_qns): conserve total number of fermions conserve_nfparity  (default: conserve_qns): conserve total fermion number parity qnname_nf  (default: \"Nf\"): name of total fermion number QN qnname_nfparity  (default: \"NfParity\"): name of total fermion number parity QN For example: sites = siteinds(\"tJ\",N; conserve_nfparity=true)"},{"id":279,"pagetitle":"SiteTypes Included with ITensor","title":"\"tJ\" States","ref":"/ITensorDocs/ITensorMPS/stable/#\"tJ\"-States","content":" \"tJ\" States The available state names for \"tJ\" sites are: \"Emp\"  (aliases:  \"0\" ) unoccupied site \"Up\"  (aliases:  \"↑\" ) site occupied with one up electron \"Dn\"  (aliases:  \"↓\" ) site occupied with one down electron"},{"id":280,"pagetitle":"SiteTypes Included with ITensor","title":"\"tJ\" Operators","ref":"/ITensorDocs/ITensorMPS/stable/#\"tJ\"-Operators","content":" \"tJ\" Operators Operators associated with \"tJ\" sites can be made using the  op  function, for example Cup = op(\"Cup\",s)\nCup4 = op(\"Cup\",sites[4]) Single-fermion operators: \"Ntot\"  (aliases:  \"ntot\" ) Total density operator \"Nup\"  (aliases:  \"n↑\" ) Up density operator \"Ndn\"  (aliases:  \"n↓\" ) Down density operator \"Cup\"  (aliases:  \"c↑\" ) Up-spin annihilation operator \"Cdn\"  (aliases:  \"c↓\" ) Down-spin annihilation operator \"Cdagup\"  (aliases:  \"c†↑\" ) Up-spin creation operator \"Cdagdn\"  (aliases:  \"c†↓\" ) Down-spin creation operator \"Sz\"  (aliases:  \"Sᶻ\" ) \"Sx\"  (aliases:  \"Sˣ\" ) \"S+\"  (aliases:  \"Sp\" ,  \"S⁺\" , \"Splus\" ) \"S-\"  (aliases:  \"Sm\" ,  \"S⁻\" ,  \"Sminus\" ) \"F\"  Jordan-Wigner string operator \"Fup\"  (aliases:  \"F↑\" ) Up-spin Jordan-Wigner string operator \"Fdn\"  (aliases:  \"F↓\" ) Down-spin Jordan-Wigner string operator Non-fermionic single particle operators (these do not have Jordan-Wigner string attached, so will commute within systems such as OpSum or the  apply  function): \"Aup\"  (aliases:  \"a↑\" ) Up-spin annihilation operator \"Adn\"  (aliases:  \"a↓\" ) Down-spin annihilation operator \"Adagup\"  (aliases:  \"a†↑\" ) Up-spin creation operator \"Adagdn\"  (aliases:  \"a†↓\" ) Down-spin creation operator"},{"id":283,"pagetitle":"MPS and MPO","title":"MPS and MPO","ref":"/ITensorDocs/ITensorMPS/stable/#MPS-and-MPO","content":" MPS and MPO"},{"id":284,"pagetitle":"MPS and MPO","title":"Types","ref":"/ITensorDocs/ITensorMPS/stable/#Types","content":" Types"},{"id":285,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPS","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPS","content":" ITensorMPS.MPS  —  Type MPS A finite size matrix product state type. Keeps track of the orthogonality center. source"},{"id":286,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPO","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPO","content":" ITensorMPS.MPO  —  Type MPO A finite size matrix product operator type. Keeps track of the orthogonality center. source"},{"id":287,"pagetitle":"MPS and MPO","title":"MPS Constructors","ref":"/ITensorDocs/ITensorMPS/stable/#MPS-Constructors","content":" MPS Constructors"},{"id":288,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPS","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPS-Tuple{Int64}","content":" ITensorMPS.MPS  —  Method MPS(N::Int) Construct an MPS with N sites with default constructed ITensors. source"},{"id":289,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPS","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPS-Tuple{Type{<:Number}, Vector{<:Index}}","content":" ITensorMPS.MPS  —  Method MPS([::Type{ElT} = Float64, ]sites; linkdims=1) Construct an MPS filled with Empty ITensors of type  ElT  from a collection of indices. Optionally specify the link dimension with the keyword argument  linkdims , which by default is 1. In the future we may generalize  linkdims  to allow specifying each individual link dimension as a vector, and additionally allow specifying quantum numbers. source"},{"id":290,"pagetitle":"MPS and MPO","title":"ITensorMPS.random_mps","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.random_mps-Tuple{Vector{<:Index}}","content":" ITensorMPS.random_mps  —  Method random_mps(sites::Vector{<:Index}; linkdims=1)\nrandom_mps(eltype::Type{<:Number}, sites::Vector{<:Index}; linkdims=1) Construct a random MPS with link dimension  linkdims  which by default has element type  Float64 . linkdims  can also accept a  Vector{Int}  with  length(linkdims) == length(sites) - 1  for constructing an MPS with non-uniform bond dimension. source"},{"id":291,"pagetitle":"MPS and MPO","title":"ITensorMPS.random_mps","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.random_mps-Tuple{Type{<:Number}, Vector{<:Index}}","content":" ITensorMPS.random_mps  —  Method random_mps(eltype::Type{<:Number}, sites::Vector{<:Index}; linkdims=1) Construct a random MPS with link dimension  linkdims  of type  eltype . linkdims  can also accept a  Vector{Int}  with  length(linkdims) == length(sites) - 1  for constructing an MPS with non-uniform bond dimension. source"},{"id":292,"pagetitle":"MPS and MPO","title":"ITensorMPS.random_mps","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.random_mps-Tuple{Vector{<:Index}, Any}","content":" ITensorMPS.random_mps  —  Method random_mps(sites::Vector{<:Index}, state; linkdims=1) Construct a real, random MPS with link dimension  linkdims , made by randomizing an initial product state specified by  state . This version of  random_mps  is necessary when creating QN-conserving random MPS (consisting of QNITensors). The initial  state  array provided determines the total QN of the resulting random MPS. source"},{"id":293,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPS","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPS-Tuple{Vector{<:Index}, Any}","content":" ITensorMPS.MPS  —  Method MPS(sites::Vector{<:Index},states) Construct a product state MPS having site indices  sites , and which corresponds to the initial state given by the array  states . The  states  array may consist of either an array of integers or strings, as recognized by the  state  function defined for the relevant Index tag type. Examples N = 10\nsites = siteinds(\"S=1/2\", N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\npsi = MPS(sites, states) source"},{"id":294,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPS","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPS-Tuple{Type{<:Number}, Vector{<:Index}, Any}","content":" ITensorMPS.MPS  —  Method MPS(::Type{T},\n    sites::Vector{<:Index},\n    states::Union{Vector{String},\n                  Vector{Int},\n                  String,\n                  Int}) Construct a product state MPS of element type  T , having site indices  sites , and which corresponds to the initial state given by the array  states . The input  states  may be an array of strings or an array of ints recognized by the  state  function defined for the relevant Index tag type. In addition, a single string or int can be input to create a uniform state. Examples N = 10\nsites = siteinds(\"S=1/2\", N)\nstates = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\npsi = MPS(ComplexF64, sites, states)\nphi = MPS(sites, \"Up\") source"},{"id":295,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPS","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPS-Tuple{Vector{<:Pair{<:Index}}}","content":" ITensorMPS.MPS  —  Method MPS(ivals::Vector{<:Pair{<:Index}}) Construct a product state MPS with element type  Float64  and nonzero values determined from the input IndexVals. source"},{"id":296,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPS","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPS-Tuple{Type{<:Number}, Vector{<:Pair{<:Index}}}","content":" ITensorMPS.MPS  —  Method MPS(::Type{T<:Number}, ivals::Vector{<:Pair{<:Index}}) Construct a product state MPS with element type  T  and nonzero values determined from the input IndexVals. source"},{"id":297,"pagetitle":"MPS and MPO","title":"MPO Constructors","ref":"/ITensorDocs/ITensorMPS/stable/#MPO-Constructors","content":" MPO Constructors"},{"id":298,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPO","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPO-Tuple{Int64}","content":" ITensorMPS.MPO  —  Method MPO(N::Int) Make an MPO of length  N  filled with default ITensors. source"},{"id":299,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPO","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPO-Tuple{Type{<:Number}, Vector{<:Index}, Vector{String}}","content":" ITensorMPS.MPO  —  Method MPO([::Type{ElT} = Float64}, ]sites, ops::Vector{String}) Make an MPO with pairs of sites  s[i]  and  s[i]'  and operators  ops  on each site. source"},{"id":300,"pagetitle":"MPS and MPO","title":"ITensorMPS.MPO","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPO-Tuple{Type{<:Number}, Vector{<:Index}, String}","content":" ITensorMPS.MPO  —  Method MPO([::Type{ElT} = Float64, ]sites, op::String) Make an MPO with pairs of sites  s[i]  and  s[i]'  and operator  op  on every site. source"},{"id":301,"pagetitle":"MPS and MPO","title":"Copying behavior","ref":"/ITensorDocs/ITensorMPS/stable/#Copying-behavior","content":" Copying behavior"},{"id":302,"pagetitle":"MPS and MPO","title":"Base.copy","ref":"/ITensorDocs/ITensorMPS/stable/#Base.copy-Tuple{AbstractMPS}","content":" Base.copy  —  Method copy(::MPS)\ncopy(::MPO) Make a shallow copy of an MPS or MPO. By shallow copy, it means that a new MPS/MPO is returned, but the data of the tensors are still shared between the returned MPS/MPO and the original MPS/MPO. Therefore, replacing an entire tensor of the returned MPS/MPO will not modify the input MPS/MPO, but modifying the data of the returned MPS/MPO will modify the input MPS/MPO. Use  deepcopy  for an alternative that copies the ITensors as well. Examples julia> using ITensors, ITensorMPS\n\njulia> s = siteinds(\"S=1/2\", 3);\n\njulia> M1 = random_mps(s; linkdims=3);\n\njulia> norm(M1)\n0.9999999999999999\n\njulia> M2 = copy(M1);\n\njulia> M2[1] *= 2;\n\njulia> norm(M1)\n0.9999999999999999\n\njulia> norm(M2)\n1.9999999999999998\n\njulia> M3 = copy(M1);\n\njulia> M3[1] .*= 3; # Modifies the tensor data\n\njulia> norm(M1)\n3.0000000000000004\n\njulia> norm(M3)\n3.0000000000000004 source"},{"id":303,"pagetitle":"MPS and MPO","title":"Base.deepcopy","ref":"/ITensorDocs/ITensorMPS/stable/#Base.deepcopy-Tuple{AbstractMPS}","content":" Base.deepcopy  —  Method deepcopy(::MPS)\ndeepcopy(::MPO) Make a deep copy of an MPS or MPO. By deep copy, it means that a new MPS/MPO is returned that doesn't share any data with the input MPS/MPO. Therefore, modifying the resulting MPS/MPO will note modify the original MPS/MPO. Use  copy  for an alternative that performs a shallow copy that avoids copying the ITensor data. Examples julia> using ITensors, ITensorMPS\n\njulia> s = siteinds(\"S=1/2\", 3);\n\njulia> M1 = random_mps(s; linkdims=3);\n\njulia> norm(M1)\n1.0\n\njulia> M2 = deepcopy(M1);\n\njulia> M2[1] .*= 2; # Modifies the tensor data\n\njulia> norm(M1)\n1.0\n\njulia> norm(M2)\n2.0\n\njulia> M3 = copy(M1);\n\njulia> M3[1] .*= 3; # Modifies the tensor data\n\njulia> norm(M1)\n3.0\n\njulia> norm(M3)\n3.0 source"},{"id":304,"pagetitle":"MPS and MPO","title":"Properties","ref":"/ITensorDocs/ITensorMPS/stable/#Properties","content":" Properties"},{"id":305,"pagetitle":"MPS and MPO","title":"Base.eltype","ref":"/ITensorDocs/ITensorMPS/stable/#Base.eltype-Tuple{AbstractMPS}","content":" Base.eltype  —  Method eltype(m::MPS)\neltype(m::MPO) The element type of the MPS/MPO. Always returns  ITensor . For the element type of the ITensors of the MPS/MPO, use  promote_itensor_eltype . source"},{"id":306,"pagetitle":"MPS and MPO","title":"ITensors.flux","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.flux-Tuple{AbstractMPS}","content":" ITensors.flux  —  Method flux(M::MPS)\n\nflux(M::MPO)\n\ntotalqn(M::MPS)\n\ntotalqn(M::MPO) For an MPS or MPO which conserves quantum numbers, compute the total QN flux. For a tensor network such as an MPS or MPO, the flux is the sum of fluxes of each of the tensors in the network. The name  totalqn  is an alias for  flux . source"},{"id":307,"pagetitle":"MPS and MPO","title":"ITensors.hasqns","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.hasqns-Tuple{AbstractMPS}","content":" ITensors.hasqns  —  Method hasqns(M::MPS)\n\nhasqns(M::MPO) Return true if the MPS or MPO has tensors which carry quantum numbers. source"},{"id":308,"pagetitle":"MPS and MPO","title":"Base.length","ref":"/ITensorDocs/ITensorMPS/stable/#Base.length-Tuple{AbstractMPS}","content":" Base.length  —  Method length(::MPS/MPO) The number of sites of an MPS/MPO. source"},{"id":309,"pagetitle":"MPS and MPO","title":"ITensorMPS.maxlinkdim","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.maxlinkdim-Tuple{AbstractMPS}","content":" ITensorMPS.maxlinkdim  —  Method maxlinkdim(M::MPS)\nmaxlinkdim(M::MPO) Get the maximum link dimension of the MPS or MPO. The minimum this will return is  1 , even if there are no link indices. source"},{"id":310,"pagetitle":"MPS and MPO","title":"Obtaining and finding indices","ref":"/ITensorDocs/ITensorMPS/stable/#Obtaining-and-finding-indices","content":" Obtaining and finding indices"},{"id":311,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteinds-Tuple{typeof(commoninds), AbstractMPS, AbstractMPS, Int64}","content":" ITensors.SiteTypes.siteinds  —  Method siteinds(commoninds, A::MPO, B::MPS, j::Integer; kwargs...)\nsiteinds(commonind, A::MPO, B::MPO, j::Integer; kwargs...) Get the site index (or indices) of  the  j th MPO tensor of  A  that is shared with MPS/MPO  B . source"},{"id":312,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteinds-Tuple{typeof(uniqueinds), AbstractMPS, AbstractMPS, Int64}","content":" ITensors.SiteTypes.siteinds  —  Method siteinds(uniqueinds, A::MPO, B::MPS, j::Integer; kwargs...)\nsiteinds(uniqueind, A::MPO, B::MPS, j::Integer; kwargs...) Get the site index (or indices) of MPO  A  that is unique to  A  (not shared with MPS/MPO  B ). source"},{"id":313,"pagetitle":"MPS and MPO","title":"ITensorMPS.findsite","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.findsite","content":" ITensorMPS.findsite  —  Function findsite(M::Union{MPS, MPO}, is) Return the first site of the MPS or MPO that has at least one Index in common with the Index or collection of indices  is . To find all sites with common indices with  is , use the  findsites  function. Examples s = siteinds(\"S=1/2\", 5)\nψ = random_mps(s)\nfindsite(ψ, s[3]) == 3\nfindsite(ψ, (s[3], s[4])) == 3\n\nM = MPO(s)\nfindsite(M, s[4]) == 4\nfindsite(M, s[4]') == 4\nfindsite(M, (s[4]', s[4])) == 4\nfindsite(M, (s[4]', s[3])) == 3 source"},{"id":314,"pagetitle":"MPS and MPO","title":"ITensorMPS.findsites","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.findsites","content":" ITensorMPS.findsites  —  Function findsites(M::Union{MPS, MPO}, is) Return the sites of the MPS or MPO that have indices in common with the collection of site indices  is . Examples s = siteinds(\"S=1/2\", 5)\nψ = random_mps(s)\nfindsites(ψ, s[3]) == [3]\nfindsites(ψ, (s[4], s[1])) == [1, 4]\n\nM = MPO(s)\nfindsites(M, s[4]) == [4]\nfindsites(M, s[4]') == [4]\nfindsites(M, (s[4]', s[4])) == [4]\nfindsites(M, (s[4]', s[3])) == [3, 4] source"},{"id":315,"pagetitle":"MPS and MPO","title":"ITensorMPS.firstsiteinds","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.firstsiteinds","content":" ITensorMPS.firstsiteinds  —  Function firstsiteinds(M::MPO; kwargs...) Get a Vector of the first site Index found on each site of M. By default, it finds the first site Index with prime level 0. source"},{"id":316,"pagetitle":"MPS and MPO","title":"ITensorMPS.linkind","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.linkind-Tuple{AbstractMPS, Int64}","content":" ITensorMPS.linkind  —  Method linkind(M::MPS, j::Integer)\nlinkind(M::MPO, j::Integer) Get the link or bond Index connecting the MPS or MPO tensor on site j to site j+1. If there is no link Index, return  nothing . source"},{"id":317,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteind","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteind-Tuple{MPS, Int64}","content":" ITensors.SiteTypes.siteind  —  Method siteind(M::MPS, j::Int; kwargs...) Get the first site Index of the MPS. Return  nothing  if none is found. source"},{"id":318,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteind","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteind-Tuple{typeof(first), MPS, Int64}","content":" ITensors.SiteTypes.siteind  —  Method siteind(::typeof(first), M::Union{MPS,MPO}, j::Integer; kwargs...) Return the first site Index found on the MPS or MPO (the first Index unique to the  j th MPS/MPO tensor). You can choose different filters, like prime level and tags, with the  kwargs . source"},{"id":319,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteinds-Tuple{MPS}","content":" ITensors.SiteTypes.siteinds  —  Method siteinds(M::MPS)\nsiteinds(::typeof(first), M::MPS) Get a vector of the first site Index found on each tensor of the MPS. siteinds(::typeof(only), M::MPS) Get a vector of the only site Index found on each tensor of the MPS. Errors if more than one is found. siteinds(::typeof(all), M::MPS) Get a vector of the all site Indices found on each tensor of the MPS. Returns a Vector of IndexSets. source"},{"id":320,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteind","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteind-Tuple{MPO, Int64}","content":" ITensors.SiteTypes.siteind  —  Method siteind(M::MPO, j::Int; plev = 0, kwargs...) Get the first site Index of the MPO found, by default with prime level 0. source"},{"id":321,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteinds-Tuple{MPO}","content":" ITensors.SiteTypes.siteinds  —  Method siteinds(M::MPO; kwargs...) Get a Vector of IndexSets of all the site indices of M. source"},{"id":322,"pagetitle":"MPS and MPO","title":"ITensors.SiteTypes.siteinds","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.siteinds-Tuple{AbstractMPS, Int64}","content":" ITensors.SiteTypes.siteinds  —  Method siteinds(M::Union{MPS, MPO}}, j::Integer; kwargs...) Return the site Indices found of the MPO or MPO at the site  j  as an IndexSet. Optionally filter prime tags and prime levels with keyword arguments like  plev  and  tags . source"},{"id":323,"pagetitle":"MPS and MPO","title":"Priming and tagging","ref":"/ITensorDocs/ITensorMPS/stable/#Priming-and-tagging","content":" Priming and tagging"},{"id":324,"pagetitle":"MPS and MPO","title":"ITensors.prime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.prime-Tuple{AbstractMPS}","content":" ITensors.prime  —  Method prime[!](M::MPS, args...; kwargs...)\nprime[!](M::MPO, args...; kwargs...) Apply prime to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":325,"pagetitle":"MPS and MPO","title":"ITensors.prime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.prime-Tuple{typeof(siteinds), AbstractMPS}","content":" ITensors.prime  —  Method prime[!](siteinds, M::MPS, args...; kwargs...)\nprime[!](siteinds, M::MPO, args...; kwargs...) Apply prime to all site indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":326,"pagetitle":"MPS and MPO","title":"ITensors.prime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.prime-Tuple{typeof(linkinds), AbstractMPS}","content":" ITensors.prime  —  Method prime[!](linkinds, M::MPS, args...; kwargs...)\nprime[!](linkinds, M::MPO, args...; kwargs...) Apply prime to all link indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":327,"pagetitle":"MPS and MPO","title":"ITensors.prime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.prime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","content":" ITensors.prime  —  Method prime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...) Apply prime to the site indices that are shared by  M1  and  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":328,"pagetitle":"MPS and MPO","title":"ITensors.prime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.prime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","content":" ITensors.prime  —  Method prime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...) Apply prime to the site indices of  M1  that are not shared with  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":329,"pagetitle":"MPS and MPO","title":"ITensors.swapprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.swapprime-Tuple{AbstractMPS, Vararg{Any}}","content":" ITensors.swapprime  —  Method swapprime[!](M::MPS, args...; kwargs...)\nswapprime[!](M::MPO, args...; kwargs...) Apply swapprime to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":330,"pagetitle":"MPS and MPO","title":"ITensors.setprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.setprime-Tuple{AbstractMPS}","content":" ITensors.setprime  —  Method setprime[!](M::MPS, args...; kwargs...)\nsetprime[!](M::MPO, args...; kwargs...) Apply setprime to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":331,"pagetitle":"MPS and MPO","title":"ITensors.setprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.setprime-Tuple{typeof(siteinds), AbstractMPS}","content":" ITensors.setprime  —  Method setprime[!](siteinds, M::MPS, args...; kwargs...)\nsetprime[!](siteinds, M::MPO, args...; kwargs...) Apply setprime to all site indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":332,"pagetitle":"MPS and MPO","title":"ITensors.setprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.setprime-Tuple{typeof(linkinds), AbstractMPS}","content":" ITensors.setprime  —  Method setprime[!](linkinds, M::MPS, args...; kwargs...)\nsetprime[!](linkinds, M::MPO, args...; kwargs...) Apply setprime to all link indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":333,"pagetitle":"MPS and MPO","title":"ITensors.setprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.setprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","content":" ITensors.setprime  —  Method setprime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nsetprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...) Apply setprime to the site indices that are shared by  M1  and  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":334,"pagetitle":"MPS and MPO","title":"ITensors.setprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.setprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","content":" ITensors.setprime  —  Method setprime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...) Apply setprime to the site indices of  M1  that are not shared with  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":335,"pagetitle":"MPS and MPO","title":"ITensors.noprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.noprime-Tuple{AbstractMPS}","content":" ITensors.noprime  —  Method noprime[!](M::MPS, args...; kwargs...)\nnoprime[!](M::MPO, args...; kwargs...) Apply noprime to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":336,"pagetitle":"MPS and MPO","title":"ITensors.noprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.noprime-Tuple{typeof(siteinds), AbstractMPS}","content":" ITensors.noprime  —  Method noprime[!](siteinds, M::MPS, args...; kwargs...)\nnoprime[!](siteinds, M::MPO, args...; kwargs...) Apply noprime to all site indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":337,"pagetitle":"MPS and MPO","title":"ITensors.noprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.noprime-Tuple{typeof(linkinds), AbstractMPS}","content":" ITensors.noprime  —  Method noprime[!](linkinds, M::MPS, args...; kwargs...)\nnoprime[!](linkinds, M::MPO, args...; kwargs...) Apply noprime to all link indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":338,"pagetitle":"MPS and MPO","title":"ITensors.noprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.noprime-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","content":" ITensors.noprime  —  Method noprime[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nnoprime[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...) Apply noprime to the site indices that are shared by  M1  and  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":339,"pagetitle":"MPS and MPO","title":"ITensors.noprime","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.noprime-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","content":" ITensors.noprime  —  Method noprime[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...) Apply noprime to the site indices of  M1  that are not shared with  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":340,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.addtags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.addtags-Tuple{AbstractMPS}","content":" ITensors.TagSets.addtags  —  Method addtags[!](M::MPS, args...; kwargs...)\naddtags[!](M::MPO, args...; kwargs...) Apply addtags to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":341,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.addtags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.addtags-Tuple{typeof(siteinds), AbstractMPS}","content":" ITensors.TagSets.addtags  —  Method addtags[!](siteinds, M::MPS, args...; kwargs...)\naddtags[!](siteinds, M::MPO, args...; kwargs...) Apply addtags to all site indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":342,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.addtags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.addtags-Tuple{typeof(linkinds), AbstractMPS}","content":" ITensors.TagSets.addtags  —  Method addtags[!](linkinds, M::MPS, args...; kwargs...)\naddtags[!](linkinds, M::MPO, args...; kwargs...) Apply addtags to all link indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":343,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.addtags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","content":" ITensors.TagSets.addtags  —  Method addtags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\naddtags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...) Apply addtags to the site indices that are shared by  M1  and  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":344,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.addtags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.addtags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","content":" ITensors.TagSets.addtags  —  Method addtags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...) Apply addtags to the site indices of  M1  that are not shared with  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":345,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.removetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.removetags-Tuple{AbstractMPS}","content":" ITensors.TagSets.removetags  —  Method removetags[!](M::MPS, args...; kwargs...)\nremovetags[!](M::MPO, args...; kwargs...) Apply removetags to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":346,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.removetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.removetags-Tuple{typeof(siteinds), AbstractMPS}","content":" ITensors.TagSets.removetags  —  Method removetags[!](siteinds, M::MPS, args...; kwargs...)\nremovetags[!](siteinds, M::MPO, args...; kwargs...) Apply removetags to all site indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":347,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.removetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.removetags-Tuple{typeof(linkinds), AbstractMPS}","content":" ITensors.TagSets.removetags  —  Method removetags[!](linkinds, M::MPS, args...; kwargs...)\nremovetags[!](linkinds, M::MPO, args...; kwargs...) Apply removetags to all link indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":348,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.removetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","content":" ITensors.TagSets.removetags  —  Method removetags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nremovetags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...) Apply removetags to the site indices that are shared by  M1  and  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":349,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.removetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.removetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","content":" ITensors.TagSets.removetags  —  Method removetags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...) Apply removetags to the site indices of  M1  that are not shared with  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":350,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.replacetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.replacetags-Tuple{AbstractMPS}","content":" ITensors.TagSets.replacetags  —  Method replacetags[!](M::MPS, args...; kwargs...)\nreplacetags[!](M::MPO, args...; kwargs...) Apply replacetags to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":351,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.replacetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), AbstractMPS}","content":" ITensors.TagSets.replacetags  —  Method replacetags[!](siteinds, M::MPS, args...; kwargs...)\nreplacetags[!](siteinds, M::MPO, args...; kwargs...) Apply replacetags to all site indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":352,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.replacetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.replacetags-Tuple{typeof(linkinds), AbstractMPS}","content":" ITensors.TagSets.replacetags  —  Method replacetags[!](linkinds, M::MPS, args...; kwargs...)\nreplacetags[!](linkinds, M::MPO, args...; kwargs...) Apply replacetags to all link indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":353,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.replacetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","content":" ITensors.TagSets.replacetags  —  Method replacetags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nreplacetags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...) Apply replacetags to the site indices that are shared by  M1  and  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":354,"pagetitle":"MPS and MPO","title":"ITensors.TagSets.replacetags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.TagSets.replacetags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","content":" ITensors.TagSets.replacetags  —  Method replacetags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...) Apply replacetags to the site indices of  M1  that are not shared with  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":355,"pagetitle":"MPS and MPO","title":"ITensors.settags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.settags-Tuple{AbstractMPS}","content":" ITensors.settags  —  Method settags[!](M::MPS, args...; kwargs...)\nsettags[!](M::MPO, args...; kwargs...) Apply settags to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":356,"pagetitle":"MPS and MPO","title":"ITensors.settags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.settags-Tuple{typeof(siteinds), AbstractMPS}","content":" ITensors.settags  —  Method settags[!](siteinds, M::MPS, args...; kwargs...)\nsettags[!](siteinds, M::MPO, args...; kwargs...) Apply settags to all site indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":357,"pagetitle":"MPS and MPO","title":"ITensors.settags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.settags-Tuple{typeof(linkinds), AbstractMPS}","content":" ITensors.settags  —  Method settags[!](linkinds, M::MPS, args...; kwargs...)\nsettags[!](linkinds, M::MPO, args...; kwargs...) Apply settags to all link indices of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. source"},{"id":358,"pagetitle":"MPS and MPO","title":"ITensors.settags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.settags-Tuple{typeof(siteinds), typeof(commoninds), AbstractMPS, AbstractMPS}","content":" ITensors.settags  —  Method settags[!](siteinds, commoninds, M1::MPO, M2::MPS, args...; kwargs...)\nsettags[!](siteinds, commoninds, M1::MPO, M2::MPO, args...; kwargs...) Apply settags to the site indices that are shared by  M1  and  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":359,"pagetitle":"MPS and MPO","title":"ITensors.settags","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.settags-Tuple{typeof(siteinds), typeof(uniqueinds), AbstractMPS, AbstractMPS}","content":" ITensors.settags  —  Method settags[!](siteinds, uniqueinds, M1::MPO, M2::MPS, args...; kwargs...) Apply settags to the site indices of  M1  that are not shared with  M2 . Returns new MPSs/MPOs. The ITensors of the MPSs/MPOs will be a view of the storage of the original ITensors. source"},{"id":360,"pagetitle":"MPS and MPO","title":"Operations","ref":"/ITensorDocs/ITensorMPS/stable/#Operations","content":" Operations"},{"id":361,"pagetitle":"MPS and MPO","title":"ITensorMPS.expect","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.expect-Tuple{MPS, Any}","content":" ITensorMPS.expect  —  Method expect(psi::MPS, op::AbstractString...; kwargs...)\nexpect(psi::MPS, op::Matrix{<:Number}...; kwargs...)\nexpect(psi::MPS, ops; kwargs...) Given an MPS  psi  and a single operator name, returns a vector of the expected value of the operator on each site of the MPS. If multiple operator names are provided, returns a tuple of expectation value vectors. If a container of operator names is provided, returns the same type of container with names replaced by vectors of expectation values. Optional Keyword Arguments sites = 1:length(psi) : compute expected values only for sites in the given range Examples N = 10\n\ns = siteinds(\"S=1/2\", N)\npsi = random_mps(s; linkdims=8)\nZ = expect(psi, \"Sz\") # compute for all sites\nZ = expect(psi, \"Sz\"; sites=2:4) # compute for sites 2,3,4\nZ3 = expect(psi, \"Sz\"; sites=3)  # compute for site 3 only (output will be a scalar)\nXZ = expect(psi, [\"Sx\", \"Sz\"]) # compute Sx and Sz for all sites\nZ = expect(psi, [1/2 0; 0 -1/2]) # same as expect(psi,\"Sz\")\n\ns = siteinds(\"Electron\", N)\npsi = random_mps(s; linkdims=8)\ndens = expect(psi, \"Ntot\")\nupdens, dndens = expect(psi, \"Nup\", \"Ndn\") # pass more than one operator source"},{"id":362,"pagetitle":"MPS and MPO","title":"ITensorMPS.correlation_matrix","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.correlation_matrix-Tuple{MPS, AbstractString, AbstractString}","content":" ITensorMPS.correlation_matrix  —  Method correlation_matrix(psi::MPS,\n                   Op1::AbstractString,\n                   Op2::AbstractString;\n                   kwargs...)\n\ncorrelation_matrix(psi::MPS,\n                   Op1::Matrix{<:Number},\n                   Op2::Matrix{<:Number};\n                   kwargs...) Given an MPS psi and two strings denoting operators (as recognized by the  op  function), computes the two-point correlation function matrix C[i,j] = <psi| Op1i Op2j |psi> using efficient MPS techniques. Returns the matrix C. Optional Keyword Arguments sites = 1:length(psi) : compute correlations only  for sites in the given range ishermitian = false  : if  false , force independent calculations of the  matrix elements above and below the diagonal, while if  true  assume they are complex conjugates. For a correlation matrix of size NxN and an MPS of typical bond dimension m, the scaling of this algorithm is N^2*m^3. Examples N = 30\nm = 4\n\ns = siteinds(\"S=1/2\", N)\npsi = random_mps(s; linkdims=m)\nCzz = correlation_matrix(psi, \"Sz\", \"Sz\")\nCzz = correlation_matrix(psi, [1/2 0; 0 -1/2], [1/2 0; 0 -1/2]) # same as above\n\ns = siteinds(\"Electron\", N; conserve_qns=true)\npsi = random_mps(s, n -> isodd(n) ? \"Up\" : \"Dn\"; linkdims=m)\nCuu = correlation_matrix(psi, \"Cdagup\", \"Cup\"; sites=2:8) source"},{"id":363,"pagetitle":"MPS and MPO","title":"ITensors.dag","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.dag-Tuple{AbstractMPS}","content":" ITensors.dag  —  Method dag[!](M::MPS, args...; kwargs...)\ndag[!](M::MPO, args...; kwargs...) Apply dag to all ITensors of an MPS/MPO, returning a new MPS/MPO. The ITensors of the MPS/MPO will be a view of the storage of the original ITensors. Alternatively apply the function in-place. source"},{"id":364,"pagetitle":"MPS and MPO","title":"NDTensors.dense","ref":"/ITensorDocs/ITensorMPS/stable/#NDTensors.dense-Tuple{AbstractMPS}","content":" NDTensors.dense  —  Method dense(::MPS/MPO) Given an MPS (or MPO), return a new MPS (or MPO) having called  dense  on each ITensor to convert each tensor to use dense storage and remove any QN or other sparse structure information, if it is not dense already. source"},{"id":365,"pagetitle":"MPS and MPO","title":"ITensorMPS.movesite","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.movesite-Tuple{AbstractMPS, Pair{Int64, Int64}}","content":" ITensorMPS.movesite  —  Method movesite(::Union{MPS, MPO}, n1n2::Pair{Int, Int}) Create a new MPS/MPO where the site at  n1  is moved to  n2 , for a pair  n1n2 = n1 => n2 . This is done with a series a pairwise swaps, and can introduce a lot of entanglement into your state, so use with caution. source"},{"id":366,"pagetitle":"MPS and MPO","title":"ITensorMPS.orthogonalize!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.orthogonalize!","content":" ITensorMPS.orthogonalize!  —  Function orthogonalize!(M::MPS, j::Int; kwargs...)\northogonalize(M::MPS, j::Int; kwargs...)\n\northogonalize!(M::MPO, j::Int; kwargs...)\northogonalize(M::MPO, j::Int; kwargs...) Move the orthogonality center of the MPS to site  j . No observable property of the MPS will be changed, and no truncation of the bond indices is performed. Afterward, tensors  1,2,...,j-1  will be left-orthogonal and tensors  j+1,j+2,...,N  will be right-orthogonal. Either modify in-place with  orthogonalize!  or out-of-place with  orthogonalize . source"},{"id":367,"pagetitle":"MPS and MPO","title":"ITensorMPS.replacebond!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.replacebond!-Tuple{MPS, Int64, ITensor}","content":" ITensorMPS.replacebond!  —  Method replacebond!(M::MPS, b::Int, phi::ITensor; kwargs...) Factorize the ITensor  phi  and replace the ITensors  b  and  b+1  of MPS  M  with the factors. Choose the orthogonality with  ortho=\"left\"/\"right\" . source"},{"id":368,"pagetitle":"MPS and MPO","title":"ITensorMPS.sample","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.sample-Tuple{MPS}","content":" ITensorMPS.sample  —  Method sample(m::MPS) Given a normalized MPS m with  orthocenter(m)==1 , returns a  Vector{Int}  of  length(m)  corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents source"},{"id":369,"pagetitle":"MPS and MPO","title":"ITensorMPS.sample!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.sample!-Tuple{MPS}","content":" ITensorMPS.sample!  —  Method sample!(m::MPS) Given a normalized MPS m, returns a  Vector{Int}  of  length(m)  corresponding to one sample of the probability distribution defined by squaring the components of the tensor that the MPS represents. If the MPS does not have an orthogonality center, orthogonalize!(m,1) will be called before computing the sample. source"},{"id":370,"pagetitle":"MPS and MPO","title":"ITensorMPS.sample","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.sample-Tuple{MPO}","content":" ITensorMPS.sample  —  Method sample(M::MPO) Given a normalized MPO  M , returns a  Vector{Int}  of  length(M)  corresponding to one sample of the probability distribution defined by the MPO, treating the MPO as a density matrix. The MPO  M  should have an (approximately) positive spectrum. source"},{"id":371,"pagetitle":"MPS and MPO","title":"ITensorMPS.swapbondsites","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.swapbondsites-Tuple{AbstractMPS, Int64}","content":" ITensorMPS.swapbondsites  —  Method swapbondsites(ψ::Union{MPS, MPO}, b::Integer; kwargs...) Swap the sites  b  and  b+1 . source"},{"id":372,"pagetitle":"MPS and MPO","title":"NDTensors.truncate!","ref":"/ITensorDocs/ITensorMPS/stable/#NDTensors.truncate!","content":" NDTensors.truncate!  —  Function truncate!(M::MPS; kwargs...)\ntruncate!(M::MPO; kwargs...) Perform a truncation of all bonds of an MPS/MPO, using the truncation parameters (cutoff,maxdim, etc.) provided as keyword arguments. Keyword arguments: site_range =1:N - only truncate the MPS bonds between these sites callback=Returns(nothing)  - callback function that allows the user to save the per-bond truncation error. The API of  callback  expects to take two kwargs called  link  and  truncation_error  where  link  is of type  Pair{Int64, Int64}  and  truncation_error  is  Float64 . Consider the following example that illustrates one possible use case. nbonds = 9\ntruncation_errors = zeros(nbonds)\nfunction callback(; link, truncation_error)\n  bond_no = last(link)\n  truncation_errors[bond_no] = truncation_error\n  return nothing\nend\ntruncate!(ψ; maxdim=5, cutoff=1E-7, callback) source"},{"id":373,"pagetitle":"MPS and MPO","title":"Gate evolution","ref":"/ITensorDocs/ITensorMPS/stable/#Gate-evolution","content":" Gate evolution"},{"id":374,"pagetitle":"MPS and MPO","title":"ITensors.product","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.product-Tuple{ITensor, AbstractMPS}","content":" ITensors.product  —  Method apply(o::ITensor, ψ::Union{MPS, MPO}, [ns::Vector{Int}]; kwargs...)\nproduct([...]) Get the product of the operator  o  with the MPS/MPO  ψ , where the operator is applied to the sites  ns . If  ns  are not specified, the sites are determined by the common indices between  o  and the site indices of  ψ . If  ns  are non-contiguous, the sites of the MPS are moved to be contiguous. By default, the sites are moved back to their original locations. You can leave them where they are by setting the keyword argument  move_sites_back  to false. Keywords cutoff::Real : singular value truncation cutoff. maxdim::Int : maximum MPS/MPO dimension. apply_dag::Bool = false : apply the gate and the dagger of the gate (only  relevant for MPO evolution). move_sites_back::Bool = true : after the ITensors are applied to the MPS or  MPO, move the sites of the MPS or MPO back to their original locations. source"},{"id":375,"pagetitle":"MPS and MPO","title":"ITensors.product","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.product-Tuple{Vector{ITensor}, AbstractMPS}","content":" ITensors.product  —  Method apply(As::Vector{<:ITensor}, M::Union{MPS, MPO}; kwargs...)\nproduct([...]) Apply the ITensors  As  to the MPS or MPO  M , treating them as gates or matrices from pairs of prime or unprimed indices. Keywords cutoff::Real : singular value truncation cutoff. maxdim::Int : maximum MPS/MPO dimension. apply_dag::Bool = false : apply the gate and the dagger of the gate (only relevant for MPO evolution). move_sites_back::Bool = true : after the ITensor is applied to the MPS or  MPO, move the sites of the MPS or MPO back to their original locations. Examples Apply one-site gates to an MPS: N = 3\n\nITensors.op(::OpName\"σx\", ::SiteType\"S=1/2\", s::Index) =\n  2*op(\"Sx\", s)\n\nITensors.op(::OpName\"σz\", ::SiteType\"S=1/2\", s::Index) =\n  2*op(\"Sz\", s)\n\n# Make the operator list.\nos = [(\"σx\", n) for n in 1:N]\nappend!(os, [(\"σz\", n) for n in 1:N])\n\n@show os\n\ns = siteinds(\"S=1/2\", N)\ngates = ops(os, s)\n\n# Starting state |↑↑↑⟩\nψ0 = MPS(s, \"↑\")\n\n# Apply the gates.\nψ = apply(gates, ψ0; cutoff = 1e-15)\n\n# Test against exact (full) wavefunction\nprodψ = apply(gates, prod(ψ0))\n@show prod(ψ) ≈ prodψ\n\n# The result is:\n# σz₃ σz₂ σz₁ σx₃ σx₂ σx₁ |↑↑↑⟩ = -|↓↓↓⟩\n@show inner(ψ, MPS(s, \"↓\")) == -1 Apply nonlocal two-site gates and one-site gates to an MPS: # 2-site gate\nfunction ITensors.op(::OpName\"CX\", ::SiteType\"S=1/2\", s1::Index, s2::Index)\n  mat = [1 0 0 0\n         0 1 0 0\n         0 0 0 1\n         0 0 1 0]\n  return itensor(mat, s2', s1', s2, s1)\nend\n\nos = [(\"CX\", 1, 3), (\"σz\", 3)]\n\n@show os\n\n# Start with the state |↓↑↑⟩\nψ0 = MPS(s, n -> n == 1 ? \"↓\" : \"↑\")\n\n# The result is:\n# σz₃ CX₁₃ |↓↑↑⟩ = -|↓↑↓⟩\nψ = apply(ops(os, s), ψ0; cutoff = 1e-15)\n@show inner(ψ, MPS(s, n -> n == 1 || n == 3 ? \"↓\" : \"↑\")) == -1 Perform TEBD-like time evolution: # Define the nearest neighbor term `S⋅S` for the Heisenberg model\nfunction ITensors.op(::OpName\"expS⋅S\", ::SiteType\"S=1/2\",\n                     s1::Index, s2::Index; τ::Number)\n  O = 0.5 * op(\"S+\", s1) * op(\"S-\", s2) +\n      0.5 * op(\"S-\", s1) * op(\"S+\", s2) +\n            op(\"Sz\", s1) * op(\"Sz\", s2)\n  return exp(τ * O)\nend\n\nτ = -0.1im\nos = [(\"expS⋅S\", (1, 2), (τ = τ,)),\n      (\"expS⋅S\", (2, 3), (τ = τ,))]\nψ0 = MPS(s, n -> n == 1 ? \"↓\" : \"↑\")\nexpτH = ops(os, s)\nψτ = apply(expτH, ψ0) source"},{"id":376,"pagetitle":"MPS and MPO","title":"Algebra Operations","ref":"/ITensorDocs/ITensorMPS/stable/#Algebra-Operations","content":" Algebra Operations"},{"id":377,"pagetitle":"MPS and MPO","title":"ITensors.inner","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.inner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","content":" ITensors.inner  —  Method inner(A::MPS, B::MPS)\ninner(A::MPO, B::MPO) Compute the inner product  ⟨A|B⟩ . If  A  and  B  are MPOs, computes the Frobenius inner product. Use  loginner  to avoid underflow/overflow for taking overlaps of large MPS or MPO. ITensors 0.3 Before ITensors 0.3,  inner  had a keyword argument  make_inds_match  that default to  true .   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly. Same as  dot . See also  loginner ,  logdot . source"},{"id":378,"pagetitle":"MPS and MPO","title":"LinearAlgebra.dot","ref":"/ITensorDocs/ITensorMPS/stable/#LinearAlgebra.dot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","content":" LinearAlgebra.dot  —  Method dot(A::MPS, B::MPS)\ndot(A::MPO, B::MPO) Same as  inner . See also  loginner ,  logdot . source"},{"id":379,"pagetitle":"MPS and MPO","title":"ITensorMPS.loginner","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.loginner-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","content":" ITensorMPS.loginner  —  Method loginner(A::MPS, B::MPS)\nloginner(A::MPO, B::MPO) Compute the logarithm of the inner product  ⟨A|B⟩ . If  A  and  B  are MPOs, computes the logarithm of the Frobenius inner product. This is useful for larger MPS/MPO, where in the limit of large numbers of sites the inner product can diverge or approach zero. ITensors 0.3 Before ITensors 0.3,  inner  had a keyword argument  make_inds_match  that default to  true .   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly. Same as  logdot . See also  inner ,  dot . source"},{"id":380,"pagetitle":"MPS and MPO","title":"ITensorMPS.logdot","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.logdot-Union{Tuple{MPST}, Tuple{MPST, MPST}} where MPST<:AbstractMPS","content":" ITensorMPS.logdot  —  Method logdot(A::MPS, B::MPS)\nlogdot(A::MPO, B::MPO) Same as  loginner . See also  inner ,  dot . source"},{"id":381,"pagetitle":"MPS and MPO","title":"ITensors.inner","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.inner-Tuple{MPS, MPO, MPS}","content":" ITensors.inner  —  Method inner(y::MPS, A::MPO, x::MPS) Compute  ⟨y|A|x⟩ = ⟨y|Ax⟩  efficiently and exactly without making any intermediate MPOs. In general it is more efficient and accurate than  inner(y, apply(A, x)) . This is helpful for computing the expectation value of an operator  A , which would be: inner(x', A, x) assuming  x  is normalized. If you want to compute  ⟨By|Ax⟩  you can use  inner(B::MPO, y::MPS, A::MPO, x::MPS) . This is helpful for computing the variance of an operator  A , which would be: inner(A, x, A, x) - inner(x', A, x) ^ 2 assuming  x  is normalized. ITensors 0.3 Before ITensors 0.3,  inner  had a keyword argument  make_inds_match  that default to  true .   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly. Same as  dot . source"},{"id":382,"pagetitle":"MPS and MPO","title":"LinearAlgebra.dot","ref":"/ITensorDocs/ITensorMPS/stable/#LinearAlgebra.dot-Tuple{MPS, MPO, MPS}","content":" LinearAlgebra.dot  —  Method dot(y::MPS, A::MPO, x::MPS) Same as  inner . source"},{"id":383,"pagetitle":"MPS and MPO","title":"ITensors.inner","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.inner-Tuple{MPO, MPS, MPO, MPS}","content":" ITensors.inner  —  Method inner(B::MPO, y::MPS, A::MPO, x::MPS) Compute  ⟨By|A|x⟩ = ⟨By|Ax⟩  efficiently and exactly without making any intermediate MPOs. In general it is more efficient and accurate than  inner(apply(B, y), apply(A, x)) . This is helpful for computing the variance of an operator  A , which would be: inner(A, x, A, x) - inner(x, A, x) ^ 2 ITensors 0.3 Before ITensors 0.3,  inner  had a keyword argument  make_inds_match  that default to  true .   When true, the function attempted to make the site indices match before contracting. So for example, the   inputs could have different site indices, as long as they have the same dimensions or QN blocks.   This behavior was fragile since it only worked for MPS with single site indices per tensor,   and as of ITensors 0.3 has been deprecated. As of ITensors 0.3 you will need to make sure   the MPS or MPO you input have compatible site indices to contract over, such as by making   sure the prime levels match properly. Same as  dot . source"},{"id":384,"pagetitle":"MPS and MPO","title":"LinearAlgebra.dot","ref":"/ITensorDocs/ITensorMPS/stable/#LinearAlgebra.dot-Tuple{MPO, MPS, MPO, MPS}","content":" LinearAlgebra.dot  —  Method dot(B::MPO, y::MPS, A::MPO, x::MPS) Same as  inner . source"},{"id":385,"pagetitle":"MPS and MPO","title":"LinearAlgebra.norm","ref":"/ITensorDocs/ITensorMPS/stable/#LinearAlgebra.norm-Tuple{AbstractMPS}","content":" LinearAlgebra.norm  —  Method norm(A::MPS)\nnorm(A::MPO) Compute the norm of the MPS or MPO. If the MPS or MPO has a well defined orthogonality center, this reduces to the norm of the orthogonality center tensor. Otherwise, it computes the norm with the full inner product of the MPS/MPO with itself. See also  lognorm . source"},{"id":386,"pagetitle":"MPS and MPO","title":"LinearAlgebra.normalize","ref":"/ITensorDocs/ITensorMPS/stable/#LinearAlgebra.normalize-Tuple{AbstractMPS}","content":" LinearAlgebra.normalize  —  Method normalize(A::MPS; (lognorm!)=[])\nnormalize(A::MPO; (lognorm!)=[]) Return a new MPS or MPO  A  that is the same as the original MPS or MPO but with  norm(A) ≈ 1 . In practice, this evenly spreads  lognorm(A)  over the tensors within the range of the orthogonality center to avoid numerical overflow in the case of diverging norms. See also  normalize! ,  norm ,  lognorm . source"},{"id":387,"pagetitle":"MPS and MPO","title":"LinearAlgebra.normalize!","ref":"/ITensorDocs/ITensorMPS/stable/#LinearAlgebra.normalize!-Tuple{AbstractMPS}","content":" LinearAlgebra.normalize!  —  Method normalize!(A::MPS; (lognorm!)=[])\nnormalize!(A::MPO; (lognorm!)=[]) Change the MPS or MPO  A  in-place such that  norm(A) ≈ 1 . This modifies the data of the tensors within the orthogonality center. In practice, this evenly spreads  lognorm(A)  over the tensors within the range of the orthogonality center to avoid numerical overflow in the case of diverging norms. If the norm of the input MPS or MPO is 0, normalizing is ill-defined. In this case, we just return the original MPS or MPO. You can check for this case as follows: s = siteinds(\"S=1/2\", 4)\nψ = 0 * random_mps(s)\nlognorm_ψ = []\nnormalize!(ψ; (lognorm!)=lognorm_ψ)\nlognorm_ψ[1] == -Inf # There was an infinite norm See also  normalize ,  norm ,  lognorm . source"},{"id":388,"pagetitle":"MPS and MPO","title":"ITensorMPS.lognorm","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.lognorm-Tuple{AbstractMPS}","content":" ITensorMPS.lognorm  —  Method lognorm(A::MPS)\nlognorm(A::MPO) Compute the logarithm of the norm of the MPS or MPO. This is useful for larger MPS/MPO that are not gauged, where in the limit of large numbers of sites the norm can diverge or approach zero. See also  norm ,  logdot . source"},{"id":389,"pagetitle":"MPS and MPO","title":"Base.:+","ref":"/ITensorDocs/ITensorMPS/stable/#Base.:+-Tuple{Vararg{AbstractMPS}}","content":" Base.:+  —  Method +(A::MPS/MPO...; kwargs...)\nadd(A::MPS/MPO...; kwargs...) Add arbitrary numbers of MPS/MPO with each other, optionally truncating the results. A cutoff of 1e-15 is used by default, and in general users should set their own cutoff for their particular application. Keywords cutoff::Real : singular value truncation cutoff maxdim::Int : maximum MPS/MPO bond dimension alg = \"densitymatrix\" :  \"densitymatrix\"  or  \"directsum\" .  \"densitymatrix\"  adds the MPS/MPO  by adding up and diagoanlizing local density matrices site by site in a single  sweep through the system, truncating the density matrix with  cutoff  and  maxdim .   \"directsum\"  performs a direct sum of each tensors on each site of the input  MPS/MPO being summed. It doesn't perform any truncation, and therefore ignores   cutoff  and  maxdim . The bond dimension of the output is the sum of the bond  dimensions of the inputs. You can truncate the resulting MPS/MPO with the  truncate!  function. Examples N = 10\n\ns = siteinds(\"S=1/2\", N; conserve_qns = true)\n\nstate = n -> isodd(n) ? \"↑\" : \"↓\"\nψ₁ = random_mps(s, state; linkdims=2)\nψ₂ = random_mps(s, state; linkdims=2)\nψ₃ = random_mps(s, state; linkdims=2)\n\nψ = +(ψ₁, ψ₂; cutoff = 1e-8)\n\n# Can use:\n#\n# ψ = ψ₁ + ψ₂\n#\n# but generally you want to set a custom `cutoff` and `maxdim`.\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₂) + inner(ψ₁, ψ₂) + inner(ψ₂, ψ₁) + inner(ψ₂, ψ₂)\n\n# Computes ψ₁ + 2ψ₂\nψ = ψ₁ + 2ψ₂\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + 2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂)\n\n# Computes ψ₁ + 2ψ₂ + ψ₃\nψ = ψ₁ + 2ψ₂ + ψ₃\n\nprintln()\n@show inner(ψ, ψ)\n@show inner(ψ₁, ψ₁) + 2 * inner(ψ₁, ψ₂) + inner(ψ₁, ψ₃) +\n      2 * inner(ψ₂, ψ₁) + 4 * inner(ψ₂, ψ₂) + 2 * inner(ψ₂, ψ₃) +\n      inner(ψ₃, ψ₁) + 2 * inner(ψ₃, ψ₂) + inner(ψ₃, ψ₃) source"},{"id":390,"pagetitle":"MPS and MPO","title":"NDTensors.contract","ref":"/ITensorDocs/ITensorMPS/stable/#NDTensors.contract-Tuple{MPO, MPS}","content":" NDTensors.contract  —  Method contract(ψ::MPS, A::MPO; kwargs...) -> MPS\n*(::MPS, ::MPO; kwargs...) -> MPS\n\ncontract(A::MPO, ψ::MPS; kwargs...) -> MPS\n*(::MPO, ::MPS; kwargs...) -> MPS Contract the  MPO A  with the  MPS ψ , returning an  MPS  with the unique site indices of the  MPO . For example, for an MPO with site indices with prime levels of 1 and 0, such as  -s'-A-s- , and an MPS with site indices with prime levels of 0, such as  -s-x , the result is an MPS  y  with site indices with prime levels of 1,  -s'-y = -s'-A-s-x . Since it is common to contract an MPO with prime levels of 1 and 0 with an MPS with prime level of 0 and want a resulting MPS with prime levels of 0, we provide a convenience function  apply : apply(A, x; kwargs...) = replaceprime(contract(A, x; kwargs...), 2 => 1)`. Choose the method with the  method  keyword, for example  \"densitymatrix\"  and  \"naive\" . Keywords cutoff::Float64=1e-13 : the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to  change, in general you should set a  cutoff  value. maxdim::Int=maxlinkdim(A) * maxlinkdim(ψ)) : the maximal bond dimension of the results MPS. mindim::Int=1 : the minimal bond dimension of the resulting MPS. normalize::Bool=false : whether or not to normalize the resulting MPS. method::String=\"densitymatrix\" : the algorithm to use for the contraction.  Currently the options are \"densitymatrix\", where the network formed by the  MPO and MPS is squared and contracted down to a density matrix which is  diagonalized iteratively at each site, and \"naive\", where the MPO and MPS  tensor are contracted exactly at each site and then a truncation of the  resulting MPS is performed. See also  apply . source"},{"id":391,"pagetitle":"MPS and MPO","title":"ITensors.apply","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.apply-Tuple{MPO, MPS}","content":" ITensors.apply  —  Method apply(A::MPO, x::MPS; kwargs...) Contract the  MPO A  with the  MPS x  and then map the prime level of the resulting MPS back to 0. Equivalent to  replaceprime(contract(A, x; kwargs...), 2 => 1) . See also  contract  for details about the arguments available. source"},{"id":392,"pagetitle":"MPS and MPO","title":"NDTensors.contract","ref":"/ITensorDocs/ITensorMPS/stable/#NDTensors.contract-Tuple{MPO, MPO}","content":" NDTensors.contract  —  Method contract(A::MPO, B::MPO; kwargs...) -> MPO\n*(::MPO, ::MPO; kwargs...) -> MPO Contract the  MPO A  with the  MPO B , returning an  MPO  with the site indices that are not shared between  A  and  B . If you are contracting two MPOs with the same sets of indices, likely you want to call something like: C = contract(A', B; cutoff=1e-12)\nC = replaceprime(C, 2 => 1) That is because if MPO  A  has the index structure  -s'-A-s-  and MPO  B  has the Index structure  -s'-B-s- , if we only want to contract over on set of the indices, we would do  (-s'-A-s-)'-s'-B-s- = -s''-A-s'-s'-B-s- = -s''-C-s- , and then map the prime levels back to pairs of primed and unprimed indices with:  replaceprime(-s''-C-s-, 2 => 1) = -s'-C-s- . Since this is a common use case, you can use the convenience function: C = apply(A, B; cutoff=1e-12) which is the same as the code above. If you are contracting MPOs that have diverging norms, such as MPOs representing sums of local operators, the truncation can become numerically unstable (see https://arxiv.org/abs/1909.06341 for a more numerically stable alternative). For now, you can use the following options to contract MPOs like that: C = contract(A, B; alg=\"naive\", truncate=false)\n# Bring the indices back to pairs of primed and unprimed\nC = apply(A, B; alg=\"naive\", truncate=false) Keywords cutoff::Float64=1e-14 : the cutoff value for truncating the density matrix  eigenvalues. Note that the default is somewhat arbitrary and subject to change,  in general you should set a  cutoff  value. maxdim::Int=maxlinkdim(A) * maxlinkdim(B)) : the maximal bond dimension of the results MPS. mindim::Int=1 : the minimal bond dimension of the resulting MPS. alg=\"zipup\" : Either  \"zipup\"  or  \"naive\" .  \"zipup\"  contracts pairs of  site tensors and truncates with SVDs in a sweep across the sites, while  \"naive\"   first contracts pairs of tensor exactly and then truncates at the end if  truncate=true . truncate=true : Enable or disable truncation. If  truncate=false , ignore  other truncation parameters like  cutoff  and  maxdim . This is most relevant  for the  \"naive\"  version, if you just want to contract the tensors pairwise  exactly. This can be useful if you are contracting MPOs that have diverging  norms, such as MPOs originating from sums of local operators. See also  apply  for details about the arguments available. source"},{"id":393,"pagetitle":"MPS and MPO","title":"ITensors.apply","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.apply-Tuple{MPO, MPO}","content":" ITensors.apply  —  Method apply(A::MPO, B::MPO; kwargs...) Contract the  MPO A'  with the  MPO B  and then map the prime level of the resulting MPO back to having pairs of indices with prime levels of 1 and 0. Equivalent to  replaceprime(contract(A', B; kwargs...), 2 => 1) . See also  contract  for details about the arguments available. source"},{"id":394,"pagetitle":"MPS and MPO","title":"ITensorMPS.error_contract","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.error_contract-Tuple{MPS, MPO, MPS}","content":" ITensorMPS.error_contract  —  Method error_contract(y::MPS, A::MPO, x::MPS;\n               make_inds_match::Bool = true)\nerror_contract(y::MPS, x::MPS, A::MPO;\n               make_inds_match::Bool = true) Compute the distance between A|x> and an approximation MPS y:  | |y> - A|x> |/| A|x> | = √(1 + (<y|y> - 2*real(<y|A|x>))/<Ax|A|x>) . If  make_inds_match = true , the function attempts match the site indices of  y  with the site indices of  A  that are not common with  x . source"},{"id":395,"pagetitle":"MPS and MPO","title":"NDTensors.outer","ref":"/ITensorDocs/ITensorMPS/stable/#NDTensors.outer-Tuple{MPS, MPS}","content":" NDTensors.outer  —  Method outer(x::MPS, y::MPS; <keyword argument>) -> MPO Compute the outer product of  MPS x  and  MPS y , returning an  MPO  approximation. Note that  y  will be conjugated. In Dirac notation, this is the operation  |x⟩⟨y| . If you want an outer product of an MPS with itself, you should call  outer(x', x; kwargs...)  so that the resulting MPO has site indices with indices coming in pairs of prime levels of 1 and 0. If not, the site indices won't be unique which would not be an outer product. For example: s = siteinds(\"S=1/2\", 5)\nx = random_mps(s)\ny = random_mps(s)\nouter(x, y) # Incorrect! Site indices must be unique.\nouter(x', y) # Results in an MPO with pairs of primed and unprimed indices. This allows for more general outer products, such as more general MPO outputs which don't have pairs of primed and unprimed indices, or outer products where the input MPS are vectorizations of MPOs. For example: s = siteinds(\"S=1/2\", 5)\nX = MPO(s, \"Id\")\nY = MPO(s, \"Id\")\nx = convert(MPS, X)\ny = convert(MPS, Y)\nouter(x, y) # Incorrect! Site indices must be unique.\nouter(x', y) # Incorrect! Site indices must be unique.\nouter(addtags(x, \"Out\"), addtags(y, \"In\")) # This performs a proper outer product. The keyword arguments determine the truncation, and accept the same arguments as  contract(::MPO, ::MPO; kwargs...) . See also  apply ,  contract . source"},{"id":396,"pagetitle":"MPS and MPO","title":"ITensorMPS.projector","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.projector-Tuple{MPS}","content":" ITensorMPS.projector  —  Method projector(x::MPS; <keyword argument>) -> MPO Computes the projector onto the state  x . In Dirac notation, this is the operation  |x⟩⟨x|/|⟨x|x⟩|² . Use keyword arguments to control the level of truncation, which are the same as those accepted by  contract(::MPO, ::MPO; kw...) . Keywords normalize::Bool=true : whether or not to normalize the input MPS before  forming the projector. If  normalize==false  and the input MPS is not  already normalized, this function will not output a proper project, and  simply outputs  outer(x, x) = |x⟩⟨x| , i.e. the projector scaled by  norm(x)^2 . truncation keyword arguments accepted by  contract(::MPO, ::MPO; kw...) . See also  outer ,  contract . source"},{"id":399,"pagetitle":"Observer System for DMRG","title":"Observer System for DMRG","ref":"/ITensorDocs/ITensorMPS/stable/#observer","content":" Observer System for DMRG An observer is an object which can be passed to the ITensor DMRG algorithm, to allow measurements to be performed throughout the DMRG calculation and to set conditions for early stopping of DMRG. The only requirement of an observer is that it is a subtype of  AbstractObserver . But to do something interesting, it should also overload at least one the methods  measure!  or  checkdone! . A general purpose observer type called  DMRGObserver  is included with ITensors which already provides some quite useful features. It accepts a list of strings naming local operators to be measured at each step of DMRG, with the results saved for later analysis. It also accepts an optional energy precision, and stops a DMRG calculation early if the energy no longer changes to this precision. For more details about the  DMRGObserver  type, see the  DMRGObserver  documentation page."},{"id":400,"pagetitle":"Observer System for DMRG","title":"Defining a Custom Observer","ref":"/ITensorDocs/ITensorMPS/stable/#Defining-a-Custom-Observer","content":" Defining a Custom Observer To define a custom observer, just make a struct with any name and internal fields you would like, and make this struct a subtype of  AbstractObserver . For example, let's make a type called  DemoObserver  as: using ITensors, ITensorMPS\n\nmutable struct DemoObserver <: AbstractObserver\n   energy_tol::Float64\n   last_energy::Float64\n\n   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)\nend\n In this minimal example, our  DemoObserver  contains a field  energy_tol  which we can use to set an early-stopping condition for DMRG, and an field  last_energy  which our observer will use internally to keep track of changes to the energy after each sweep. Now to give our  DemoObserver  type a useful behavior we need to define overloads of the methods  measure!  and  checkdone! ."},{"id":401,"pagetitle":"Observer System for DMRG","title":"Overloading the checkdone! method","ref":"/ITensorDocs/ITensorMPS/stable/#Overloading-the-checkdone!-method","content":" Overloading the  checkdone!  method Let's start with the  checkdone!  method. After each sweep of DMRG, the  checkdone!  method is passed the observer object, as well as a set of keyword arguments which currently include: energy: the current energy psi: the current wavefunction MPS sweep: the number of the sweep that just finished outputlevel: an integer stating the desired level of output If the  checkdone!  function returns  true , then the DMRG routine stops (recall that  checkdone!  is called only at the end of a sweep). In our example, we will just compare the  energy  keyword argument to the  last_energy  variable held inside the  DemoObserver : function ITensorMPS.checkdone!(o::DemoObserver;kwargs...)\n  sw = kwargs[:sweep]\n  energy = kwargs[:energy]\n  if abs(energy-o.last_energy)/abs(energy) < o.energy_tol\n    println(\"Stopping DMRG after sweep $sw\")\n    return true\n  end\n  # Otherwise, update last_energy and keep going\n  o.last_energy = energy\n  return false\nend (Recall that in order to properly overload the default behavior, the  checkdone!  method has to be imported from the ITensorMPS module or preceded with  ITensorsMPS. )"},{"id":402,"pagetitle":"Observer System for DMRG","title":"Overloading the measure! method","ref":"/ITensorDocs/ITensorMPS/stable/#Overloading-the-measure!-method","content":" Overloading the  measure!  method The other method that an observer can overload is  measure! . This method is called at every step of DMRG, so at every site and for every sweep. The  measure!  method is passed the current observer object and a set of keyword arguments which include: energy: the energy after the current step of DMRG psi: the current wavefunction MPS bond: the bond  b  that was just optimized, corresponding to sites  (b,b+1)  in the two-site DMRG algorithm sweep: the current sweep number sweep_is_done: true if at the end of the current sweep, otherwise false half_sweep: the half-sweep number, equal to 1 for a left-to-right, first half sweep, or 2 for the second, right-to-left half sweep spec: the Spectrum object returned from factorizing the local superblock wavefunction tensor in two-site DMRG outputlevel: an integer specifying the amount of output to show projected_operator: projection of the linear operator into the current MPS basis For our minimal  DemoObserver  example here, we will just make a  measure!  function that prints out some of the information above, but in a more realistic setting one could use the MPS  psi  to perform essentially arbitrary measurements. function ITensorMPS.measure!(o::DemoObserver; kwargs...)\n  energy = kwargs[:energy]\n  sweep = kwargs[:sweep]\n  bond = kwargs[:bond]\n  outputlevel = kwargs[:outputlevel]\n\n  if outputlevel > 0\n    println(\"Sweep $sweep at bond $bond, the energy is $energy\")\n  end\nend"},{"id":403,"pagetitle":"Observer System for DMRG","title":"Calling DMRG with the Custom Observer","ref":"/ITensorDocs/ITensorMPS/stable/#Calling-DMRG-with-the-Custom-Observer","content":" Calling DMRG with the Custom Observer After defining an observer type and overloading at least one of the methods  checkdone!  or  measure!  for it, one can construct an object of this type and pass it to the ITensor  dmrg  function using the  observer  keyword argument. Continuing with our  DemoObserver  example above: obs = DemoObserver(1E-4) # use an energy tolerance of 1E-4\nenergy, psi = dmrg(H,psi0,sweeps; observer=obs, outputlevel=1)"},{"id":404,"pagetitle":"Observer System for DMRG","title":"Complete Sample Code","ref":"/ITensorDocs/ITensorMPS/stable/#Complete-Sample-Code","content":" Complete Sample Code using ITensors, ITensorMPS\n\nmutable struct DemoObserver <: AbstractObserver\n   energy_tol::Float64\n   last_energy::Float64\n\n   DemoObserver(energy_tol=0.0) = new(energy_tol,1000.0)\nend\n\nfunction ITensorMPS.checkdone!(o::DemoObserver;kwargs...)\n  sw = kwargs[:sweep]\n  energy = kwargs[:energy]\n  if abs(energy-o.last_energy)/abs(energy) < o.energy_tol\n    println(\"Stopping DMRG after sweep $sw\")\n    return true\n  end\n  # Otherwise, update last_energy and keep going\n  o.last_energy = energy\n  return false\nend\n\nfunction ITensorMPS.measure!(o::DemoObserver; kwargs...)\n  energy = kwargs[:energy]\n  sweep = kwargs[:sweep]\n  bond = kwargs[:bond]\n  outputlevel = kwargs[:outputlevel]\n\n  if outputlevel > 0\n    println(\"Sweep $sweep at bond $bond, the energy is $energy\")\n  end\nend\n\nlet\n  N = 10\n  etol = 1E-4\n\n  s = siteinds(\"S=1/2\",N)\n\n  a = OpSum()\n  for n=1:N-1\n    a += \"Sz\",n,\"Sz\",n+1\n    a += 0.5,\"S+\",n,\"S-\",n+1\n    a += 0.5,\"S-\",n,\"S+\",n+1\n  end\n  H = MPO(a,s)\n  psi0 = random_mps(s;linkdims=4)\n\n  nsweeps = 5\n  cutoff = 1E-8\n  maxdim = [10,20,100]\n\n  obs = DemoObserver(etol)\n\n  println(\"Starting DMRG\")\n  energy, psi = dmrg(H,psi0; nsweeps, cutoff, maxdim, observer=obs, outputlevel=1)\n\n  return\nend"},{"id":407,"pagetitle":"OpSum","title":"OpSum","ref":"/ITensorDocs/ITensorMPS/stable/#OpSum","content":" OpSum"},{"id":408,"pagetitle":"OpSum","title":"Description","ref":"/ITensorDocs/ITensorMPS/stable/#Description","content":" Description"},{"id":409,"pagetitle":"OpSum","title":"ITensors.Ops.OpSum","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.Ops.OpSum","content":" ITensors.Ops.OpSum  —  Type An  OpSum  represents a sum of operator terms. Often it is used to create matrix product operator ( MPO ) approximation of the sum of the terms in the  OpSum  oject. Each term is a product of local operators specified by names such as  \"Sz\"  or  \"N\" , times an optional coefficient which can be real or complex. Which local operator names are available is determined by the function  op  associated with the  TagType  defined by special Index tags, such as  \"S=1/2\" ,  \"S=1\" ,  \"Fermion\" , and  \"Electron\" . source"},{"id":410,"pagetitle":"OpSum","title":"Methods","ref":"/ITensorDocs/ITensorMPS/stable/#Methods","content":" Methods"},{"id":411,"pagetitle":"OpSum","title":"ITensorMPS.add!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.add!","content":" ITensorMPS.add!  —  Function add!(opsum::OpSum,\n     op1::String, i1::Int)\n\nadd!(opsum::OpSum,\n     coef::Number,\n     op1::String, i1::Int)\n\nadd!(opsum::OpSum,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\nadd!(opsum::OpSum,\n     coef::Number,\n     op1::String, i1::Int,\n     op2::String, i2::Int,\n     ops...)\n\n+(opsum:OpSum, term::Tuple) Add a single- or multi-site operator term to the OpSum  opsum . Each operator is specified by a name (String) and a site number (Int). The second version accepts a real or complex coefficient. The  +  operator version of this function accepts a tuple with entries either (String,Int,String,Int,...) or (Number,String,Int,String,Int,...) where these tuple values are the same as valid inputs to the  add!  function. For inputting a very large number of terms (tuples) to an OpSum, consider using the broadcasted operator  .+=  which avoids reallocating the OpSum after each addition. Examples opsum = OpSum()\n\nadd!(opsum,\"Sz\",2,\"Sz\",3)\n\nopsum += (\"Sz\",3,\"Sz\",4)\n\nopsum += (0.5,\"S+\",4,\"S-\",5)\n\nopsum .+= (0.5,\"S+\",5,\"S-\",6) source"},{"id":412,"pagetitle":"OpSum","title":"ITensorMPS.MPO","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.MPO-Tuple{ITensors.LazyApply.Applied{typeof(sum), Tuple{Array{ITensors.LazyApply.Applied{typeof(*), Tuple{C, Prod{Op}}, @NamedTuple{}}, 1}}, @NamedTuple{}} where C, Vector{<:Index}}","content":" ITensorMPS.MPO  —  Method MPO(os::OpSum, sites::Vector{<:Index}; splitblocks=true, kwargs...)\nMPO(eltype::Type{<:Number}, os::OpSum, sites::Vector{<:Index}; splitblocks=true, kwargs...) Convert an OpSum object  os  to an MPO, with indices given by  sites . The resulting MPO will have the indices  sites[1], sites[1]', sites[2], sites[2]'  etc. The conversion is done by an algorithm that compresses the MPO resulting from adding the OpSum terms together, often achieving the minimum possible bond dimension. Optionally specify the desired element type of the output MPO by passing the type as the first argument. The keyword argument  splitblocks  controls the sparsity of the resulting MPO. With the default  splitblocks=true , the link indices of the MPO are split into blocks of dimension 1, potentially making the MPO more sparse. With the  splitblocks=false , the blocks of the link dimensions are packed as much as possible according to common quantum numbers, making larger blocks. Before ITensors 0.3.19, this was the default output, but we have found that in general MPOs output with  splitblocks=true  lead to better performance in algorithms like DMRG. Examples os = OpSum()\nos += \"Sz\",1,\"Sz\",2\nos += \"Sz\",2,\"Sz\",3\nos += \"Sz\",3,\"Sz\",4\n\nsites = siteinds(\"S=1/2\",4)\nH = MPO(os,sites)\nH = MPO(Float32,os,sites)\nH = MPO(os,sites; splitblocks=false) source"},{"id":415,"pagetitle":"ProjMPO","title":"ProjMPO","ref":"/ITensorDocs/ITensorMPS/stable/#ProjMPO","content":" ProjMPO"},{"id":416,"pagetitle":"ProjMPO","title":"Description","ref":"/ITensorDocs/ITensorMPS/stable/#Description","content":" Description"},{"id":417,"pagetitle":"ProjMPO","title":"ITensorMPS.ProjMPO","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.ProjMPO","content":" ITensorMPS.ProjMPO  —  Type A ProjMPO computes and stores the projection of an MPO into a basis defined by an MPS, leaving a certain number of site indices of the MPO unprojected. Which sites are unprojected can be shifted by calling the  position!  method. Drawing of the network represented by a ProjMPO  P(H) , showing the case of  nsite(P)==2  and  position!(P,psi,4)  for an MPS  psi : o--o--o-      -o--o--o--o--o--o <psi|\n|  |  |  |  |  |  |  |  |  |  |\no--o--o--o--o--o--o--o--o--o--o H\n|  |  |  |  |  |  |  |  |  |  |\no--o--o-      -o--o--o--o--o--o |psi> source"},{"id":418,"pagetitle":"ProjMPO","title":"Methods","ref":"/ITensorDocs/ITensorMPS/stable/#Methods","content":" Methods"},{"id":419,"pagetitle":"ProjMPO","title":"ITensors.product","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.product-Tuple{ProjMPO, ITensor}","content":" ITensors.product  —  Method product(P::ProjMPO,v::ITensor)::ITensor\n\n(P::ProjMPO)(v::ITensor) Efficiently multiply the ProjMPO  P  by an ITensor  v  in the sense that the ProjMPO is a generalized square matrix or linear operator and  v  is a generalized vector in the space where it acts. The returned ITensor will have the same indices as  v . The operator overload  P(v)  is shorthand for  product(P,v) . source"},{"id":420,"pagetitle":"ProjMPO","title":"ITensorMPS.position!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.position!-Tuple{ProjMPO, MPS, Int64}","content":" ITensorMPS.position!  —  Method position!(P::ProjMPO, psi::MPS, pos::Int) Given an MPS  psi , shift the projection of the MPO represented by the ProjMPO  P  such that the set of unprojected sites begins with site  pos . This operation efficiently reuses previous projections of the MPO on sites that have already been projected. The MPS  psi  must have compatible bond indices with the previous projected MPO tensors for this operation to succeed. source"},{"id":421,"pagetitle":"ProjMPO","title":"ITensorMPS.noiseterm","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.noiseterm-Tuple{ProjMPO, ITensor, String}","content":" ITensorMPS.noiseterm  —  Method noiseterm(P::ProjMPO,\n          phi::ITensor,\n          ortho::String) Return a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor  phi  is the contracted product of MPS tensors acted on by the ProjMPO  P , and  ortho  is a String which can take the values  \"left\"  or  \"right\"  depending on the sweeping direction of the DMRG calculation. source"},{"id":422,"pagetitle":"ProjMPO","title":"Properties","ref":"/ITensorDocs/ITensorMPS/stable/#Properties","content":" Properties"},{"id":423,"pagetitle":"ProjMPO","title":"Base.length","ref":"/ITensorDocs/ITensorMPS/stable/#Base.length-Tuple{ProjMPO}","content":" Base.length  —  Method length(P::ProjMPO) The length of a ProjMPO is the same as the length of the MPO used to construct it source"},{"id":424,"pagetitle":"ProjMPO","title":"Base.eltype","ref":"/ITensorDocs/ITensorMPS/stable/#Base.eltype-Tuple{ProjMPO}","content":" Base.eltype  —  Method eltype(P::ProjMPO) Deduce the element type (such as Float64 or ComplexF64) of the tensors in the ProjMPO  P . source"},{"id":425,"pagetitle":"ProjMPO","title":"Base.size","ref":"/ITensorDocs/ITensorMPS/stable/#Base.size-Tuple{ProjMPO}","content":" Base.size  —  Method size(P::ProjMPO) The size of a ProjMPO are its dimensions  (d,d)  when viewed as a matrix or linear operator acting on a space of dimension  d . For example, if a ProjMPO maps from a space with indices  (a,s1,s2,b)  to the space  (a',s1',s2',b')  then the size is  (d,d)  where  d = dim(a)*dim(s1)*dim(s1)*dim(b) source"},{"id":428,"pagetitle":"ProjMPOSum","title":"ProjMPOSum","ref":"/ITensorDocs/ITensorMPS/stable/#ProjMPOSum","content":" ProjMPOSum"},{"id":429,"pagetitle":"ProjMPOSum","title":"Description","ref":"/ITensorDocs/ITensorMPS/stable/#Description","content":" Description"},{"id":430,"pagetitle":"ProjMPOSum","title":"ITensorMPS.ProjMPOSum","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.ProjMPOSum","content":" ITensorMPS.ProjMPOSum  —  Type A ProjMPOSum computes and stores the projection of an implied sum of MPOs into a basis defined by an MPS, leaving a certain number of site indices of each MPO unprojected. Which sites are unprojected can be shifted by calling the  position!  method. The MPOs used as input to a ProjMPOSum are  not  added together beforehand; instead when the  product  method of a ProjMPOSum is invoked, each projected MPO in the set of MPOs is multiplied by the input tensor one-by-one in an efficient way. Drawing of the network represented by a ProjMPOSum  P([H1,H2,...]) , showing the case of  nsite(P)==2  and  position!(P,psi,4)  for an MPS  psi  (note the sum Σⱼ on the left):      o--o--o-      -o--o--o--o--o--o <psi|\n     |  |  |  |  |  |  |  |  |  |  |\n Σⱼ  o--o--o--o--o--o--o--o--o--o--o Hⱼ\n     |  |  |  |  |  |  |  |  |  |  |\n     o--o--o-      -o--o--o--o--o--o |psi> source"},{"id":431,"pagetitle":"ProjMPOSum","title":"Methods","ref":"/ITensorDocs/ITensorMPS/stable/#Methods","content":" Methods"},{"id":432,"pagetitle":"ProjMPOSum","title":"ITensors.product","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.product-Tuple{ProjMPOSum, ITensor}","content":" ITensors.product  —  Method product(P::ProjMPOSum,v::ITensor)\n\n(P::ProjMPOSum)(v::ITensor) Efficiently multiply the ProjMPOSum  P  by an ITensor  v  in the sense that the ProjMPOSum is a generalized square matrix or linear operator and  v  is a generalized vector in the space where it acts. The returned ITensor will have the same indices as  v . The operator overload  P(v)  is shorthand for  product(P,v) . source"},{"id":433,"pagetitle":"ProjMPOSum","title":"ITensorMPS.position!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.position!-Tuple{ProjMPOSum, MPS, Int64}","content":" ITensorMPS.position!  —  Method position!(P::ProjMPOSum, psi::MPS, pos::Int) Given an MPS  psi , shift the projection of the MPO represented by the ProjMPOSum  P  such that the set of unprojected sites begins with site  pos . This operation efficiently reuses previous projections of the MPOs on sites that have already been projected. The MPS  psi  must have compatible bond indices with the previous projected MPO tensors for this operation to succeed. source"},{"id":434,"pagetitle":"ProjMPOSum","title":"ITensorMPS.noiseterm","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.noiseterm-Tuple{ProjMPOSum, ITensor, String}","content":" ITensorMPS.noiseterm  —  Method noiseterm(P::ProjMPOSum,\n          phi::ITensor,\n          ortho::String) Return a \"noise term\" or density matrix perturbation ITensor as proposed in Phys. Rev. B 72, 180403 for aiding convergence of DMRG calculations. The ITensor  phi  is the contracted product of MPS tensors acted on by the ProjMPOSum  P , and  ortho  is a String which can take the values  \"left\"  or  \"right\"  depending on the sweeping direction of the DMRG calculation. source"},{"id":435,"pagetitle":"ProjMPOSum","title":"Properties","ref":"/ITensorDocs/ITensorMPS/stable/#Properties","content":" Properties"},{"id":436,"pagetitle":"ProjMPOSum","title":"Base.eltype","ref":"/ITensorDocs/ITensorMPS/stable/#Base.eltype-Tuple{ProjMPOSum}","content":" Base.eltype  —  Method eltype(P::ProjMPOSum) Deduce the element type (such as Float64 or ComplexF64) of the tensors in the ProjMPOSum  P . source"},{"id":437,"pagetitle":"ProjMPOSum","title":"Base.size","ref":"/ITensorDocs/ITensorMPS/stable/#Base.size-Tuple{ProjMPOSum}","content":" Base.size  —  Method size(P::ProjMPOSum) The size of a ProjMPOSum are its dimensions  (d,d)  when viewed as a matrix or linear operator acting on a space of dimension  d . For example, if a ProjMPOSum maps from a space with indices  (a,s1,s2,b)  to the space  (a',s1',s2',b')  then the size is  (d,d)  where  d = dim(a)*dim(s1)*dim(s1)*dim(b) source"},{"id":440,"pagetitle":"SiteType and op, state, val functions","title":"SiteType and op, state, val functions","ref":"/ITensorDocs/ITensorMPS/stable/#SiteType-and-op,-state,-val-functions","content":" SiteType and op, state, val functions"},{"id":441,"pagetitle":"SiteType and op, state, val functions","title":"Description","ref":"/ITensorDocs/ITensorMPS/stable/#Description","content":" Description"},{"id":442,"pagetitle":"SiteType and op, state, val functions","title":"ITensors.SiteTypes.SiteType","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.SiteType","content":" ITensors.SiteTypes.SiteType  —  Type SiteType is a parameterized type which allows making Index tags into Julia types. Use cases include overloading functions such as  op ,  siteinds , and  state  which generate custom operators, Index arrays, and IndexVals associated with Index objects having a certain tag. To make a SiteType type, you can use the string macro notation:  SiteType\"MyTag\" To make a SiteType value or object, you can use the notation:  SiteType(\"MyTag\") There are currently a few built-in site types recognized by  jl . The system is easily extensible by users. To add new operators to an existing site type, or to create new site types, you can follow the instructions  here . The current built-in site types are: SiteType\"S=1/2\"  (or  SiteType\"S=½\" ) SiteType\"S=1\" SiteType\"Qubit\" SiteType\"Qudit\" SiteType\"Boson\" SiteType\"Fermion\" SiteType\"tJ\" SiteType\"Electron\" Examples Tags on indices get turned into SiteTypes internally, and then we search for overloads of functions like  op  and  siteind . For example: julia> s = siteind(\"S=1/2\")\n(dim=2|id=862|\"S=1/2,Site\")\n\njulia> @show op(\"Sz\", s);\nop(s, \"Sz\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.5   0.0\n 0.0  -0.5\n\njulia> @show op(\"Sx\", s);\nop(s, \"Sx\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 2×2\n 0.0  0.5\n 0.5  0.0\n\njulia> @show op(\"Sy\", s);\nop(s, \"Sy\") = ITensor ord=2\nDim 1: (dim=2|id=862|\"S=1/2,Site\")'\nDim 2: (dim=2|id=862|\"S=1/2,Site\")\nNDTensors.Dense{Complex{Float64},Array{Complex{Float64},1}}\n 2×2\n 0.0 + 0.0im  -0.0 - 0.5im\n 0.0 + 0.5im   0.0 + 0.0im\n\njulia> s = siteind(\"Electron\")\n(dim=4|id=734|\"Electron,Site\")\n\njulia> @show op(\"Nup\", s);\nop(s, \"Nup\") = ITensor ord=2\nDim 1: (dim=4|id=734|\"Electron,Site\")'\nDim 2: (dim=4|id=734|\"Electron,Site\")\nNDTensors.Dense{Float64,Array{Float64,1}}\n 4×4\n 0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0 Many operators are available, for example: SiteType\"S=1/2\" :  \"Sz\" ,  \"Sx\" ,  \"Sy\" ,  \"S+\" ,  \"S-\" , ... SiteType\"Electron\" :  \"Nup\" ,  \"Ndn\" ,  \"Nupdn\" ,  \"Ntot\" ,  \"Cup\" ,   \"Cdagup\" ,  \"Cdn\" ,  \"Cdagdn\" ,  \"Sz\" ,  \"Sx\" ,  \"Sy\" ,  \"S+\" ,  \"S-\" , ... ... You can view the internal SiteType definitions and operators  here . source"},{"id":443,"pagetitle":"SiteType and op, state, val functions","title":"Methods","ref":"/ITensorDocs/ITensorMPS/stable/#Methods","content":" Methods"},{"id":444,"pagetitle":"SiteType and op, state, val functions","title":"ITensors.SiteTypes.op","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.op","content":" ITensors.SiteTypes.op  —  Function op(opname::String, s::Index; kwargs...) Return an ITensor corresponding to the operator named  opname  for the Index  s . The operator is constructed by calling an overload of either the  op  or  op!  methods which take a  SiteType  argument that corresponds to one of the tags of the Index  s  and an  OpName\"opname\"  argument that corresponds to the input operator name. Operator names can be combined using the  \"*\"  symbol, for example  \"S+*S-\"  or  \"Sz*Sz*Sz\" . The result is an ITensor made by forming each operator then contracting them together in a way corresponding to the usual operator product or matrix multiplication. The  op  system is used by the OpSum system to convert operator names into ITensors, and can be used directly such as for applying operators to MPS. Example s = Index(2, \"Site,S=1/2\")\nSz = op(\"Sz\", s) You can see all of the operator names defined for the site types included with ITensor  here . Note that some site types such as \"S=1/2\" and \"Qubit\" are aliases for each other and share operator definitions. source op(X::AbstractArray, s::Index...)\nop(M::Matrix, s::Index...) Given a matrix M and a set of indices s,t,... return an operator ITensor with matrix elements given by M and indices s, s', t, t' Example julia> s = siteind(\"S=1/2\")\n(dim=2|id=575|\"S=1/2,Site\")\n\njulia> Sz = op([1/2 0; 0 -1/2],s)\nITensor ord=2 (dim=2|id=575|\"S=1/2,Site\")' (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n\njulia> @show Sz\nSz = ITensor ord=2\nDim 1: (dim=2|id=575|\"S=1/2,Site\")'\nDim 2: (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}}\n 2×2\n 0.5   0.0\n 0.0  -0.5\nITensor ord=2 (dim=2|id=575|\"S=1/2,Site\")' (dim=2|id=575|\"S=1/2,Site\")\nNDTensors.Dense{Float64, Vector{Float64}} source op(opname::String,sites::Vector{<:Index},n::Int; kwargs...) Return an ITensor corresponding to the operator named  opname  for the n'th Index in the array  sites . Example s = siteinds(\"S=1/2\", 4)\nSz2 = op(\"Sz\", s, 2) source"},{"id":445,"pagetitle":"SiteType and op, state, val functions","title":"ITensors.SiteTypes.state","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.SiteTypes.state","content":" ITensors.SiteTypes.state  —  Function state(s::Index, name::String; kwargs...) Return an ITensor corresponding to the state named  name  for the Index  s . The returned ITensor will have  s  as its only index. The terminology here is based on the idea of a single-site state or wavefunction in physics. The  state  function is implemented for various Index tags by overloading either the  state  or  state!  methods which take a  SiteType  argument corresponding to one of the tags of the Index  s  and an  StateName\"name\"  argument that corresponds to the input state name. The  state  system is used by the MPS type to construct product-state MPS and for other purposes. Example s = Index(2, \"Site,S=1/2\")\nsup = state(s,\"Up\")\nsdn = state(s,\"Dn\")\nsxp = state(s,\"X+\")\nsxm = state(s,\"X-\") source"},{"id":446,"pagetitle":"SiteType and op, state, val functions","title":"ITensors.val","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.val","content":" ITensors.val  —  Function val(q::QN,name) Get the value within the QN q corresponding to the string  name source val(s::Index, name::String) Return an integer corresponding to the  name  of a certain value the Index  s  can take. In other words, the  val  function maps strings to specific integer values within the range  1:dim(s) . The  val  function is implemented for various Index tags by overloading methods named  val  which take a  SiteType  argument corresponding to one of the tags of the Index  s  and an  ValName\"name\"  argument that corresponds to the input name. Example s = Index(2, \"Site,S=1/2\")\nval(s,\"Up\") == 1\nval(s,\"Dn\") == 2\n\ns = Index(2, \"Site,Fermion\")\nval(s,\"Emp\") == 1\nval(s,\"Occ\") == 2 source"},{"id":447,"pagetitle":"SiteType and op, state, val functions","title":"ITensors.space","ref":"/ITensorDocs/ITensorMPS/stable/#ITensors.space","content":" ITensors.space  —  Function space(::SiteType\"Qubit\";\n      conserve_qns = false,\n      conserve_parity = conserve_qns,\n      conserve_number = false,\n      qnname_parity = \"Parity\",\n      qnname_number = \"Number\") Create the Hilbert space for a site of type \"Qubit\". Optionally specify the conserved symmetries and their quantum number labels. source space(::SiteType\"S=1/2\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_szparity = false,\n      qnname_sz = \"Sz\",\n      qnname_szparity = \"SzParity\") Create the Hilbert space for a site of type \"S=1/2\". Optionally specify the conserved symmetries and their quantum number labels. source space(::SiteType\"S=1\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      qnname_sz = \"Sz\") Create the Hilbert space for a site of type \"S=1\". Optionally specify the conserved symmetries and their quantum number labels. source space(::SiteType\"Fermion\";\n      conserve_qns=false,\n      conserve_nf=conserve_qns,\n      conserve_nfparity=conserve_qns,\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\",\n      qnname_sz = \"Sz\",\n      conserve_sz = false) Create the Hilbert space for a site of type \"Fermion\". Optionally specify the conserved symmetries and their quantum number labels. source space(::SiteType\"Electron\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_nf = conserve_qns,\n      conserve_nfparity = conserve_qns,\n      qnname_sz = \"Sz\",\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\") Create the Hilbert space for a site of type \"Electron\". Optionally specify the conserved symmetries and their quantum number labels. source space(::SiteType\"tJ\";\n      conserve_qns = false,\n      conserve_sz = conserve_qns,\n      conserve_nf = conserve_qns,\n      conserve_nfparity = conserve_qns,\n      qnname_sz = \"Sz\",\n      qnname_nf = \"Nf\",\n      qnname_nfparity = \"NfParity\") Create the Hilbert space for a site of type \"tJ\". Optionally specify the conserved symmetries and their quantum number labels. source space(::SiteType\"Qudit\";\n      dim = 2,\n      conserve_qns = false,\n      conserve_number = false,\n      qnname_number = \"Number\") Create the Hilbert space for a site of type \"Qudit\". Optionally specify the conserved symmetries and their quantum number labels. source space(::SiteType\"Boson\";\n      dim = 2,\n      conserve_qns = false,\n      conserve_number = false,\n      qnname_number = \"Number\") Create the Hilbert space for a site of type \"Boson\". Optionally specify the conserved symmetries and their quantum number labels. source"},{"id":450,"pagetitle":"Sweeps","title":"Sweeps","ref":"/ITensorDocs/ITensorMPS/stable/#Sweeps","content":" Sweeps"},{"id":451,"pagetitle":"Sweeps","title":"ITensorMPS.Sweeps","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.Sweeps","content":" ITensorMPS.Sweeps  —  Type A Sweeps objects holds information about the various parameters controlling a density matrix renormalization group (DMRG) or similar matrix product state (MPS) calculation. For a Sweeps object  sw  the available parameters are: nsweep(sw)  – the number of sweeps to do maxdim(sw,n)  – maximum MPS bond dimension for sweep n mindim(sw,n)  – minimum MPS bond dimension for sweep n cutoff(sw,n)  – truncation error cutoff for sweep n noise(sw,n)  – noise term coefficient for sweep n source"},{"id":452,"pagetitle":"Sweeps","title":"ITensorMPS.Sweeps","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.Sweeps-Tuple{Int64, AbstractMatrix}","content":" ITensorMPS.Sweeps  —  Method Sweeps(d::AbstractMatrix)\n\nSweeps(nsweep::Int, d::AbstractMatrix) Make a sweeps object from a matrix of input values. The first row should be strings that define which variables are being set (\"maxdim\", \"cutoff\", \"mindim\", and \"noise\"). If the number of sweeps are not specified, they are determined from the size of the input matrix. Examples julia > Sweeps(\n  [\n    \"maxdim\" \"mindim\" \"cutoff\" \"noise\"\n    50 10 1e-12 1E-7\n    100 20 1e-12 1E-8\n    200 20 1e-12 1E-10\n    400 20 1e-12 0\n    800 20 1e-12 1E-11\n    800 20 1e-12 0\n  ],\n)\nSweeps\n1cutoff = 1.0E-12, maxdim = 50, mindim = 10, noise = 1.0E-07\n2cutoff = 1.0E-12, maxdim = 100, mindim = 20, noise = 1.0E-08\n3cutoff = 1.0E-12, maxdim = 200, mindim = 20, noise = 1.0E-10\n4cutoff = 1.0E-12, maxdim = 400, mindim = 20, noise = 0.0E+00\n5cutoff = 1.0E-12, maxdim = 800, mindim = 20, noise = 1.0E-11\n6cutoff = 1.0E-12, maxdim = 800, mindim = 20, noise = 0.0E+00 source"},{"id":453,"pagetitle":"Sweeps","title":"Modifying Sweeps Objects","ref":"/ITensorDocs/ITensorMPS/stable/#Modifying-Sweeps-Objects","content":" Modifying Sweeps Objects"},{"id":454,"pagetitle":"Sweeps","title":"ITensorMPS.setmaxdim!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.setmaxdim!","content":" ITensorMPS.setmaxdim!  —  Function maxdim!(sw::Sweeps,maxdims::Int...) Set the maximum MPS bond dimension for each sweep by providing up to  nsweep(sw)  values. If fewer values are provided, the last value is repeated for the remaining sweeps. source"},{"id":455,"pagetitle":"Sweeps","title":"ITensorMPS.setcutoff!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.setcutoff!","content":" ITensorMPS.setcutoff!  —  Function cutoff!(sw::Sweeps,maxdims::Int...) Set the MPS truncation error used for each sweep by providing up to  nsweep(sw)  values. If fewer values are provided, the last value is repeated for the remaining sweeps. source"},{"id":456,"pagetitle":"Sweeps","title":"ITensorMPS.setnoise!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.setnoise!","content":" ITensorMPS.setnoise!  —  Function noise!(sw::Sweeps,maxdims::Int...) Set the noise-term coefficient used for each sweep by providing up to  nsweep(sw)  values. If fewer values are provided, the last value is repeated for the remaining sweeps. source"},{"id":457,"pagetitle":"Sweeps","title":"ITensorMPS.setmindim!","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.setmindim!","content":" ITensorMPS.setmindim!  —  Function mindim!(sw::Sweeps,maxdims::Int...) Set the minimum MPS bond dimension for each sweep by providing up to  nsweep(sw)  values. If fewer values are provided, the last value is repeated for the remaining sweeps. source"},{"id":458,"pagetitle":"Sweeps","title":"Getting Sweeps Object Data","ref":"/ITensorDocs/ITensorMPS/stable/#Getting-Sweeps-Object-Data","content":" Getting Sweeps Object Data"},{"id":459,"pagetitle":"Sweeps","title":"ITensorMPS.nsweep","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.nsweep-Tuple{Sweeps}","content":" ITensorMPS.nsweep  —  Method nsweep(sw::Sweeps)\nlength(sw::Sweeps) Obtain the number of sweeps parameterized by this sweeps object. source"},{"id":460,"pagetitle":"Sweeps","title":"NDTensors.maxdim","ref":"/ITensorDocs/ITensorMPS/stable/#NDTensors.maxdim-Tuple{Sweeps, Int64}","content":" NDTensors.maxdim  —  Method maxdim(sw::Sweeps,n::Int) Maximum MPS bond dimension allowed by the Sweeps object  sw  during sweep  n source"},{"id":461,"pagetitle":"Sweeps","title":"ITensorMPS.cutoff","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.cutoff-Tuple{Sweeps, Int64}","content":" ITensorMPS.cutoff  —  Method cutoff(sw::Sweeps,n::Int) Truncation error cutoff setting of the Sweeps object  sw  during sweep  n source"},{"id":462,"pagetitle":"Sweeps","title":"ITensorMPS.noise","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.noise-Tuple{Sweeps, Int64}","content":" ITensorMPS.noise  —  Method noise(sw::Sweeps,n::Int) Noise term coefficient setting of the Sweeps object  sw  during sweep  n source"},{"id":463,"pagetitle":"Sweeps","title":"NDTensors.mindim","ref":"/ITensorDocs/ITensorMPS/stable/#NDTensors.mindim-Tuple{Sweeps, Int64}","content":" NDTensors.mindim  —  Method mindim(sw::Sweeps,n::Int) Minimum MPS bond dimension allowed by the Sweeps object  sw  during sweep  n source"},{"id":466,"pagetitle":"Home","title":"ITensorMPS.jl","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.jl","content":" ITensorMPS.jl Finite MPS and MPO methods based on the Julia version of  ITensor  ( ITensors.jl ). See the  ITensorMPS.jl documentation  for more details."},{"id":467,"pagetitle":"Home","title":"Support","ref":"/ITensorDocs/ITensorMPS/stable/#Support","content":" Support ITensorMPS.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":468,"pagetitle":"Home","title":"News","ref":"/ITensorDocs/ITensorMPS/stable/#News","content":" News"},{"id":469,"pagetitle":"Home","title":"ITensorMPS.jl v0.3 release notes","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.jl-v0.3-release-notes","content":" ITensorMPS.jl v0.3 release notes All MPS/MPO code from  ITensors.jl  and  ITensorTDVP.jl  has been moved into this repository and this repository now relies on ITensors.jl v0.7 and above. All of the MPS/MPO functionality that was previously in ITensors.jl and ITensorTDVP.jl will be developed here from now on. For users of this repository, this change should not break any code, though please let us know if you have any issues."},{"id":470,"pagetitle":"Home","title":"Upgrade guide","ref":"/ITensorDocs/ITensorMPS/stable/#Upgrade-guide","content":" Upgrade guide If you are using any MPS/MPO functionality of ITensors.jl, such as the  MPS  and  MPO  types or constructors thereof (like  random_mps ),  OpSum ,  siteinds ,  dmrg ,  apply , etc. you should install the ITensorMPS.jl package with  import Pkg; Pkg.add(\"ITensorMPS\")  and add  using ITensorMPS  to your code. Additionally, if you are currently using  ITensorTDVP.jl , you should replace  using ITensorTDVP  with  using ITensorMPS  in your code."},{"id":471,"pagetitle":"Home","title":"ITensorMPS.jl v0.2.1 release notes","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.jl-v0.2.1-release-notes","content":" ITensorMPS.jl v0.2.1 release notes"},{"id":472,"pagetitle":"Home","title":"New features","ref":"/ITensorDocs/ITensorMPS/stable/#New-features","content":" New features This release introduces a new (experimental) function  expand  for performing global Krylov expansion based on  arXiv:2005.06104 . It is a re-export of the  expand  function introduced in ITensorTDVP.jl v0.4.1, see the  ITensorTDVP.jl v0.4.1 release notes  for more details."},{"id":473,"pagetitle":"Home","title":"ITensorMPS.jl v0.2 release notes","ref":"/ITensorDocs/ITensorMPS/stable/#ITensorMPS.jl-v0.2-release-notes","content":" ITensorMPS.jl v0.2 release notes"},{"id":474,"pagetitle":"Home","title":"Breaking changes","ref":"/ITensorDocs/ITensorMPS/stable/#Breaking-changes","content":" Breaking changes ITensorMPS.jl v0.2 has been released, which is a breaking release. It updates to using ITensorTDVP.jl v0.4, which has a number of breaking changes to the  tdvp ,  linsolve , and  dmrg_x  functions. See the  ITensorTDVP.jl v0.4 release notes  for details."},{"id":475,"pagetitle":"Home","title":"Example DMRG Calculation","ref":"/ITensorDocs/ITensorMPS/stable/#Example-DMRG-Calculation","content":" Example DMRG Calculation DMRG is an iterative algorithm for finding the dominant eigenvector of an exponentially large, Hermitian matrix. It originates in physics with the purpose of finding eigenvectors of Hamiltonian (energy) matrices which model the behavior of quantum systems. using ITensors, ITensorMPS\nlet\n  # Create 100 spin-one indices\n  N = 100\n  sites = siteinds(\"S=1\", N)\n\n  # Input operator terms which define\n  # a Hamiltonian matrix, and convert\n  # these terms to an MPO tensor network\n  # (here we make the 1D Heisenberg model)\n  os = OpSum()\n  for j in 1:(N - 1)\n    os += \"Sz\", j, \"Sz\", j + 1\n    os += 0.5, \"S+\", j, \"S-\", j + 1\n    os += 0.5, \"S-\", j, \"S+\", j + 1\n  end\n  H = MPO(os, sites)\n\n  # Create an initial random matrix product state\n  psi0 = random_mps(sites)\n\n  # Plan to do 5 passes or 'sweeps' of DMRG,\n  # setting maximum MPS internal dimensions\n  # for each sweep and maximum truncation cutoff\n  # used when adapting internal dimensions:\n  nsweeps = 5\n  maxdim = [10, 20, 100, 100, 200]\n  cutoff = 1E-10\n\n  # Run the DMRG algorithm, returning energy\n  # (dominant eigenvalue) and optimized MPS\n  energy, psi = dmrg(H, psi0; nsweeps, maxdim, cutoff)\n  println(\"Final energy = $energy\")\n\n  nothing\nend\n\n# output\n\n# After sweep 1 energy=-137.954199761732 maxlinkdim=9 maxerr=2.43E-16 time=9.356\n# After sweep 2 energy=-138.935058943878 maxlinkdim=20 maxerr=4.97E-06 time=0.671\n# After sweep 3 energy=-138.940080155429 maxlinkdim=92 maxerr=1.00E-10 time=4.522\n# After sweep 4 energy=-138.940086009318 maxlinkdim=100 maxerr=1.05E-10 time=11.644\n# After sweep 5 energy=-138.940086058840 maxlinkdim=96 maxerr=1.00E-10 time=12.771\n# Final energy = -138.94008605883985 After sweep 1 energy=-137.36728582611758  maxlinkdim=9 maxerr=3.41E-16 time=16.560\nAfter sweep 2 energy=-138.93320077469934  maxlinkdim=20 maxerr=4.93E-06 time=0.393\nAfter sweep 3 energy=-138.9400657859546  maxlinkdim=92 maxerr=9.99E-11 time=3.168\nAfter sweep 4 energy=-138.94008581461114  maxlinkdim=100 maxerr=1.11E-10 time=8.316\nAfter sweep 5 energy=-138.9400860572466  maxlinkdim=99 maxerr=1.00E-10 time=8.916\nFinal energy = -138.9400860572466 You can find more examples of running  dmrg  and related algorithms  here . This page was generated using  Literate.jl ."},{"id":478,"pagetitle":"DMRG Examples","title":"DMRG Code Examples","ref":"/ITensorDocs/ITensorMPS/stable/examples/#DMRG-Code-Examples","content":" DMRG Code Examples"},{"id":479,"pagetitle":"DMRG Examples","title":"Perform a basic DMRG calculation","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Perform-a-basic-DMRG-calculation","content":" Perform a basic DMRG calculation Because tensor indices in ITensor have unique identities, before we can make a Hamiltonian or a wavefunction we need to construct a \"site set\" which will hold the site indices defining the physical Hilbert space: using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=1\",N) Here we have chosen to create a Hilbert space of N spin 1 sites. The string \"S=1\" denotes a special Index tag which hooks into a system that knows \"S=1\" indices have a dimension of 3 and how to create common physics operators like \"Sz\" for them. Next we'll make our Hamiltonian matrix product operator (MPO). A very convenient way to do this is to use the OpSum helper type which lets us input a Hamiltonian (or any sum of local operators) in similar notation to pencil-and-paper notation: os = OpSum()\nfor j=1:N-1\n  os += 0.5,\"S+\",j,\"S-\",j+1\n  os += 0.5,\"S-\",j,\"S+\",j+1\n  os += \"Sz\",j,\"Sz\",j+1\nend\nH = MPO(os,sites) In the last line above we convert the OpSum helper object to an actual MPO. Before beginning the calculation, we need to specify how many DMRG sweeps to do and what schedule we would like for the parameters controlling the accuracy. These parameters can be specified as follows: nsweeps = 5 # number of sweeps is 5\nmaxdim = [10,20,100,100,200] # gradually increase states kept\ncutoff = [1E-10] # desired truncation error The random starting wavefunction  psi0  must be defined in the same Hilbert space as the Hamiltonian, so we construct it using the same collection of site indices: psi0 = random_mps(sites;linkdims=2) Here we have made a random MPS of bond dimension 2. We could have used a random product state instead, but choosing a slightly larger bond dimension can help DMRG avoid getting stuck in local minima. We could also set psi to some specific initial state using the  MPS  constructor, which is actually required if we were conserving QNs. Finally, we are ready to call DMRG: energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff) When the algorithm is done, it returns the ground state energy as the variable  energy  and an MPS approximation to the ground state as the variable  psi . Below you can find a complete working code that includes all of these steps: using ITensors, ITensorMPS\n\nlet\n  N = 100\n  sites = siteinds(\"S=1\",N)\n\n  os = OpSum()\n  for j=1:N-1\n    os += 0.5,\"S+\",j,\"S-\",j+1\n    os += 0.5,\"S-\",j,\"S+\",j+1\n    os += \"Sz\",j,\"Sz\",j+1\n  end\n  H = MPO(os,sites)\n\n  nsweeps = 5 # number of sweeps is 5\n  maxdim = [10,20,100,100,200] # gradually increase states kept\n  cutoff = [1E-10] # desired truncation error\n\n  psi0 = random_mps(sites;linkdims=2)\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend"},{"id":480,"pagetitle":"DMRG Examples","title":"Using a Custom Observer for DMRG","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Using-a-Custom-Observer-for-DMRG","content":" Using a Custom Observer for DMRG An Observer is any object which can be used to perform custom measurements throughout a DMRG calculation and to stop a DMRG calculation early. Because an Observer has access to the entire wavefunction at every step, a wide range of customization is possible. For detailed examples of making custom Observers, see the  Observer  section of the documentation."},{"id":481,"pagetitle":"DMRG Examples","title":"DMRG Calculation with Mixed Local Hilbert Space Types","ref":"/ITensorDocs/ITensorMPS/stable/examples/#DMRG-Calculation-with-Mixed-Local-Hilbert-Space-Types","content":" DMRG Calculation with Mixed Local Hilbert Space Types The following fully-working example shows how to set up a calculation mixing S=1/2 and S=1 spins on every other site of a 1D system. The Hamiltonian involves Heisenberg spin interactions with adjustable couplings between sites of the same spin or different spin. Note that the only difference from a regular ITensor DMRG calculation is that the  sites  array has Index objects which alternate in dimension and in which physical tag type they carry, whether  \"S=1/2\"  or  \"S=1\" . (Try printing out the sites array to see!) These tags tell the OpSum system which local operators to use for these sites when building the Hamiltonian MPO. using ITensors, ITensorMPS\n\nlet\n  N = 100\n\n  # Make an array of N Index objects with alternating\n  # \"S=1/2\" and \"S=1\" tags on odd versus even sites\n  # (The first argument n->isodd(n) ... is an\n  # on-the-fly function mapping integers to strings)\n  sites = siteinds(n->isodd(n) ? \"S=1/2\" : \"S=1\",N)\n\n  # Couplings between spin-half and\n  # spin-one sites:\n  Jho = 1.0 # half-one coupling\n  Jhh = 0.5 # half-half coupling\n  Joo = 0.5 # one-one coupling\n\n  os = OpSum()\n  for j=1:N-1\n    os += 0.5*Jho,\"S+\",j,\"S-\",j+1\n    os += 0.5*Jho,\"S-\",j,\"S+\",j+1\n    os += Jho,\"Sz\",j,\"Sz\",j+1\n  end\n  for j=1:2:N-2\n    os += 0.5*Jhh,\"S+\",j,\"S-\",j+2\n    os += 0.5*Jhh,\"S-\",j,\"S+\",j+2\n    os += Jhh,\"Sz\",j,\"Sz\",j+2\n  end\n  for j=2:2:N-2\n    os += 0.5*Joo,\"S+\",j,\"S-\",j+2\n    os += 0.5*Joo,\"S-\",j,\"S+\",j+2\n    os += Joo,\"Sz\",j,\"Sz\",j+2\n  end\n  H = MPO(os,sites)\n\n  nsweeps = 10\n  maxdim = [10,10,20,40,80,100,140,180,200]\n  cutoff = [1E-8]\n\n  psi0 = random_mps(sites;linkdims=4)\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend"},{"id":482,"pagetitle":"DMRG Examples","title":"Use a Sum of MPOs in DMRG","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Use-a-Sum-of-MPOs-in-DMRG","content":" Use a Sum of MPOs in DMRG One version of the ITensor  dmrg  function accepts an array of MPOs  [H1,H2,H3]  (or any number of MPOs you want). This version of DMRG will find the ground state of  H1+H2+H3 . Internally it does not actually sum these MPOs, but loops over them during each step of the \"eigensolver\" at the core of the DMRG algorithm, so it is usually more efficient than if the MPOs had been summed together into a single MPO. To use this version of DMRG, say you have MPOs  H1 ,  H2 , and  H3 . Then call DMRG like this: energy,psi = dmrg([H1,H2,H3],psi0;nsweeps,maxdim,cutoff)"},{"id":483,"pagetitle":"DMRG Examples","title":"Make a 2D Hamiltonian for DMRG","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Make-a-2D-Hamiltonian-for-DMRG","content":" Make a 2D Hamiltonian for DMRG You can use the OpSum system to make 2D Hamiltonians much in the same way you make 1D Hamiltonians: by looping over all of the bonds and adding the interactions on these bonds to the OpSum. To help with the logic of 2D lattices, ITensor pre-defines some helper functions which return an array of bonds. Each bond object has an \"s1\" field and an \"s2\" field which are the integers numbering the two sites the bond connects. (You can view the source for these functions at  this link .) The two provided functions currently are  square_lattice  and  triangular_lattice . It is not hard to write your own similar lattice functions as all they have to do is define an array of  ITensorMPS.LatticeBond  structs or even a custom struct type you wish to define. We welcome any user contributions of other lattices that ITensor does not currently offer. Each lattice function takes an optional named argument \"yperiodic\" which lets you request that the lattice should have periodic boundary conditions around the y direction, making the geometry a cylinder. Full example code: using ITensors, ITensorMPS\n\nlet\n  Ny = 6\n  Nx = 12\n\n  N = Nx*Ny\n\n  sites = siteinds(\"S=1/2\", N;\n                   conserve_qns = true)\n\n  # Obtain an array of LatticeBond structs\n  # which define nearest-neighbor site pairs\n  # on the 2D square lattice (wrapped on a cylinder)\n  lattice = square_lattice(Nx, Ny; yperiodic = false)\n\n  # Define the Heisenberg spin Hamiltonian on this lattice\n  os = OpSum()\n  for b in lattice\n    os += 0.5, \"S+\", b.s1, \"S-\", b.s2\n    os += 0.5, \"S-\", b.s1, \"S+\", b.s2\n    os +=      \"Sz\", b.s1, \"Sz\", b.s2\n  end\n  H = MPO(os,sites)\n\n  state = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\n  # Initialize wavefunction to a random MPS\n  # of bond-dimension 10 with same quantum\n  # numbers as `state`\n  psi0 = random_mps(sites,state;linkdims=20)\n\n  nsweeps = 10\n  maxdim = [20,60,100,100,200,400,800]\n  cutoff = [1E-8]\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend"},{"id":484,"pagetitle":"DMRG Examples","title":"Compute excited states with DMRG","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Compute-excited-states-with-DMRG","content":" Compute excited states with DMRG ITensor DMRG accepts additional MPS wavefunctions as a optional, extra argument. These additional 'penalty states' are provided as an array of MPS just after the Hamiltonian, like this: energy,psi3 = dmrg(H,[psi0,psi1,psi2],psi3_init;nsweeps,maxdim,cutoff) Here the penalty states are  [psi0,psi1,psi2] . When these are provided, the DMRG code minimizes the energy of the current MPS while also reducing its overlap (inner product) with the previously provided MPS. If these overlaps become sufficiently small, then the computed MPS is an excited state. So by finding the ground state, then providing it to DMRG as a \"penalty state\" or previous state one can compute the first excited state. Then providing both of these, one can get the second excited state, etc. A  keyword argument called  weight  can also be provided to the  dmrg  function when penalizing overlaps to previous states. The  weight  parameter is multiplied by the overlap with the previous states, so sets the size of the penalty. It should be chosen at least as large as the (estimated) gap between the ground and first excited states. Otherwise the optimal value of the weight parameter is not so obvious, and it is best to try various weights during initial test calculations. Note that when the system has conserved quantum numbers, a superior way to find excited states can be to find ground states of quantum number (or symmetry) sectors other than the one containing the absolute ground state. In that context, the penalty method used below is a way to find higher excited states within the same quantum number sector. Full Example code: using ITensors, ITensorMPS\n\nlet\n  N = 20\n\n  sites = siteinds(\"S=1/2\",N)\n\n  h = 4.0\n\n  weight = 20*h # use a large weight\n                # since gap is expected to be large\n\n\n  #\n  # Use the OpSum feature to create the\n  # transverse field Ising model\n  #\n  # Factors of 4 and 2 are to rescale\n  # spin operators into Pauli matrices\n  #\n  os = OpSum()\n  for j=1:N-1\n    os -= 4,\"Sz\",j,\"Sz\",j+1\n  end\n  for j=1:N\n    os -= 2*h,\"Sx\",j;\n  end\n  H = MPO(os,sites)\n\n\n  #\n  # Make sure to do lots of sweeps\n  # when finding excited states\n  #\n  nsweeps = 30\n  maxdim = [10,10,10,20,20,40,80,100,200,200]\n  cutoff = [1E-8]\n  noise = [1E-6]\n\n  #\n  # Compute the ground state psi0\n  #\n  psi0_init = random_mps(sites;linkdims=2)\n  energy0,psi0 = dmrg(H,psi0_init;nsweeps,maxdim,cutoff,noise)\n\n  println()\n\n  #\n  # Compute the first excited state psi1\n  #\n  psi1_init = random_mps(sites;linkdims=2)\n  energy1,psi1 = dmrg(H,[psi0],psi1_init;nsweeps,maxdim,cutoff,noise,weight)\n\n  # Check psi1 is orthogonal to psi0\n  @show inner(psi1,psi0)\n\n\n  #\n  # The expected gap of the transverse field Ising\n  # model is given by Eg = 2*|h-1|\n  #\n  # (The DMRG gap will have finite-size corrections)\n  #\n  println(\"DMRG energy gap = \",energy1-energy0);\n  println(\"Theoretical gap = \",2*abs(h-1));\n\n  println()\n\n  #\n  # Compute the second excited state psi2\n  #\n  psi2_init = random_mps(sites;linkdims=2)\n  energy2,psi2 = dmrg(H,[psi0,psi1],psi2_init;nsweeps,maxdim,cutoff,noise,weight)\n\n  # Check psi2 is orthogonal to psi0 and psi1\n  @show inner(psi2,psi0)\n  @show inner(psi2,psi1)\n\n  return\nend"},{"id":485,"pagetitle":"DMRG Examples","title":"Printing the Entanglement Entropy at Each Step","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Printing-the-Entanglement-Entropy-at-Each-Step","content":" Printing the Entanglement Entropy at Each Step To obtain the entanglement entropy of an MPS at each step during a DMRG calculation, you can use the  Observer  system to make a custom observer object that prints out this information. First we define our custom observer type,  EntanglementObserver , and overload the  measure!  function for it: using ITensors, ITensorMPS\n\nmutable struct EntanglementObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::EntanglementObserver; bond, psi, half_sweep, kwargs...)\n  wf_center, other = half_sweep==1 ? (psi[bond+1],psi[bond]) : (psi[bond],psi[bond+1])\n  U,S,V = svd(wf_center, uniqueinds(wf_center,other))\n  SvN = 0.0\n  for n=1:dim(S, 1)\n    p = S[n,n]^2\n    SvN -= p * log(p)\n  end\n  println(\"  Entanglement across bond $bond = $SvN\")\nend The  measure!  function grabs certain helpful keywords passed to it by DMRG, such as what bond DMRG has just finished optimizing. Here is a complete sample code including constructing the observer and passing it to DMRG: using ITensors, ITensorMPS\n\nmutable struct EntanglementObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::EntanglementObserver; bond, psi, half_sweep, kwargs...)\n  wf_center, other = half_sweep==1 ? (psi[bond+1],psi[bond]) : (psi[bond],psi[bond+1])\n  U,S,V = svd(wf_center, uniqueinds(wf_center,other))\n  SvN = 0.0\n  for n=1:dim(S, 1)\n    p = S[n,n]^2\n    SvN -= p * log(p)\n  end\n  println(\"  Entanglement across bond $bond = $SvN\")\nend\n\nlet\n  N = 100\n\n  s = siteinds(\"S=1/2\",N)\n\n  a = OpSum()\n  for n=1:N-1\n    a += \"Sz\",n,\"Sz\",n+1\n    a += 0.5,\"S+\",n,\"S-\",n+1\n    a += 0.5,\"S-\",n,\"S+\",n+1\n  end\n  H = MPO(a,s)\n  psi0 = random_mps(s;linkdims=4)\n\n  nsweeps = 5\n  maxdim = [10,20,80,160]\n  cutoff = 1E-8\n\n  observer = EntanglementObserver()\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff,observer,outputlevel=2)\n\n  return\nend Example output: ...\nSweep 2, half 2, bond (35,36) energy=-44.08644657103751\n  Truncated using cutoff=1.0E-08 maxdim=20 mindim=1\n  Trunc. err=2.54E-07, bond dimension 20\n  Entanglement across bond 35 = 0.7775882479059774\nSweep 2, half 2, bond (34,35) energy=-44.086696891668424\n  Truncated using cutoff=1.0E-08 maxdim=20 mindim=1\n  Trunc. err=2.12E-07, bond dimension 20\n  Entanglement across bond 34 = 0.7103532704635472\nSweep 2, half 2, bond (33,34) energy=-44.08696190368391\n  Truncated using cutoff=1.0E-08 maxdim=20 mindim=1\n  Trunc. err=1.29E-07, bond dimension 20\n  Entanglement across bond 33 = 0.7798362911744212\n... If you only want to see the maximum entanglement during each sweep, you can add a field to the EntanglementObserver object that saves the maximum value encountered so far and keep overwriting this field, printing out the most recently observed maximum at the end of each sweep."},{"id":486,"pagetitle":"DMRG Examples","title":"Monitoring the Memory Usage of DMRG","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Monitoring-the-Memory-Usage-of-DMRG","content":" Monitoring the Memory Usage of DMRG To monitor how much memory (RAM) a DMRG calculation is using while it is running, you can use the  Observer  system to make a custom observer object that prints out this information. Also the  Base.summarysize  function, which returns the size in bytes of any Julia object is very helpful here. First we define our custom observer type,  SizeObserver , and overload the  measure!  function for it: using ITensors, ITensorMPS\n\nmutable struct SizeObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::SizeObserver; bond, half_sweep, psi, projected_operator, kwargs...)\n  if bond==1 && half_sweep==2\n    psi_size =  Base.format_bytes(Base.summarysize(psi))\n    PH_size =  Base.format_bytes(Base.summarysize(projected_operator))\n    println(\"|psi| = $psi_size, |PH| = $PH_size\")\n  end\nend The  measure!  function grabs certain helpful keywords passed to it by DMRG, checking  if bond==1 && half_sweep==2  so that it only runs when at the end of a full sweep. When it runs, it calls  Base.summarysize  on the wavefunction  psi  object and the  projected_operator  object. The  projected_operator , which is the matrix (Hamiltonian) wrapped into the current MPS basis, is usually the largest-sized object in a DMRG calculation. The code also uses  Base.format_bytes  to turn an integer representing bytes into a human-readable string. Here is a complete sample code including constructing the observer and passing it to DMRG: using ITensors, ITensorMPS\n\nmutable struct SizeObserver <: AbstractObserver\nend\n\nfunction ITensorMPS.measure!(o::SizeObserver; bond, sweep, half_sweep, psi, projected_operator, kwargs...)\n  if bond==1 && half_sweep==2\n    psi_size =  Base.format_bytes(Base.summarysize(psi))\n    PH_size =  Base.format_bytes(Base.summarysize(projected_operator))\n    println(\"After sweep $sweep, |psi| = $psi_size, |PH| = $PH_size\")\n  end\nend\n\nlet\n  N = 100\n\n  s = siteinds(\"S=1/2\",N)\n\n  a = OpSum()\n  for n=1:N-1\n    a += \"Sz\",n,\"Sz\",n+1\n    a += 0.5,\"S+\",n,\"S-\",n+1\n    a += 0.5,\"S-\",n,\"S+\",n+1\n  end\n  H = MPO(a,s)\n  psi0 = random_mps(s;linkdims=4)\n\n  nsweeps = 5\n  maxdim = [10,20,80,160]\n  cutoff = 1E-8\n\n  obs = SizeObserver()\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff,observer=obs)\n\n  return\nend Example output: After sweep 1, |psi| = 211.312 KiB, |PH| = 593.984 KiB\nAfter sweep 1 energy=-43.95323393592883  maxlinkdim=10 maxerr=8.26E-06 time=0.098\nAfter sweep 2, |psi| = 641.000 KiB, |PH| = 1.632 MiB\nAfter sweep 2 energy=-44.10791340895817  maxlinkdim=20 maxerr=7.39E-07 time=0.132\nAfter sweep 3, |psi| = 1.980 MiB, |PH| = 5.066 MiB\nAfter sweep 3 energy=-44.12593605906466  maxlinkdim=44 maxerr=9.96E-09 time=0.256\nAfter sweep 4, |psi| = 2.863 MiB, |PH| = 7.246 MiB\nAfter sweep 4 energy=-44.127710946536645  maxlinkdim=56 maxerr=9.99E-09 time=0.445\nAfter sweep 5, |psi| = 3.108 MiB, |PH| = 7.845 MiB\nAfter sweep 5 energy=-44.127736798226536  maxlinkdim=57 maxerr=9.98E-09 time=0.564"},{"id":489,"pagetitle":"MPS and MPO Examples","title":"MPS and MPO Examples","ref":"/ITensorDocs/ITensorMPS/stable/examples/#MPS-and-MPO-Examples","content":" MPS and MPO Examples The following examples demonstrate operations available in ITensor to work with  matrix product state (MPS)  (or tensor train) and matrix product operator (MPO) tensor networks."},{"id":490,"pagetitle":"MPS and MPO Examples","title":"Creating an MPS from a Tensor","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Creating-an-MPS-from-a-Tensor","content":" Creating an MPS from a Tensor A matrix product state (MPS) made of N tensors, each with one site or physical index, is a way of representing a single tensor with N indices. One way of obtaining the MPS form of an N-index tensor  T  is by repeatedly factorizing  T  into N separate tensors using a factorization such as the  Singular Value Decomposition  (SVD). This algorithm for obtaining an MPS is known in the mathematics literature as the \"tensor train SVD\" or \"TT-SVD\" algorithm. To turn an N-index (order-N) tensor T into an MPS, you can just construct an MPS by passing T as the first argument, along with keyword arguments that control the approximations used in factorizing T. Let's look at a few specific cases."},{"id":491,"pagetitle":"MPS and MPO Examples","title":"ITensor to MPS Example","ref":"/ITensorDocs/ITensorMPS/stable/examples/#ITensor-to-MPS-Example","content":" ITensor to MPS Example If you have a tensor  T  which is an ITensor and has indices  i,j,k,l,m , you can create an MPS approximation of  T  where the MPS has site indices  i,j,k,l,m  as follows: cutoff = 1E-8\nmaxdim = 10\nT = random_itensor(i,j,k,l,m)\nM = MPS(T,(i,j,k,l,m);cutoff=cutoff,maxdim=maxdim) Here we used a random ITensor for illustrative purposes, but it could be any ITensor and typically tensors with additional structure are more well approximated by MPS."},{"id":492,"pagetitle":"MPS and MPO Examples","title":"Julia Tensor to MPS Example","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Julia-Tensor-to-MPS-Example","content":" Julia Tensor to MPS Example Another situation could be where you have a Julia array or Julia tensor of dimension  $d^N$  and want to approximate it as an MPS with  $N$  site indices, each of dimension  $d$ . For example, we could have the following random Julia array of dimension  $2\\times 2\\times 2 \\times 2 \\times 2$ : d = 2\nN = 5\nA = randn(d,d,d,d,d) Alternatively, the array could be just a one dimensional array of length  $d^N$ : A = randn(d^N) To convert this array to an MPS, we will first need a collection of Index objects to use as the site indices of the MPS. We can conveniently construct an array of four indices of dimension 2 as follows: sites = siteinds(d,N) Finally, we can pass our array  A  and our  sites  to the MPS constructor along with parameters controlling the truncation level of the factorizations used: cutoff = 1E-8\nmaxdim = 10\nM = MPS(A,sites;cutoff=cutoff,maxdim=maxdim)"},{"id":493,"pagetitle":"MPS and MPO Examples","title":"Obtaining Elements of a Tensor Represented by an MPS","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Obtaining-Elements-of-a-Tensor-Represented-by-an-MPS","content":" Obtaining Elements of a Tensor Represented by an MPS A matrix product state (MPS) or tensor train (TT) is a format for representing a large tensor having N indices in terms of N smaller tensors. Given an MPS represeting a tensor T we can obtain a particular element  $T^{s_1 s_2 s_3 \\cdots s_N}$  of that tensor using code similar to the following code below. In the example code below we will obtain the element  $T^{1,2,1,1,2,1,2,2,2,1}$  of the tensor T which is (implicitly) defined by the MPS psi: using ITensors, ITensorMPS\nN = 10\ns = siteinds(2,N)\nchi = 4\npsi = random_mps(s;linkdims=chi)\n\n# Make an array of integers of the element we\n# want to obtain\nel = [1,2,1,1,2,1,2,2,2,1]\n\nV = ITensor(1.)\nfor j=1:N\n  V *= (psi[j]*state(s[j],el[j]))\nend\nv = scalar(V)\n\n# v is the element we wanted to obtain:\n@show v -0.001590873317961136 The call to  state(s[j],el[j])  in the code above makes a single-index ITensor with the Index  s[j]  and the entry at location  el[j]  set to 1.0, with all other entries set to 0.0. Contracting this tensor with the MPS tensor at site  j  can be viewed as \"clamping\" or \"fixing\" the index to a set value. The resulting tensors are contracted sequentially, overwriting the ITensor  V , and the final scalar value of  V  is the tensor element we seek. See below for a visual depiction of what the above code is doing:"},{"id":494,"pagetitle":"MPS and MPO Examples","title":"Expected Value of Local Operators","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Expected-Value-of-Local-Operators","content":" Expected Value of Local Operators When using an MPS to represent a quantum wavefunction  $|\\psi\\rangle$  a common operation is computing the expected value  $\\langle\\psi|\\hat{A}_j|\\psi\\rangle$  of a local operator  $\\hat{A}_j$  acting on site  $j$ . This can be accomplished efficiently and conveniently using the  expect  function as: Avals = expect(psi,\"A\") where  \"A\"  must be an operator associated with the physical site type, or site tags, of the sites of the MPS  psi . For example, the operator name could be  \"Sz\"  for spin sites or  \"Ntot\"  for electron sites. (For more information about defining such operators yourself, see the section on  Extending op Function Definitions .) As a concrete example, consider computing the expectation value of  $S^z_j$  on every site of an MPS representing a system of N spins of size  $S=1/2$ . In the following example we will use a random MPS of bond dimension  $\\chi=4$  but the MPS could be obtained other ways such as through a DMRG calculation. using ITensors, ITensorMPS\nN = 10\nchi = 4\nsites = siteinds(\"S=1/2\",N)\npsi = random_mps(sites;linkdims=chi)\nmagz = expect(psi,\"Sz\")\nfor (j,mz) in enumerate(magz)\n    println(\"$j $mz\")\nend 1 0.20344610010961728\n2 0.07047403958509374\n3 0.2904185450119215\n4 -0.02378624031346194\n5 0.051682494378442\n6 0.07564067398320483\n7 0.09164274996170588\n8 -0.16514960740234433\n9 0.160731769346307\n10 0.007155256835411122"},{"id":495,"pagetitle":"MPS and MPO Examples","title":"Expected Values of MPO Operators","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Expected-Values-of-MPO-Operators","content":" Expected Values of MPO Operators When using an MPS to represent a quantum wavefunction  $|\\psi\\rangle$  another common operation is computing the expected value  $\\langle\\psi|W|\\psi\\rangle$  of an operator  $W$  which is represented as a matrix product operator (MPO) tensor network. A key example could be the Hamiltonian defining a quantum system. Given an MPO  W  and an MPS  psi , you can compute  $\\langle\\psi|W|\\psi\\rangle$  by using the function  inner  as follows: ex_W = inner(psi',W,psi) which will return a scalar that may be either real or complex, depending on the properties of  psi  and  W ."},{"id":496,"pagetitle":"MPS and MPO Examples","title":"Computing Correlation Functions","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Computing-Correlation-Functions","content":" Computing Correlation Functions In addition to expected values of local operators discussed above, another type of observable that is very important in physics studies are correlation functions of the form \\[C_{ij} = \\langle\\psi| A_i B_j |\\psi\\rangle\\] These can be computed efficiently for an MPS  psi  in ITensor using the  correlation_matrix  function: C = correlation_matrix(psi,\"A\",\"B\") where  \"A\"  and  \"B\"  must be an operator names associated with the physical site type, or site tags, of the sites of the MPS  psi . For example, these strings could be  \"Sz\" ,  \"S+\" , or  \"S-\"  for spin sites, or  \"Cdagup\"  and  \"Cup\"  for electron sites. (For more information about defining such operators yourself, see the section on  Extending op Function Definitions .) As a concrete example, say we have an MPS  psi  for a system of spins and want to compute the correlator  $\\langle\\psi|S^z_i S^z_j|\\psi\\rangle$ . We can compute this as: zzcorr = correlation_matrix(psi,\"Sz\",\"Sz\") See the  correlation_matrix  docs for more details about additional arguments you can pass to this function."},{"id":497,"pagetitle":"MPS and MPO Examples","title":"Applying a Single-site Operator to an MPS","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Applying-a-Single-site-Operator-to-an-MPS","content":" Applying a Single-site Operator to an MPS In many applications one needs to modify a matrix product state (MPS) by multiplying it with an operator that acts only on a single site. This is actually a very straightforward operation and this formula shows you how to do it in ITensor. Say we have an operator  $G^{s'_3}_{s_3}$  which acts non-trivially on site 3 of our MPS  psi  as in the following diagram: To carry out this operation, contract the operator G with the MPS tensor for site 3, removing the prime from the  $s'_3$  index afterward: newA = G * psi[3]\nnewA = noprime(newA) Finally, put the new tensor back into MPS  psi  to update its third MPS tensor: psi[3] = newA Afterward, we can visualize the modified MPS as: As a technical note, if you are working in a context where gauge or orthogonality properties of the MPS are important, such as in time evolution using two-site gates, then you may want to call  psi = orthogonalize(psi, 3)  before modifying the tensor at site 3, which will ensure that the MPS remains in a well-defined orthogonal gauge centered on site 3. Modifying a tensor which is left- or right-orthogonal (i.e. not the \"center\" tensor of the gauge) will destroy the gauge condition and require extra operations to restore it. (Calling  orthogonalize  method will automatically fix this but will have to do extra work to do so.)"},{"id":498,"pagetitle":"MPS and MPO Examples","title":"Applying a Two-site Operator to an MPS","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Applying-a-Two-site-Operator-to-an-MPS","content":" Applying a Two-site Operator to an MPS A very common operation with matrix product states (MPS) is multiplication by a two-site operator or \"gate\" which modifies the MPS. This procedure can be carried out in an efficient, controlled way which is adaptive in the MPS bond dimension. Say we have an operator  $G^{s'_3 s'_4}_{s_3 s_4}$  which is our gate and which acts on physical sites 3 and 4 of our MPS  psi , as in the following diagram: To apply this gate in a controlled manner, first 'gauge' the MPS  psi  such that either site 3 or 4 is the  orthogonality center . Here we make site 3 the center: psi = orthogonalize(psi, 3) The other MPS tensors are now either left-orthogonal or right-orthogonal and can be left out of further steps without producing incorrect results. Next, contract the gate tensor G with the MPS tensors for sites 3 and 4 wf = (psi[3] * psi[4]) * G\nwf = noprime(wf) Finally, use the singular value decomposition (SVD) to factorize the resulting tensor, multiplying the singular values into either U or V. Assign these two tensors back into the MPS to update it. inds3 = uniqueinds(psi[3],psi[4])\nU,S,V = svd(wf,inds3,cutoff=1E-8)\npsi[3] = U\npsi[4] = S*V The call to  uniqueinds(psi[3])  analyzes the indices of  psi[3]  and  psi[4]  and finds any which are unique to just  psi[3] , saving this collection of indices as  inds3 . Passing this collection of indices to the  svd  function tells it to treat any indices that are unique to  psi[3]  as the indices which should go onto the  U  tensor afterward. We also set a truncation error cutoff of 1E-8 in the call to  svd  to truncate the smallest singular values and control the size of the resulting MPS. Other cutoff values can be used, depending on the desired accuracy, as well as limits on the maximum bond dimension ( maxdim  keyword argument). Complete code example using ITensors, ITensorMPS\n\npsi = orthogonalize(psi, 3)\n\nwf = (psi[3] * psi[4]) * G\nwf = noprime(wf)\n\ninds3 = uniqueinds(psi[3], psi[4])\nU, S, V = svd(wf, inds3; cutoff=1E-8)\npsi[3] = U\npsi[4] = S * V"},{"id":499,"pagetitle":"MPS and MPO Examples","title":"Computing the Entanglement Entropy of an MPS","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Computing-the-Entanglement-Entropy-of-an-MPS","content":" Computing the Entanglement Entropy of an MPS A key advantage of using the matrix product state (MPS) format to represent quantum wavefunctions is that it allows one to efficiently compute the entanglement entropy of any left-right bipartition of the system in one dimension, or for a two-dimensional system any \"cut\" along the MPS path. Say that we have obtained an MPS  psi  of length N and we wish to compute the entanglement entropy of a bipartition of the system into a region \"A\" which consists of sites 1,2,...,b and a region B consisting of sites b+1,b+2,...,N. Then the following code formula can be used to accomplish this task: psi = orthogonalize(psi, b)\nU,S,V = svd(psi[b], (linkinds(psi, b-1)..., siteinds(psi, b)...))\nSvN = 0.0\nfor n=1:dim(S, 1)\n  p = S[n,n]^2\n  SvN -= p * log(p)\nend As a brief explanation of the code above, the call to  psi = orthogonalize(psi, b)  shifts the orthogonality center to site  b  of the MPS. The call to the  svd  routine says to treat the link (virtual or bond) Index connecting the b'th MPS tensor  psi[b]  and the b'th physical Index as \"row\" indices for the purposes of the SVD (these indices will end up on  U , along with the Index connecting  U  to  S ). The code in the  for  loop iterates over the diagonal elements of the  S  tensor (which are the singular values from the SVD), computes their squares to obtain the probabilities of observing the various states in the Schmidt basis (i.e. eigenvectors of the left-right bipartition reduced density matrices), and puts them into the von Neumann entanglement entropy formula  $S_\\text{vN} = - \\sum_{n} p_{n} \\log{p_{n}}$ ."},{"id":500,"pagetitle":"MPS and MPO Examples","title":"Sampling from an MPS","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Sampling-from-an-MPS","content":" Sampling from an MPS A matrix product state (MPS) can be viewed as defining a probability distribution through the Born rule, as is the case when the MPS represents a quantum wavefunction. To sample from the distribution defined by an MPS, you can use the function  sample  provided in ITensor. For an MPS  psi  call to  sample(psi)  returns a random sample from the distribution defined by  psi . (Note that each sample is drawn anew and not from a Markov chain seeded by a previous sample; this is possible because the algorithm for sampling MPS is a `perfect' sampling algorithm with no autocorrelation.) In more detail, say we have a set of  N  site indices  s  and define a random MPS with these sites: using ITensors, ITensorMPS\n\nN = 10 # number of sites\nd = 3  # dimension of each site\nchi = 16 # bond dimension of the MPS\ns = siteinds(d,N)\npsi = random_mps(s;linkdims=chi) We can now draw some samples from this MPS as v1 = sample(psi)\nv2 = sample(psi)\nv3 = sample(psi)\nprintln(v1)\nprintln(v2)\nprintln(v3) [2, 3, 3, 3, 2, 1, 3, 3, 2, 3]\n[1, 2, 3, 3, 2, 2, 2, 1, 1, 3]\n[2, 2, 1, 2, 3, 2, 2, 2, 2, 3] The integers in each of the samples represent settings of each of the MPS indices in the \"computational basis\". For reasons of efficiency, the  sample  function requires the MPS to be in orthogonal form, orthogonalized to the first site. If it is not already in this form, it can be brought into orthogonal form by calling  psi = orthogonalize(psi, 1) ."},{"id":501,"pagetitle":"MPS and MPO Examples","title":"Write and Read an MPS or MPO to Disk with HDF5","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Write-and-Read-an-MPS-or-MPO-to-Disk-with-HDF5","content":" Write and Read an MPS or MPO to Disk with HDF5 Info Make sure to install the HDF5 package to use this feature. (Run  julia> ] add HDF5  in the Julia REPL console.) Writing an MPS to an HDF5 File Let's say you have an MPS  psi  which you have made or obtained from a calculation. To write it to an HDF5 file named \"myfile.h5\" you can use the following pattern: using HDF5\nf = h5open(\"myfile.h5\",\"w\")\nwrite(f,\"psi\",psi)\nclose(f) Above, the string \"psi\" can actually be any string you want such as \"MPS psi\" or \"Result MPS\" and doesn't have to have the same name as the reference  psi . Closing the file  f  is optional and you can also write other objects to the same file before closing it. Reading an MPS from an HDF5 File Say you have an HDF5 file \"myfile.h5\" which contains an MPS stored as a dataset with the name \"psi\". (Which would be the situation if you wrote it as in the example above.) To read this ITensor back from the HDF5 file, use the following pattern: using HDF5\nf = h5open(\"myfile.h5\",\"r\")\npsi = read(f,\"psi\",MPS)\nclose(f) Many functions which involve MPS, such as the  dmrg  function or the  OpSum  system require that you use an array of site indices which match the MPS. So when reading in an MPS from disk, do not construct a new array of site indices. Instead, you can obtain them like this:  sites = siteinds(psi) . So for example, to create an MPO from an OpSum which has the same site indices as your MPS  psi , do the following: using ITensors, ITensorMPS\n\nos = OpSum()\n# Then put operators into os...\n\nsites = siteinds(psi) # Get site indices from your MPS\nH = MPO(os,sites)\n\n# Compute <psi|H|psi>\nenergy_psi = inner(psi',H,psi) Note the  MPS  argument to the read function, which tells Julia which read function to call and how to interpret the data stored in the HDF5 dataset named \"psi\". In the future we might lift the requirement of providing the type and have it be detected automatically from the data stored in the file. Writing and Reading MPOs To write or read MPOs to or from HDF5 files, just follow the examples above but use the type  MPO  when reading an MPO from the file instead of the type  MPS ."},{"id":504,"pagetitle":"Physics (SiteType) System Examples","title":"Physics (SiteType) System Examples","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Physics-(SiteType)-System-Examples","content":" Physics (SiteType) System Examples"},{"id":505,"pagetitle":"Physics (SiteType) System Examples","title":"Obtaining a Predefined Operator","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Obtaining-a-Predefined-Operator","content":" Obtaining a Predefined Operator Given an Index carrying a \"physical\" tag such as \"Qubit\", \"S=1/2\", \"Boson\", etc. there are a set of pre-defined operators for each tag. The entire set of operators can be found in the section  SiteTypes Included with ITensor . If you have an Index  s  carrying a \"S=1/2\" tag, for example, you can obtain the \"Sz\" operator like this: using ITensors, ITensorMPS\n\nop(\"Sz\",s) Usually indices with physical tags come from an array of indices returned from the  siteinds  function using ITensors, ITensorMPS\n\nN = 10\nsites = siteinds(\"S=1/2\",N) in which case one might want the \"Sz\" operator on site 4 using ITensors, ITensorMPS\nSz4 = op(\"Sz\",sites[4])"},{"id":506,"pagetitle":"Physics (SiteType) System Examples","title":"Make a Custom Operator from a Matrix","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Make-a-Custom-Operator-from-a-Matrix","content":" Make a Custom Operator from a Matrix The  op  function can be passed any matrix, as long as it has the correct dimensions, and it will make this into an ITensor representing the operator with the corresponding matrix elements. For example, if we have a two-dimensional Index  s  we could make the \"Sz\" operator ourselves from the matrix M = [1/2 0 ; 0 -1/2] by calling using ITensors, ITensorMPS\nSz = op(M,s)"},{"id":507,"pagetitle":"Physics (SiteType) System Examples","title":"Making a Custom op Definition","ref":"/ITensorDocs/ITensorMPS/stable/examples/#custom_op","content":" Making a Custom op Definition The function  op  is used to obtain operators defined for a given \"site type\". ITensor includes pre-defined site types such as \"S=1/2\", \"S=1\", \"Electron\" and others. Or you can define your own site type as discussed in detail in the code examples further below. Extending op Function Definitions Perhaps the most common part of the site type system one wishes to extend are the various  op  or  op!  function overloads which allow code like using ITensors, ITensorMPS\ns = siteind(\"S=1/2\")\nSz = op(\"Sz\",s) to automatically create the  $S^z$  operator for an Index  s  based on the  \"S=1/2\"  tag it carries. A major reason to define such  op  overloads is to allow the OpSum system to recognize new operator names, as discussed more below. Let's see how to introduce a new operator name into the ITensor site type system for this existing site type of  \"S=1/2\" . The operator we will introduce is the projector onto the up spin state  $P_\\uparrow$  which we will denote with the string  \"Pup\" . As a matrix acting on the space  $\\{ |\\!\\uparrow\\rangle, |\\!\\downarrow\\rangle \\}$ , the  $P_\\uparrow$  operator is given by \\[\\begin{aligned}\n\nP_\\uparrow &=\n\\begin{bmatrix}\n 1 &  0 \\\\\n 0  & 0 \\\\\n\\end{bmatrix}\n\n\\end{aligned}\\] To add this operator to the ITensor  op  system, we just need to introduce the following code using ITensors, ITensorMPS\nITensors.op(::OpName\"Pup\",::SiteType\"S=1/2\") =\n [1 0\n  0 0] This code can be defined anywhere, such as in your own personal application code and does not have to be put into the ITensor library source code. Note that we have to name the function  ITensors.op  and not just  op  so that it overloads other functions of the name  op  inside the ITensors module. Having defined the above code, we can now do things like using ITensors, ITensorMPS\ns = siteind(\"S=1/2\")\nPup = op(\"Pup\",s) to obtain the  \"Pup\"  operator for our  \"S=1/2\"  Index  s . Or we can do a similar thing for an array of site indices: using ITensors, ITensorMPS\nN = 40\ns = siteinds(\"S=1/2\",N)\nPup1 = op(\"Pup\",s[1])\nPup3 = op(\"Pup\",s[3]) Note that for the  \"Qudit\" / \"Boson\"  site types, you have to define your overload of  op  with the dimension of the local Hilbert space, for example: using ITensors, ITensorMPS\nfunction ITensors.op(::OpName\"P1\", ::SiteType\"Boson\", d::Int)\n  o = zeros(d, d)\n  o[1, 1] = 1\n  return o\nend Alternatively you could use Julia's  array comprehension  syntax: using ITensors, ITensorMPS\nITensors.op(::OpName\"P1\", ::SiteType\"Boson\", d::Int) =\n  [(i == j == 1) ? 1.0 : 0.0 for i in 1:d, j in 1:d] Using Custom Operators in OpSum A key use of these  op  system extensions is allowing additional operator names to be recognized by the OpSum system for constructing matrix product operator (MPO) tensor networks. With the code above defining the  \"Pup\"  operator, we are now allowed to use this operator name in any OpSum code involving  \"S=1/2\"  site indices. For example, we could now make an OpSum involving our custom operator such as: using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=1/2\",N)\nos = OpSum()\nfor n=1:N\n  os += \"Pup\",n\nend\nP = MPO(os,sites) This code makes an MPO  P  which is just the sum of a spin-up projection operator acting on every site."},{"id":508,"pagetitle":"Physics (SiteType) System Examples","title":"Making a Custom state Definition","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Making-a-Custom-state-Definition","content":" Making a Custom state Definition The function  state  is used to define states (single-site wavefunctions) that sites can be in. For example, the \"Qubit\" site type includes definitions for the \"0\" and \"1\" states as well as the \"+\" (eigenstate of X operator) state. The \"S=1/2\" site type includes definitions for the \"Up\" and \"Dn\" (down) states. Say we want to define a new state for the \"Electron\" site type called \"+\", which has the meaning of one electron with its spin in the +X direction. First let's review the existing state definitions: using ITensors, ITensorMPS\nITensors.state(::StateName\"Emp\", ::SiteType\"Electron\") = [1.0, 0, 0, 0]\nITensors.state(::StateName\"Up\", ::SiteType\"Electron\") = [0.0, 1, 0, 0]\nITensors.state(::StateName\"Dn\", ::SiteType\"Electron\") = [0.0, 0, 1, 0]\nITensors.state(::StateName\"UpDn\", ::SiteType\"Electron\") = [0.0, 0, 0, 1] As we can see, the four settings of an \"Electron\" index correspond to the states  $|0\\rangle, |\\uparrow\\rangle, |\\downarrow\\rangle, |\\uparrow\\downarrow\\rangle$ . So we can define our new state \"+\" as follows: ITensors.state(::StateName\"+\", ::SiteType\"Electron\") = [0, 1/sqrt(2), 1/sqrt(2), 0] which makes the state \\[|+\\rangle = \\frac{1}{\\sqrt{2}} |\\uparrow\\rangle + \\frac{1}{\\sqrt{2}} |\\downarrow\\rangle\\] Having defined this overload of  state , if we have an Index of type \"Electron\" we can obtain our new state for it by doing using ITensors, ITensorMPS\ns = siteind(\"Electron\")\nplus = state(\"+\",s) We can also use this new state definition in other ITensor features such as the MPS constructor taking an array of state names."},{"id":509,"pagetitle":"Physics (SiteType) System Examples","title":"Make a Custom Local Hilbert Space / Physical Degree of Freedom","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Make-a-Custom-Local-Hilbert-Space-/-Physical-Degree-of-Freedom","content":" Make a Custom Local Hilbert Space / Physical Degree of Freedom ITensor provides support for a range of common local Hilbert space types, or physical degrees of freedom, such as S=1/2 and S=1 spins; spinless and spinful fermions; and more. However, there can be many cases where you need to make custom degrees of freedom. You might be working with an exotic system, such as  $Z_N$  parafermions for example, or need to customize other defaults provided by ITensor. In ITensor, such a customization is done by overloading functions on specially designated Index tags. Below we give an brief introduction by example of how to make such custom Index site types in ITensor. Other code formulas following this one explain how to build on this example to expand the capabilities of your custom site type such as adding support for quantum number (QN) conservation and defining custom mappings of strings to states. Throughout we will focus on the example of  $S=3/2$  spins. These are spins taking the  $S^z$  values of  $+3/2,+1/2,-1/2,-3/2$ . So as tensor indices, they are indices of dimension 4. The key operators we will make for this example are  $S^z$ ,  $S^+$ , and  $S^-$ , which are defined as: \\[\\begin{aligned}\nS^z &=\n\\begin{bmatrix}\n3/2 &  0  &  0  &  0 \\\\\n 0  & 1/2 &  0  &  0 \\\\\n 0  &  0  &-1/2 &  0 \\\\\n 0  &  0  &  0  &-3/2\\\\\n\\end{bmatrix} \\\\\n\nS^+ & =\n\\begin{bmatrix}\n 0  &  \\sqrt{3}  &  0  &  0 \\\\\n 0  &  0  &  2  &  0 \\\\\n 0  &  0  &  0  &  \\sqrt{3} \\\\\n 0  &  0  &  0  &  0 \\\\\n\\end{bmatrix} \\\\\n\nS^- & =\n\\begin{bmatrix}\n 0  &  0 &  0  &  0 \\\\\n \\sqrt{3}  &  0  &  0  &  0 \\\\\n 0  &  2  &  0  &  0  \\\\\n 0  &  0  &  \\sqrt{3}  &  0 \\\\\n\\end{bmatrix} \\\\\n\\end{aligned}\\] Code Preview First let's see the minimal code needed to define and use this new  $S=3/2$  site type, then we will discuss what each part of the code is doing. using ITensors, ITensorMPS\n\nITensors.space(::SiteType\"S=3/2\") = 4\n\nITensors.op(::OpName\"Sz\",::SiteType\"S=3/2\") =\n  [+3/2   0    0    0\n     0  +1/2   0    0\n     0    0  -1/2   0\n     0    0    0  -3/2]\n\nITensors.op(::OpName\"S+\",::SiteType\"S=3/2\") =\n  [0  √3  0  0\n   0   0  2  0\n   0   0  0 √3\n   0   0  0  0]\n\nITensors.op(::OpName\"S-\",::SiteType\"S=3/2\") =\n  [0   0  0   0\n   √3  0  0   0\n   0   2  0   0\n   0   0  √3  0]\n Now let's look at each part of the code above. The SiteType The most important aspect of this code is a special type, known as a  SiteType , which is a type made from a string. The string of interest here will be an Index tag. In the code above, the  SiteType  we are using is SiteType\"S=3/2\" What is the purpose of a  SiteType ? The answer is that we would like to be able to select different functions to call on an ITensor Index based on what tags it has, but that is not directly possible in Julia or indeed most languages. However, if we can map a tag to a type in the Julia type system, we can create function overloads for that type. ITensor does this for certain functions for you, and we will discuss a few of these functions below. So if the code encounters an Index such as  Index(4,\"S=3/2\")  it can call these functions which are specialized for indices carrying the  \"S=3/2\"  tag. The space Function One of the overloadable  SiteType  functions is  space , whose job is to describe the vector space corresponding to that site type. For our  SiteType\"S=3/2\"  overload of  space , which gets called for any Index carrying the  \"S=3/2\"  tag, the definition is using ITensors, ITensorMPS\nITensors.space(::SiteType\"S=3/2\") = 4 Note that the function name is prepended with  ITensors.  before  space . This prefix makes sure the function is overloading other versions of the  space  inside the  ITensors  module. The only information needed about the vector space of a  \"S=3/2\"  Index in this example is that it is of dimension four. So the  space  function returns the integer  4 . We will see in more advanced examples that the returned value can instead be an array which specifies not only the dimension of a  \"S=3/2\"  Index, but also additional subspace structure it has corresponding to quantum numbers. After defining this  space  function, you can just write code like: using ITensors, ITensorMPS\ns = siteind(\"S=3/2\") to obtain a single  \"S=3/2\"  Index, or write code like using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=3/2\",N) to obtain an array of N  \"S=3/2\"  indices. The custom  space  function will be used to determine the dimension of these indices, and the  siteind  or  siteinds  functions provided by ITensor will help with extra things like putting other Index tags that are conventional for site indices. The op Function The  op  function lets you define custom local operators associated to the physical degrees of freedom of your  SiteType . Then for example you can use indices carrying your custom tag with OpSum and the OpSum system will know how to automatically convert names of operators such as  \"Sz\"  or  \"S+\"  into ITensors so that it can make an actual MPO. In our example above, we defined this function for the case of the  \"Sz\"  operator as: using ITensors, ITensorMPS\nITensors.op(::OpName\"Sz\",::SiteType\"S=3/2\") =\n  [+3/2   0    0    0\n     0  +1/2   0    0\n     0    0  -1/2   0\n     0    0    0  -3/2] As you can see, the function is passed two objects: an  OpName  and a  SiteType . The strings  \"Sz\"  and  \"S=3/2\"  are also part of the type of these objects, and have the meaning of which operator name we are defining and which site type these operators are defined for. The body of this overload of  ITensors.op  constructs and returns a Julia matrix which gives the matrix elements of the operator we are defining. Once this function is defined, and if you have an Index such as s = Index(4,\"S=3/2\") then, for example, you can get the  \"Sz\"  operator for this Index and print it out by doing: using ITensors, ITensorMPS\nSz = op(\"Sz\",s)\nprintln(Sz) ITensor ord=2\nDim 1: (dim=4|id=265|\"S=3/2\")'\nDim 2: (dim=4|id=265|\"S=3/2\")\nNDTensors.Dense{Float64, Vector{Float64}}\n 4×4\n 1.5  0.0   0.0   0.0\n 0.0  0.5   0.0   0.0\n 0.0  0.0  -0.5   0.0\n 0.0  0.0   0.0  -1.5 Again, through the magic of the  SiteType  system, the ITensor library takes your Index, reads off its tags, notices that one of them is  \"S=3/2\" , and converts this into the type  SiteType\"S=3/2\"  in order to call the specialized function  ITensors.op  defined above. You can use the  op  function yourself with a set of site indices created from the  siteinds  function like this: using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=3/2\",N)\nSz1 = op(\"Sz\",sites[1])\nSp3 = op(\"S+\",sites[3]) Alternatively, you can write the lines of code above in the style of  Sz1 = op(\"Sz\",sites,1) . This same  op  function is used inside of OpSum (formerly called AutoMPO) when it converts its input into an actual MPO. So by defining custom operator names you can pass any of these operator names into OpSum and it will know how to use these operators. Further Steps See how the built-in site types are defined inside the ITensor library: S=1/2 sites  - Dimension 2 local Hilbert space. Similar to the  \"Qubit\"  site type, shares many of the same operator definitions. Qubit sites  - Dimension 2 local Hilbert space. Similar to the  \"S=1/2\"  site type, shares many of the same operator definitions. S=1 sites  - Dimension 3 local Hilbert space. Fermion sites  - Dimension 2 local Hilbert space. Spinless fermion site type. Electron sites  - Dimension 4 local Hilbert space. Spinfull fermion site type. tJ sites  - Dimension 3 local Hilbert space. Spinfull fermion site type but without a doubly occupied state in the Hilbert space. Boson sites  - General d-dimensional local Hilbert space. Shares the same operator definitions as the  \"Qudit\"  site type. Qudit sites  - General d-dimensional local Hilbert space. Generalization of the  \"Qubit\"  site type, shares the same operator definitions as the  $Boson$  site type."},{"id":510,"pagetitle":"Physics (SiteType) System Examples","title":"Make a Custom Local Hilbert Space with QNs","ref":"/ITensorDocs/ITensorMPS/stable/examples/#Make-a-Custom-Local-Hilbert-Space-with-QNs","content":" Make a Custom Local Hilbert Space with QNs In the previous example above, we discussed the basic, minimal code needed to define a custom local Hilbert space, using the example of a  $S=3/2$  spin Hilbert space. In those examples, the  space  function defining the vector space of a  $S=3/2$  spin only provides the dimension of the space. But the Hilbert space of a  $S=3/2$  spin has additional structure, which is that each of its four subspaces (each of dimension 1) can be labeled by a different  $S^z$  quantum number. In this code formula we will include this extra quantum information in the definition of the space of a  $S=3/2$  spin. Code Preview First let's see the minimal code needed to add the option for including quantum numbers of our  $S=3/2$  site type, then we will discuss what each part of the code is doing. using ITensors, ITensorMPS\n\nfunction ITensors.space(::SiteType\"S=3/2\";\n                        conserve_qns=false)\n  if conserve_qns\n    return [QN(\"Sz\",3)=>1,QN(\"Sz\",1)=>1,\n            QN(\"Sz\",-1)=>1,QN(\"Sz\",-3)=>1]\n  end\n  return 4\nend\n\nITensors.op(::OpName\"Sz\",::SiteType\"S=3/2\") =\n  [+3/2   0    0    0\n     0  +1/2   0    0\n     0    0  -1/2   0\n     0    0    0  -3/2]\n\nITensors.op(::OpName\"S+\",::SiteType\"S=3/2\") =\n  [0  √3  0  0\n   0   0  2  0\n   0   0  0 √3\n   0   0  0  0]\n\nITensors.op(::OpName\"S-\",::SiteType\"S=3/2\") =\n  [0   0  0   0\n   √3  0  0   0\n   0   2  0   0\n   0   0  √3  0]\n\n Now let's look at each part of the code above. The space function In the previous code example above, we discussed that the function  space  tells the ITensor library the basic information about how to construct an Index associated with a special Index tag, in this case the tag  \"S=3/2\" . As in that code formula, if the user does not request that quantum numbers be included (the case  conserve_qns=false ) then all that the  space  function returns is the number 4, indicating that a  \"S=3/2\"  Index should be of dimension 4. But if the  conserve_qns  keyword argument gets set to  true , the  space  function we defined above returns an array of  QN=>Int  pairs. (The notation  a=>b  in Julia constructs a  Pair  object.) Each pair in the array denotes a subspace. The  QN  part of each pair says what quantum number the subspace has, and the integer following it indicates the dimension of the subspace. After defining the  space  function this way, you can write code like: using ITensors, ITensorMPS\ns = siteind(\"S=3/2\"; conserve_qns=true) to obtain a single  \"S=3/2\"  Index which carries quantum number information. The  siteind  function built into ITensor relies on your custom  space  function to ask how to construct a  \"S=3/2\"  Index but also includes some other Index tags which are conventional for all site indices. You can now also call code like: using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=3/2\",N; conserve_qns=true) to obtain an array of N  \"S=3/2\"  indices which carry quantum numbers. The op Function in the Quantum Number Case Note that the  op  function overloads are exactly the same as for the more basic case of defining an  \"S=3/2\"  Index type that does not carry quantum numbers. There is no need to upgrade any of the  op  functions for the QN-conserving case. The reason is that all QN, block-sparse information about an ITensor is deduced from the indices of the tensor, and setting elements of such tensors does not require any other special code. However, only operators which have a well-defined QN flux–-meaning they always change the quantum number of a state they act on by a well-defined amount–-can be used in practice in the case of QN conservation. Attempting to build an operator, or any ITensor, without a well-defined QN flux out of QN-conserving indices will result in a run time error. An example of an operator that would lead to such an error would be the \"Sx\" spin operator since it alternately increases  $S^z$  or decreases  $S^z$  depending on the state it acts on, thus it does not have a well-defined QN flux. But it is perfectly fine to define an  op  overload for the \"Sx\" operator and to make this operator when working with dense, non-QN-conserving ITensors or when  $S^z$  is not conserved."},{"id":513,"pagetitle":"DMRG FAQs","title":"Density Matrix Renormalization Group (DMRG) Frequently Asked Questions","ref":"/ITensorDocs/ITensorMPS/stable/faq/#Density-Matrix-Renormalization-Group-(DMRG)-Frequently-Asked-Questions","content":" Density Matrix Renormalization Group (DMRG) Frequently Asked Questions"},{"id":514,"pagetitle":"DMRG FAQs","title":"Ensuring a DMRG calculation is converged","ref":"/ITensorDocs/ITensorMPS/stable/faq/#Ensuring-a-DMRG-calculation-is-converged","content":" Ensuring a DMRG calculation is converged While DMRG calculations can be extremely quick to converge in the best cases, convergence can be slower for cases such as gapless systems or quasi-two-dimensional systems. So it becomes important to know if a DMRG calculation is converged i.e. has been run long enough with enough resources (large enough MPS bond dimension). Unfortunately  there is no automatic or bulletproof check for DMRG convergence . However, there are a number of reliable heuristics you can use to check convergence. We list some of these with the most fundamental and important ones first: Run your DMRG calculation on a  smaller system  and compare with another method, such as an exact diagonalization. If the agreement is good, then gradually try larger systems and see if the physical properties are roughly consistent and similar (i.e. the density profile has similar features). Make sure to check a  wide range of properties  - not just the energy. See if these look plausible by plotting and visually inspecting them. For example: if your system has left-right reflection symmetry, does the density or magnetization also have this symmetry? If the ground  state of your system is expected to have a total  $S^z$  of zero, does your ground state have this property? Make sure to run your DMRG calculation for  different numbers of sweeps  to see if the results change. For example, if you run DMRG for 5 sweeps but are unsure of convergence, try running it for 10 sweeps: is the energy the same or has it significantly decreased? If 10 sweeps made a difference, try 20 sweeps. Try setting the  eigsolve_krylovdim  keyword argument to a higher value (the default is 3). This can be particularily helpful when the Hamiltonian is close to a critical point. This may make slowly-converging calculations converge in fewer sweeps, but setting it too high can make each sweep run slowly. Inspect the the  DMRG output . The ITensor DMRG code reports the maximum bond or link dimension and maximum truncation error after each sweep. (The maximums here mean over each DMRG substep making up one sweep.) Is the maximum dimension or \"maxlinkdim\" reported by the DMRG output quickly reaching and saturating the maxdim value you set for each sweep? Is the maximum truncation error \"maxerr\" consistently reaching large values, larger than 1E-5? Then it you may need to raise the maxdim parameter for your later sweeps, so that DMRG is allowed to use a larger bond dimension and thus reach a better accuracy. Compute the  energy variance  of an MPS to check whether it is an eigenstate. To do this in ITensor, you can use the following code where  H  is your Hamiltonian MPO and  psi  is the wavefunction you want to check: H2 = inner(H,psi,H,psi)\nE = inner(psi',H,psi)\nvar = H2-E^2\n@show var Here  var  is the quantity  $\\langle H^2 \\rangle - \\langle H \\rangle^2$ . The closer  var  is to zero, the more precisely  psi  is an eigenstate of  H . Note that this check does not ensure that  psi  is the ground state, but only one of the eigenstates."},{"id":515,"pagetitle":"DMRG FAQs","title":"Preventing DMRG from getting stuck in a local minimum","ref":"/ITensorDocs/ITensorMPS/stable/faq/#Preventing-DMRG-from-getting-stuck-in-a-local-minimum","content":" Preventing DMRG from getting stuck in a local minimum While DMRG has very robust convergence properties when the initial MPS is close to the global minimum, if it is far from the global minumum then there is  no guarantee  that DMRG will be able to find the true ground state. This problem is exacerbated for quantum number conserving DMRG where the search space is more constrained. Thus it is very important to perform a number of checks to ensure that the result you get from DMRG is actually converged. To learn about these checks, see the previous question. When DMRG is failing to converge, here are some of the steps you can take to improve things: The most important and useful technique  is to turn on the  noise term  feature of DMRG. To do this, just set the  noise  parameter of each sweep to a small, non-zero value, making this value very small (1E-11, say) or zero by the last sweep. (Experiment with different values on small systems to see which noise magnitudes help.) Here is an example of defining DMRG accuracy or sweep parameters with a non-zero noise set for the first three sweeps: nsweeps = 10\nmaxdim = [100, 200, 400, 800, 1600]\ncutoff = [1E-6]\nnoise = [1E-6, 1E-7, 1E-8, 0.0]\n...\nenergy, psi = dmrg(H,psi0; nsweeps, maxdim, cutoff, noise) Try using a initial MPS with properties close to the ground state you are looking for. For example, the ground state of a system of electrons typically has a density which is spread out over the whole system. So if your initial state has all of the electrons bunched up on the left-hand side only, it can take DMRG a very long time to converge. Try using a random MPS with a modestly large bond dimension. ITensor offers a function called  random_mps  which can be used to make random MPS in both the quantum number (QN) conserving and non-QN conserving cases. Because random MPS have properties which are \"typical\" of most ground states, they can be good initial states for DMRG. Try DMRG on a closely related Hamiltonian for which convergence is easier to obtain (be creative here: it could be your Hamiltonian with interactions turned off, or  with interactions only within, but not between, small local patches). Take the output of this first calculation and use it as input for DMRG with the full Hamiltonian. In stubborn cases, try other methods for finding the ground state which are slower, but have a better chance of succeeding. A key example is imaginary time evolution, which always reaches the ground state if (a) performed accurately on (b) a state which is not orthogonal to the ground state. After doing some amount of imaginary time evolution, use the resulting MPS as an initial state for DMRG obtain a higher-accuracy solution."},{"id":516,"pagetitle":"DMRG FAQs","title":"How to do periodic boundary condition DMRG","ref":"/ITensorDocs/ITensorMPS/stable/faq/#How-to-do-periodic-boundary-condition-DMRG","content":" How to do periodic boundary condition DMRG The short answer to how to do fully periodic boundary condition DMRG in ITensor is that you simply input a  periodic Hamiltonian  into our OpSum system and make the MPO form of your Hamiltonian in the usual way. For example, for a chain of N sites with nearest-neighbor interactions, you include a term that connects site 1 to site N. For a one-dimensional Ising model chain Hamiltonian this would look like: sites = siteinds(\"S=1/2\",N)\n\nhterms = OpSum()\nfor j=1:(N-1)\n  hterms += \"Sz\",j,\"Sz\",j+1\nend\nhterms += \"Sz\",1,\"Sz\",N  # term 'wrapping' around the ring\n\nH = MPO(hterms,sites) For two-dimensional DMRG calculations, where the most common approach is to use periodic boundary conditions in the y-direction only, and not in the x-direction, you do a similar step in making your OpSum input to ITensor DMRG: you include terms wrapping around the periodic cylinder in the y direction but not in the x direction. However, fully periodic boundary conditions are only recommended for small systems when absolutely needed, and in general are not recommended. For a longer discussion of alternatives to using fully periodic boundaries, see the next section below. The reason fully periodic boundary conditions (periodic in x in 1D, and periodic in both x and y in 2D) are not recommended in general is that the DMRG algorithm, as we are defining it here, optimizes an  open-boundary MPS . So if you input a periodic-boundary Hamiltonian, there is a kind of \"mismatch\" that happens where you can still get the correct answer, but it requires much more resources (a larger bond dimension and more sweeps) to get good accuracy. There has been some research into \"truly\" periodic DMRG,  [Pippan]  that is DMRG that optimizes an MPS with a ring-like topology, but it is not widely used, is still an open area of algorithm development, and is not currently available in ITensor."},{"id":517,"pagetitle":"DMRG FAQs","title":"What boundary conditions should I choose: open, periodic, or infinite?","ref":"/ITensorDocs/ITensorMPS/stable/faq/#What-boundary-conditions-should-I-choose:-open,-periodic,-or-infinite?","content":" What boundary conditions should I choose: open, periodic, or infinite? One of the weaknesses of the density matrix renormalization group (DMRG), and its time-dependent or finite-temperature extensions, is that it works poorly with periodic boundary conditions. This stems from the fact that conventional DMRG optimizes over open-boundary matrix product state (MPS) wavefunctions whether or not the Hamiltonian includes periodic interactions. But this begs the question, when are periodic boundary conditions (PBC) really needed? DMRG offers some compelling alternatives to PBC: Use open boundary conditions (OBC). Though this introduces edge effects, the number of states needed to reach a given accuracy is  significantly  lower than with PBC (see next section below). For gapped systems DMRG scales linearly with system size, meaning often one can study systems with many hundreds or even thousands of sites. Last but not least, open boundaries are often more natural. For studying systems which spontaneously break symmetry, adding \"pinning\" fields on the edge is often a very nice way to tip the balance toward a certain symmetry broken state while leaving the bulk unmodified. Use smooth boundary conditions. The basic idea is to use OBC but send the Hamiltonian parameters smoothly to zero at the boundary so that the system can not \"feel\" the boundary. For certain systems this can significantly reduce edge effects. [Smooth1] [Smooth2] [Smooth3] Use \"infinite boundary conditions\", that is, use infinite DMRG in the form of an algorithm like iDMRG or VUMPS. This has a cost that can be even less than with OBC yet is completely free of finite-size effects. However, there are a handful of cases where PBC remains preferable despite the extra overhead. A few such cases are: Benchmarking DMRG against another code that uses PBC, such as a Monte Carlo or exact diagonalization code. Extracting the central charge of a critical one-dimensional system described by a CFT. In practice, using PBC can give an accurate central charge even for quite small systems by fitting the subsystem entanglement entropy to the CFT scaling form. Checking for the presence or absence of topological effects. These could be edge effects (the Haldane phase has a four-fold ground state degeneracy with OBC, but not with PBC), or could be related to some global topological sector that is ill-defined with PBC (e.g. periodic vs. antiperiodic boundary conditions for the transverse field Ising model). (Note that in the remaining discussion, by PBC I mean   fully periodic  boundary conditions in all directions. For the case of DMRG applied to quasi-two-dimensional systems, it remains a good practice to use periodic boundaries in the shorter direction, while still using open (or infinite) boundaries in the longer direction along the DMRG/MPS path.) Below I discuss more about the problems with using PBC, as well as some misconceptions about when PBC seems necessary even though there are better alternatives."},{"id":518,"pagetitle":"DMRG FAQs","title":"Drawbacks of Periodic Boundary Conditions","ref":"/ITensorDocs/ITensorMPS/stable/faq/#Drawbacks-of-Periodic-Boundary-Conditions","content":" Drawbacks of Periodic Boundary Conditions Periodic boundary conditions are straightforward to implement in conventional DMRG. The simplest approach is to include a \"long bond\" directly connecting site 1 to site N in the Hamiltonian. However this naive approach has a major drawback: if open-boundary DMRG achieves a given accuracy when keeping  $m$  states (bond dimension of size  $m$ ), then to reach the same accuracy with PBC one must keep closer to  $m^2$  states! The reason is that now every bond of the MPS not only carries local entanglement as with OBC, but also the entanglement between the first and last sites. (There is an alternative DMRG algorithm [Pippan]  for periodic systems which may have better scaling than the above approach but has not been widely applied and tested, as far as I am aware, especially for  2D or critical systems .) The change in scaling from  $m$  to  $m^2$   is a severe problem. For example, many gapped one-dimensional systems only require about  $m=100$  to reach good accuracy (truncation errors of less than 1E-9 or so). To reach the same accuracy with naive PBC would then require using 10,000 states, which can easily fill the RAM of a typical desktop computer for a large enough system, not to mention the extra time needed to work with larger matrices. But poor scaling is not the only drawback of PBC. Systems that exhibit spontaneous symmetry breaking are simple to work with under OBC, where one has the additional freedom of applying edge pinning terms to drive the bulk into a specific symmetry sector. Using edge pinning reduces the bulk entanglement and makes measuring order parameters straightforward. Similarly one can use infinite DMRG to directly observe symmetry breaking effects. But under PBC, order parameters remain equal to zero and can only be accessed through correlation functions. Though using correlation functions is often presented as the \"standard\" or \"correct\" approach, such reasoning pre-supposes that PBC is the best choice. Recent work in the quantum Monte Carlo community demonstrates that open boundaries with pinning fields can actually be a superior approach. [Assaad]"},{"id":519,"pagetitle":"DMRG FAQs","title":"Cases Where Periodic BC Seems Necessary, But Open/Infinite BC Can be Better","ref":"/ITensorDocs/ITensorMPS/stable/faq/#Cases-Where-Periodic-BC-Seems-Necessary,-But-Open/Infinite-BC-Can-be-Better","content":" Cases Where Periodic BC Seems Necessary, But Open/Infinite BC Can be Better Below are some cases where periodic boundary conditions seem to be necessary at a first glance. But in many of these cases, not only can open or infinite boundaries be just as successful, they can even be the better choice. Measuring asymptotic properties of correlation functions : much of our understanding of gapless one-dimensional systems comes from field-theoretic approaches which make specific predictions about asymptotic decays of various correlators. To test these predictions numerically, one must  work with large, translationally invariant systems with minimal edge effects. Using fully periodic boundary conditions satisfies these criteria. However, a superior choice is to use infinite DMRG, which combines the much better scaling of open-boundary DMRG with the ability to  measure correlators at  arbitrarily long  distances by repeating the unit cell of the MPS wavefunction. Although truncating to a finite number of states imposes an effective correlation length on the system, this correlation length can reach many thousands of sites for quite moderate MPS bond dimensions. Karrasch and Moore took advantage of this fact to convincingly check the predictions of Luttinger liquid theory for one-dimensional systems of gapless fermions. [Karrasch] Studying two-dimensional topological order : a hallmark of intrinsic topological order is the presence of a robust ground state degeneracy when the system is put on a torus. Also many topological phases  have gapless edge states which can cause problems for numerical calculations. Thus one might think that fully periodic BC are the best choice for studying topological phases. However,  topological phases have the same ground-state degeneracy on an infinite cylinder as they do on a torus. [Zhang] . Cincio and Vidal exploited this fact to use infinite DMRG to study a variety of topological phases  [Cincio] . One part of their calculation did actually require obtaining ground states on a torus, but they accomplished this by taking a finite segment of an infinite MPS  and connecting its ends. This approach does not give the true ground state of the torus but was sufficient  for their calculation and was arguably closer to the true two-dimensional physics. Obtaining bulk gaps : DMRG has the ability to \"target\" low-lying excited states or to obtain such states by constraining them to be orthogonal to the ground state. However, with OBC, localized excitations can get stuck to the edges and not reveal the true bulk gap behavior. Thus one may conclude that PBC is necessary. But using open or infinite boundaries remains the better choice because they allow much higher accuracy. To deal with the presence of edges in OBC, one can use \"restricted sweeping\". Here one sweeps across the full system to obtain the ground state. Then, to obtain the first excited state one only sweeps through the full system to obtain the ground state. Then, to obtain the first excited state one only sweeps through the near the edges. This traps the particle in a \"soft box\" which still lets its wavefunction mix with the basis that describes the ground state outside the restricted sweeping region. Within infinite DMRG, boundary effects are rigorously absent if the calculation has converged. To compute bulk gaps one again uses a type of restricted sweeping known in the literature as \"infinite boundary conditions\". For more see the work by Phien, Vidal, and McCulloch. [Phien] In conclusion, consider carefully whether you really need to use periodic boundary conditions, as they impose a steep computational cost within DMRG. Periodic BC can actually be worse for the very types of measurements where they are  often presented as the best or \"standard\" choice. Many of the issues periodic boundaries circumvent can be avoided more elegantly by using infinite DMRG, or when that is not applicable, by using open boundary conditions with sufficient care. Smooth1 Smooth boundary conditions for quantum lattice systems , M. Vekic and Steven R. White,  Phys. Rev. Lett. 71 ,  4283  (1993) cond-mat/ 9310053 Smooth2 Hubbard model with smooth boundary conditions , M. Vekic and Steven R. White,  Phys. Rev. B 53 ,  14552  (1996) cond-mat/ 9601009 Smooth3 Grand canonical finite-size numerical approaches: A route to measuring bulk properties in an applied field , Chisa Hotta and Naokazu Shibata,  Phys. Rev. B 86 ,  041108  (2012) Pippan Efficient matrix-product state method for periodic boundary conditions , P. Pippan, Steven R. White, and H.G. Evertz,  Phys. Rev. B 81 ,  081103 Assaad Pinning the Order: The Nature of Quantum Criticality in the Hubbard Model on Honeycomb Lattice , Fakher F. Assaad and Igor F. Herbut,  Phys. Rev. X 3 ,  031010 Karrasch Luttinger liquid physics from the infinite-system density matrix renormalization group , C. Karrasch and J.E. Moore,  Phys. Rev. B 86 ,  155156 Zhang Quasiparticle statistics and braiding from ground-state entanglement , Yi Zhang, Tarun Grover, Ari Turner, Masaki Oshkawa, and Ashvin Vishwanath,  Phys. Rev. B 85 ,  235151 Cincio Characterizing Topological Order by Studying the Ground States on an Infinite Cylinder , L. Cincio and G. Vidal,  Phys. Rev. Lett. 110 ,  067208 Phien Infinite boundary conditions for matrix product state calculations , Ho N. Phien, G. Vidal, and Ian P. McCulloch  Phys. Rev. B 86 ,  245107"},{"id":522,"pagetitle":"Quantum Number (QN) FAQs","title":"Quantum Number Frequently Asked Questions","ref":"/ITensorDocs/ITensorMPS/stable/faq/#Quantum-Number-Frequently-Asked-Questions","content":" Quantum Number Frequently Asked Questions"},{"id":523,"pagetitle":"Quantum Number (QN) FAQs","title":"Can I mix different types of quantum numbers within the same system?","ref":"/ITensorDocs/ITensorMPS/stable/faq/#Can-I-mix-different-types-of-quantum-numbers-within-the-same-system?","content":" Can I mix different types of quantum numbers within the same system? Yes, you can freely mix quantum numbers (QNs) of different types. For example, you can make the sites of your systems alternate between sites carrying spin \"Sz\" QNs and fermion sites carrying particle number \"Nf\" QNs. The QNs will not mix with each other and will separately be conserved to the original value you set for your initial wavefunction."},{"id":524,"pagetitle":"Quantum Number (QN) FAQs","title":"How can I separately conserve QNs which have the same name?","ref":"/ITensorDocs/ITensorMPS/stable/faq/#How-can-I-separately-conserve-QNs-which-have-the-same-name?","content":" How can I separately conserve QNs which have the same name? If you have two physically distinct types of sites, such as \"Qudit\" sites, but which carry identically named QNs called \"Number\", and you want the qudit number to be separately conserved within each type of site, you must make the QN names different for the two types of sites. For example, the following line of code will make an array of site indices with the qudit number QN having the name \"Number_odd\" on odd sites and \"Number_even\" on even sites: sites = [isodd(n) ? siteind(\"Qudit\", n; dim=10, conserve_qns=true, qnname_number=\"Number_odd\")\n                  : siteind(\"Qudit\", n; dim=2, conserve_qns=true, qnname_number=\"Number_even\")\n                  for n in 1:2*L] (You may have to collapse the above code into a single line for it to run properly.)"},{"id":527,"pagetitle":"DMRG","title":"DMRG Tutorial","ref":"/ITensorDocs/ITensorMPS/stable/tutorials/#dmrg_tutorial","content":" DMRG Tutorial The  density matrix renormalization group (DMRG)  is an algorithm for computing eigenstates of Hamiltonians (or extremal eigenvectors of large, Hermitian matrices). It computes these eigenstates in the  matrix product state (MPS)  format. Let's see how to set up and run a DMRG calculation using the ITensor library. We will be interested in finding the ground state of the quantum Hamiltonian  $H$  given by: \\[H = \\sum_{j=1}^{N-1} \\mathbf{S}_{j} \\cdot \\mathbf{S}_{j+1} = \\sum_{j=1}^{N-1} S^z_{j} S^z_{j+1} + \\frac{1}{2} S^+_{j} S^-_{j+1} + \\frac{1}{2} S^-_{j} S^+_{j+1}\\] This Hamiltonian is known as the one-dimensional Heisenberg model and we will take the spins to be  $S=1$  spins (spin-one spins). We will consider the case of  $N=100$  and plan to do five sweeps of DMRG (five passes over the system). ITensor DMRG Code Let's look at an entire, working ITensor code that will do this calculation then discuss the main steps. If you need help running the code below, see the getting started page on  Running ITensor and Julia Codes . using ITensors, ITensorMPS\nlet\n  N = 100\n  sites = siteinds(\"S=1\",N)\n\n  os = OpSum()\n  for j=1:N-1\n    os += \"Sz\",j,\"Sz\",j+1\n    os += 1/2,\"S+\",j,\"S-\",j+1\n    os += 1/2,\"S-\",j,\"S+\",j+1\n  end\n  H = MPO(os,sites)\n\n  psi0 = random_mps(sites;linkdims=10)\n\n  nsweeps = 5\n  maxdim = [10,20,100,100,200]\n  cutoff = [1E-10]\n\n  energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff)\n\n  return\nend Steps of The Code The first two lines using ITensors, ITensorMPS\nN = 100\nsites = siteinds(\"S=1\",N) tells the function  siteinds  to make an array of ITensor  Index  objects which have the properties of  $S=1$  spins. This means their dimension will be 3 and they will carry the  \"S=1\"  tag, which will enable the next part of the code to know how to make appropriate operators for them. Try printing out some of these indices to verify their properties: @show sites[1] (dim=3|id=28|\"S=1,Site,n=1\") The next part of the code builds the Hamiltonian: os = OpSum()\nfor j=1:N-1\n  os += \"Sz\",j,\"Sz\",j+1\n  os += 1/2,\"S+\",j,\"S-\",j+1\n  os += 1/2,\"S-\",j,\"S+\",j+1\nend\nH = MPO(os,sites) An  OpSum  is an object which accumulates Hamiltonian terms such as  \"Sz\",1,\"Sz\",2  so that they can be summed afterward into a matrix product operator (MPO) tensor network. The line of code  H = MPO(os,sites)  constructs the Hamiltonian in the MPO format, with physical indices given by the array  sites . The line psi0 = random_mps(sites;linkdims=10) constructs an MPS  psi0  which has the physical indices  sites  and a bond dimension of 10. It is made by a random quantum circuit that is reshaped into an MPS, so that it will have as generic and unbiased properties as an MPS of that size can have. This choice can help prevent the DMRG calculation from getting stuck in a local minimum. The lines nsweeps = 5\nmaxdim = [10,20,100,100,200]\ncutoff = [1E-10] define the number of DMRG sweeps (five) we will instruct the code to do, as well as the parameters that will control the speed and accuracy of the DMRG algorithm within each sweep. The array  maxdim  limits the maximum MPS bond dimension allowed during each sweep and  cutoff  defines the truncation error goal of each sweep (if fewer values are specified than sweeps, the last value is used for all remaining sweeps). Finally the call energy,psi = dmrg(H,psi0;nsweeps,maxdim,cutoff) runs the DMRG algorithm included in ITensor, using  psi0  as an initial guess for the ground state wavefunction. The optimized MPS  psi  and its eigenvalue  energy  are returned. After the  dmrg  function returns, you can take the returned MPS  psi  and do further calculations with it, such as measuring local operators or computing entanglement entropy."},{"id":530,"pagetitle":"MPS Time Evolution","title":"MPS Time Evolution","ref":"/ITensorDocs/ITensorMPS/stable/tutorials/#MPS-Time-Evolution","content":" MPS Time Evolution An important application of  matrix product state (MPS)  tensor networks in physics is computing the time evolution of a quantum state under the dynamics of a Hamiltonian  $H$ . An accurate, efficient, and simple way to time evolve a matrix product state (MPS) is by using a Trotter decomposition of the time evolution operator  $U(t) = e^{-i H t}$ . The technique we will use is \"time evolving block decimation\" (TEBD). More simply it is just the idea of decomposing the time-evolution operator into a circuit of quantum 'gates' (two-site unitaries) using the Trotter-Suzuki approximation and applying these gates in a controlled way to an MPS. Let's see how to set up and run a TEBD calculation using ITensor. The Hamiltonian  $H$  we will use is the one-dimensional Heisenberg model which is given by: \\[\\begin{aligned}\nH & = \\sum_{j=1}^{N-1} \\mathbf{S}_{j} \\cdot \\mathbf{S}_{j+1}  \\\\\n& = \\sum_{j=1}^{N-1} S^z_{j} S^z_{j+1} + \\frac{1}{2} S^+_{j} S^-_{j+1} + \\frac{1}{2} S^-_{j} S^+_{j+1}\n\\end{aligned}\\] The TEBD Method When the Hamiltonian, like the one above, is a sum of local terms, \\[H = \\sum_j h_{j,j+1}\\] where  $h_{j,j+1}$  acts on sites j and j+1, then a Trotter decomposition that is particularly well suited for use with MPS techniques is \\[e^{-i \\tau H} \\approx e^{-i h_{1,2} \\tau/2} e^{-i h_{2,3} \\tau/2} \\cdots e^{-i h_{N-1,N} \\tau/2}\ne^{-i h_{N-1,N} \\tau/2} e^{-i h_{N-2,N-1} \\tau/2} \\cdots e^{-i h_{1,2} \\tau/2} + O(\\tau^3)\\] Note the factors of two in each exponential. Each factored exponential is known as a Trotter \"gate\". We can visualize the resulting circuit that will be applied to the MPS as follows: The error in the above decomposition is of order  $\\tau^3$ , so that will be the error accumulated  per time step . Because of the time-step error, one takes  $\\tau$  to be small and then applies the above set of operators to an MPS as a single sweep, then does a number  $(t/\\tau)$  of sweeps to evolve for a total time  $t$ . The total error will therefore scale as  $\\tau^2$  with this scheme, though other sources of error may dominate for long times, or very small  $\\tau$ , such as truncation errors. Let's take a look at the code to apply these Trotter gates to an MPS to time evolve it. Then we will break down the steps of the code in more detail. ITensor TEBD Time Evolution Code Let's look at an entire, working ITensor code that will do this calculation then discuss the main steps. (If you need help running the code below, see the getting started page on running ITensor codes.) using ITensors, ITensorMPS\n\nlet\n  N = 100\n  cutoff = 1E-8\n  tau = 0.1\n  ttotal = 5.0\n\n  # Make an array of 'site' indices\n  s = siteinds(\"S=1/2\", N; conserve_qns=true)\n\n  # Make gates (1,2),(2,3),(3,4),...\n  gates = ITensor[]\n  for j in 1:(N - 1)\n    s1 = s[j]\n    s2 = s[j + 1]\n    hj =\n      op(\"Sz\", s1) * op(\"Sz\", s2) +\n      1 / 2 * op(\"S+\", s1) * op(\"S-\", s2) +\n      1 / 2 * op(\"S-\", s1) * op(\"S+\", s2)\n    Gj = exp(-im * tau / 2 * hj)\n    push!(gates, Gj)\n  end\n  # Include gates in reverse order too\n  # (N,N-1),(N-1,N-2),...\n  append!(gates, reverse(gates))\n\n  # Initialize psi to be a product state (alternating up and down)\n  psi = MPS(s, n -> isodd(n) ? \"Up\" : \"Dn\")\n\n  c = div(N, 2) # center site\n\n  # Compute and print <Sz> at each time step\n  # then apply the gates to go to the next time\n  for t in 0.0:tau:ttotal\n    Sz = expect(psi, \"Sz\"; sites=c)\n    println(\"$t $Sz\")\n\n    t≈ttotal && break\n\n    psi = apply(gates, psi; cutoff)\n    normalize!(psi)\n  end\n\n  return\nend Steps of The Code First we setsome parameters, like the system size N and time step  $\\tau$  to use. The line  s = siteinds(\"S=1/2\",N;conserve_qns=true)  defines an array of spin 1/2 tensor indices (Index objects) which will be the site or physical indices of the MPS. Next we make an empty array  gates = ITensor[]  that will hold ITensors that will be our Trotter gates. Inside the  for n=1:N-1  loop that follows the lines hj =      op(\"Sz\",s1) * op(\"Sz\",s2) +\n    1/2 * op(\"S+\",s1) * op(\"S-\",s2) +\n    1/2 * op(\"S-\",s1) * op(\"S+\",s2) call the  op  function which reads the \"S=1/2\" tag on our site indices (sites j and j+1) and which then knows that we want the spin 1/ 2 version of the \"Sz\", \"S+\", and \"S-\" operators. The  op  function returns these operators as ITensors and we tensor product and add them together to compute the operator  $h_{j,j+1}$  defined as \\[h_{j,j+1} = S^z_j S^z_{j+1} + \\frac{1}{2} S^+_j S^-_{j+1} + \\frac{1}{2} S^-_j S^+_{j+1}\\] which we call  hj  in the code. To make the corresponding Trotter gate  Gj  we exponentiate  hj  times a factor  $-i \\tau/2$  and then append or push this onto the end of the gate array  gates . Gj = exp(-im * tau/2 * hj)\npush!(gates,Gj) Having made the gates for bonds (1,2),(2,3),(3,4), etc. we still need to append the gates in reverse order to complete the correct Trotter formula. Here we can conveniently do that by just calling the Julia  append!  function and supply a reversed version of the array of gates we have made so far. This can be done in a single line of code  append!(gates,reverse(gates)) . The line of code  psi = MPS(s, n -> isodd(n) ? \"Up\" : \"Dn\")  initializes our MPS  psi  as a product state of alternating up and down spins. To carry out the time evolution we loop over the range of times from 0.0 to  ttotal  in steps of  tau , using the Julia range notation  0.0:tau:ttotal  to easily set up this loop as  for t in 0.0:tau:ttotal . Inside the loop, we use the  expect  function to measure the expected value of the  \"Sz\"  operator on the center site. To evolve the MPS to the next time, we call the function psi = apply(gates, psi; cutoff) which applies the array of ITensors called  gates  to our current MPS  psi , truncating the MPS at each step using the truncation error threshold supplied as the variable  cutoff . The  apply  function is smart enough to determine which site indices each gate has, and then figure out where to apply it to our MPS. It automatically handles truncating the MPS and can even handle non-nearest-neighbor gates, though that feature is not used in this example."},{"id":533,"pagetitle":"Quantum Number Conserving DMRG","title":"Quantum Number Conserving DMRG","ref":"/ITensorDocs/ITensorMPS/stable/tutorials/#Quantum-Number-Conserving-DMRG","content":" Quantum Number Conserving DMRG An important technique in DMRG calculations of quantum Hamiltonians is the conservation of  quantum numbers . Examples of these are the total number of particles of a model of fermions, or the total of all  $S^z$  components of a system of spins. Not only can conserving quantum numbers make DMRG calculations run more quickly and use less memory, but it can be important for simulating physical systems with conservation laws and for obtaining ground states in different symmetry sectors. Note that ITensor currently only supports Abelian quantum numbers."},{"id":534,"pagetitle":"Quantum Number Conserving DMRG","title":"Necessary Changes","ref":"/ITensorDocs/ITensorMPS/stable/tutorials/#Necessary-Changes","content":" Necessary Changes Setting up a quantum-number conserving DMRG calculation in ITensor requires only very small changes to a DMRG code. The main changes are: using tensor indices ( Index  objects) which carry quantum number (QN) information to build your Hamiltonian and  initial state initializing your MPS to have well-defined total quantum numbers Importantly,  the total QN of your state throughout the calculation will remain the same as the initial state passed to DMRG . The total QN of your state is not set separately, but determined implicitly from the initial QN of the state when it is first constructed. Of course, your Hamiltonian should conserve all of the QN's that you would like to use. If it doesn't, you will get an error when you try to construct it out of the QN-enabled tensor indices."},{"id":535,"pagetitle":"Quantum Number Conserving DMRG","title":"Making the Changes","ref":"/ITensorDocs/ITensorMPS/stable/tutorials/#Making-the-Changes","content":" Making the Changes Let's see how to make these two changes to the  DMRG Tutorial  code from the previous section. At the end, we will put together these changes for a complete, working code. Change 1: QN Site Indices To make change (1), we will change the line sites = siteinds(\"S=1\",N) by setting the  conserve_qns  keyword argument to  true : sites = siteinds(\"S=1\",N; conserve_qns=true) Setting  conserve_qns=true  tells the  siteinds  function to conserve every possible quantum number associated to the site type (which is  \"S=1\"  in this example). For  $S=1$  spins, this will turn on total- $S^z$  conservation. (For other site types that conserve multiple QNs, there are specific keyword arguments available to track just a subset of conservable QNs.) We can check this by printing out some of the site indices, and seeing that the subspaces of each  Index  are labeled by QN values: @show sites[1]\n@show sites[2] Sample output:  sites[1] = (dim=3|id=794|\"S=1,Site,n=1\") <Out>\n 1: QN(\"Sz\",2) => 1\n 2: QN(\"Sz\",0) => 1\n 3: QN(\"Sz\",-2) => 1\n sites[2] = (dim=3|id=806|\"S=1,Site,n=2\") <Out>\n 1: QN(\"Sz\",2) => 1\n 2: QN(\"Sz\",0) => 1\n 3: QN(\"Sz\",-2) => 1 In the sample output above, note that in addition to the dimension of these indices being 3, each of the three settings of the Index have a unique QN associated to them. The number after the QN on each line is the dimension of that subspace, which is 1 for each subspace of the Index objects above. Note also that  \"Sz\"  quantum numbers in ITensor are measured in units of  $1/2$ , so  QN(\"Sz\",2)  corresponds to  $S^z=1$  in conventional physics units. Change 2: Initial State To make change (2), instead of constructing the initial MPS  psi0  to be an arbitrary, random MPS, we will make it a specific state with a well-defined total  $S^z$ . So we will replace the line psi0 = random_mps(sites;linkdims=10) by the lines state = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\npsi0 = MPS(sites,state) The first line of the new code above makes an array of strings which alternate between  \"Up\"  and  \"Dn\"  on odd and even numbered sites. These names  \"Up\"  and  \"Dn\"  are special values associated to the  \"S=1\"  site type which indicate up and down spin values. The second line takes the array of site Index objects  sites  and the array of strings  state  and returns an MPS which is a product state (classical, unentangled state) with each site's state given by the strings in the  state  array. In this example,  psi0  will be a Neel state with alternating up and down spins, so it will have a total  $S^z$  of zero. We could check this by computing the quantum-number flux of  psi0 @show flux(psi0)\n# Output: flux(psi0) = QN(\"Sz\",0) Setting Other Total QN Values The above example shows the case of setting a total \"Sz\" quantum number of zero, since the initial state alternates between \"Up\" and \"Dn\" on every site with an even number of sites. To obtain other total QN values, just set the initial state to be one which has the total QN you want. To be concrete let's take the example of a system with  N=10  sites of  $S=1$  spins. For example if you want a total \"Sz\" of +20 (=  QN(\"Sz\",20) ) in ITensor units, or  $S^z=10$  in physical units, for a system with 10 sites, use the initial state: state = [\"Up\" for n=1:N]\npsi0 = MPS(sites,state) Or to initialize this 10-site system to have a total \"Sz\" of +16 in ITensor units ( $S^z=8$  in physical units): state = [\"Dn\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\"]\npsi0 = MPS(sites,state) would work (as would any  state  with one \"Dn\" and nine \"Up\"'s in any order). Or you could initialize to a total \"Sz\" of +18 in ITensor units ( $S^z=9$  in physical units) as state = [\"Z0\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\",\"Up\"]\npsi0 = MPS(sites,state) where \"Z0\" refers to the  $S^z=0$  state of a spin-one spin. Finally, the same kind of logic as above applies to other physical site types, whether \"S=1/2\", \"Electron\", etc."},{"id":536,"pagetitle":"Quantum Number Conserving DMRG","title":"Putting it All Together","ref":"/ITensorDocs/ITensorMPS/stable/tutorials/#Putting-it-All-Together","content":" Putting it All Together Let's take the  DMRG Tutorial  code from the previous section and make the changes discussed above, to turn it into a code which conserves the total  $S^z$  quantum number throughout the DMRG calculation. The resulting code is: using ITensors, ITensorMPS\nlet\n  N = 100\n  sites = siteinds(\"S=1\",N;conserve_qns=true)\n\n  os = OpSum()\n  for j=1:N-1\n    os += \"Sz\",j,\"Sz\",j+1\n    os += 1/2,\"S+\",j,\"S-\",j+1\n    os += 1/2,\"S-\",j,\"S+\",j+1\n  end\n  H = MPO(os,sites)\n\n  state = [isodd(n) ? \"Up\" : \"Dn\" for n=1:N]\n  psi0 = MPS(sites,state)\n  @show flux(psi0)\n\n  nsweeps = 5\n  maxdim = [10,20,100,100,200]\n  cutoff = [1E-10]\n\n  energy, psi = dmrg(H,psi0; nsweeps, maxdim, cutoff)\n\n  return\nend"}]